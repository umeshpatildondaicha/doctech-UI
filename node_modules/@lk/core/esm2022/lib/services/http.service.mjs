import { Injectable } from '@angular/core';
import { HttpClient, HttpEventType, HttpHeaders } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { filter, map } from 'rxjs/operators';
import { Observe, ResponseType } from '../enums/http.enum';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common/http";
import * as i2 from "./http-util.service";
/**
 * Injectable decorator to provide the service at the root level
 */
/**
 * HttpService class
 */
export class HttpService {
    /**
     * Creates an instance of HttpService.
     * @param http - The HttpClient instance for making HTTP requests.
     * @param httpUtil - The HttpUtilService instance for handling HTTP utilities.
     * @param coreUtils - The CoreUtilService instance for core utility functions.
     * @param httpbackend - The HttpBackend instance for handling HTTP requests.
     */
    constructor(http, httpUtil, httpbackend) {
        this.http = http;
        this.httpUtil = httpUtil;
        this.httpbackend = httpbackend;
    }
    /**
     * Http GET request
     * @param url - The URL to send the GET request to.
     * @param options - The options for the GET request.
     * @returns An Observable that emits the response from the GET request.
     */
    sendGETRequest(url, options) {
        const httpOptions = this.httpUtil.getHttpOptions(options);
        return this.http.get(url, httpOptions);
    }
    /**
     * Http GET can pass custom heeaders
     * @param url - The URL to send the GET request to.
     * @param options - The options for the GET request.
     * @returns An Observable that emits the response from the GET request.
     */
    sendGETRequestBackend(url, options) {
        let httpClient = new HttpClient(this.httpbackend);
        return httpClient.get(url, options);
    }
    /**
     * Http DELETE request
     * @param url - The URL to send the DELETE request to.
     * @param options - The options for the DELETE request.
     * @returns An Observable that emits the response from the DELETE request.
     */
    sendDELETERequest(url, options) {
        const httpOptions = this.httpUtil.getHttpOptions(options);
        return this.http.delete(url, httpOptions);
    }
    /**
     * Http POST request
     * @param url - The URL to send the POST request to.
     * @param json - The payload to send in the POST request.
     * @param options - The options for the POST request.
     * @returns An Observable that emits the response from the POST request.
     */
    sendPOSTRequest(url, json, options) {
        if (!(json instanceof FormData) &&
            (json === '' || json === '{}' || json === '[]')) {
            return throwError(new Error('Json should not be empty'));
        }
        const httpOptions = this.httpUtil.getHttpOptions(options);
        return this.http.post(url, json, httpOptions);
    }
    /**
     * Http POST can pass custom header
     * @param url - The URL to send the POST request to.
     * @param json - The payload to send in the POST request.
     * @param options - The options for the POST request.
     * @returns An Observable that emits the response from the POST request.
     */
    sendPOSTRequestBackend(url, json, options) {
        let httpClient = new HttpClient(this.httpbackend);
        return httpClient.post(url, json, options);
    }
    /**
     * Http PUT request
     * @param url - The URL to send the PUT request to.
     * @param json - The payload to send in the PUT request.
     * @param options - The options for the PUT request.
     * @returns An Observable that emits the response from the PUT request.
     */
    sendPUTRequest(url, json, options) {
        if (!(json instanceof FormData) &&
            (json === '' || json === '{}' || json === '[]')) {
            return throwError(new Error('Json should not be empty'));
        }
        const httpOptions = this.httpUtil.getHttpOptions(options);
        return this.http.put(url, json, httpOptions);
    }
    /**
     * Http PATCH request
     * @param url - The URL to send the PATCH request to.
     * @param json - The payload to send in the PATCH request.
     * @param options - The options for the PATCH request.
     * @returns An Observable that emits the response from the PATCH request.
     */
    sendPATCHRequest(url, json, options) {
        if (!(json instanceof FormData) &&
            (json === '' || json === '{}' || json === '[]')) {
            return throwError(new Error('Json should not be empty'));
        }
        const httpOptions = this.httpUtil.getHttpOptions(options);
        return this.http.patch(url, json, httpOptions);
    }
    /**
     * Http Proxy request
     * @param proxyUrl - The URL to send the proxy request to.
     * @param obj - The payload to send in the proxy request.
     * @returns An Observable that emits the response from the proxy request.
     */
    sendProxyRequest(proxyUrl, obj) {
        // let keyCloakToken= this.coreUtils.getKeycloakToken();
        // let headers= { 'Authorization': `Bearer ${keyCloakToken}`}
        //   if(obj.headers){
        //     headers = Object.assign(headers, obj.headers);
        //   }
        //   let json:any={
        //     "url": obj.url,
        //     "auth":JSON.stringify(headers),
        //     "methodType": obj.methodType,
        //     "Content-Type":'application/json'
        //   }
        //   if(obj.methodType=='POST'){
        //   json['body']=JSON.stringify(obj);
        //  }
        //   return this.sendPOSTRequest(proxyUrl,json);
    }
    /**
     * upload file
     * @param url - The URL to send the upload request to.
     * @param json - The payload to send in the upload request.
     * @param options - The options for the upload request.
     * @returns An Observable that emits the response from the upload request.
     */
    uploadFile(url, json, options) {
        const defaultOptions = {
            observe: Observe.EVENTS,
            headers: new HttpHeaders(),
            // withCredentials: true,
        };
        return this.sendPOSTRequest(url, json, {
            ...defaultOptions,
            ...options,
        }).pipe(filter((event) => event.type === HttpEventType.UploadProgress ||
            event.type === HttpEventType.Response), map(this.httpUtil.getUploadProgress));
    }
    /**
     * upload file and download response
     * @p aram url - The URL to send the upload request to.
     * @param json - The payload to send in the upload request.
     * @param fileName - The name of the file to download.
     * @param options - The options for the upload request.
     * @returns An Observable that emits the response from the upload request.
     */
    uploadFileAndDownloadResponse(url, json, fileName, options) {
        const downloadFile = new Observable((observer) => {
            let contentDisposition = null;
            let contentType = null;
            const defaultOptions = {
                observe: Observe.EVENTS,
                headers: new HttpHeaders(),
                // withCredentials: true,
                responseType: ResponseType.BLOB,
            };
            defaultOptions.headers =
                options && options.headers ? options.headers : new HttpHeaders();
            this.sendPOSTRequest(url, json, {
                ...defaultOptions,
                ...options,
            })
                .pipe(filter((event) => event.type === HttpEventType.ResponseHeader ||
                event.type === HttpEventType.Response ||
                event.type === HttpEventType.DownloadProgress), map(this.httpUtil.getUploadProgress))
                .subscribe((response) => {
                if (response.status && response.status === 'progress') {
                    // Progress event, no action needed
                }
                else if (response.type &&
                    response.type === 'application/octet-stream' //HttpEventType.ResponseHeader
                ) {
                    contentDisposition = 'attachment; filename="IPAddressList.xlsx"'; //response.headers.get('Content-Disposition');
                    contentType = 'application/octet-stream'; //response.headers.get('content-type');
                    try {
                        this.httpUtil.saveDownloadedFile(contentDisposition, response, contentType, fileName);
                        observer.next(response);
                    }
                    catch (ex) {
                        observer.error(response);
                    }
                }
                else {
                    try {
                        if (!contentType ||
                            contentType === 'application/json' ||
                            contentType === 'application/json;charset=UTF-8') {
                            const reader = new FileReader();
                            reader.addEventListener('loadend', (event) => {
                                const text = event.srcElement['result'];
                                if (JSON.parse(text) && JSON.parse(text).errorMsg) {
                                    // Error message found, no action needed
                                }
                                else {
                                    this.httpUtil.saveDownloadedFile(contentDisposition, response, contentType, fileName);
                                }
                            });
                            reader.readAsText(response);
                        }
                        else {
                            this.httpUtil.saveDownloadedFile(contentDisposition, response, contentType, fileName);
                        }
                        observer.next(response);
                    }
                    catch (ex) {
                        observer.error(response);
                    }
                }
            }, (err) => {
                observer.error(err);
            });
        });
        return downloadFile;
    }
    /**
     * downloadFile
     * @param url - The URL to send the download request to.
     * @param fileName - The name of the file to download.
     * @param options - The options for the download request.
     * @param reportDownloadProgress - Whether to report download progress.
     * @param json - The payload to send in the download request.
     * @returns An Observable that emits the response from the download request.
     */
    downloadFile(url, fileName, options, reportDownloadProgress = false, json = '') {
        const downloadFile = new Observable((observer) => {
            let contentDisposition = null;
            let contentType = null;
            const defaultOptions = {
                reportProgress: true,
                observe: Observe.EVENTS,
                headers: new HttpHeaders(),
                responseType: json ? ResponseType.ARRAYBUFFER : ResponseType.BLOB,
                // withCredentials: true,
            };
            defaultOptions.headers =
                options && options.headers ? options.headers : new HttpHeaders();
            let urlResponse = json
                ? this.sendPOSTRequest(url, json, defaultOptions)
                : this.sendGETRequest(url, defaultOptions);
            urlResponse
                .pipe(filter((event) => event.type === HttpEventType.ResponseHeader ||
                event.type === HttpEventType.Response ||
                event.type === HttpEventType.DownloadProgress), map(this.httpUtil.getDownloadProgress))
                .subscribe((response) => {
                if (response?.status && response.status === 'progress') {
                    if (reportDownloadProgress) {
                        observer.next(response);
                    }
                }
                else if (response?.type &&
                    response.type === HttpEventType.ResponseHeader) {
                    contentDisposition = response.headers.get('Content-Disposition');
                    if (!contentDisposition) {
                        console.warn('Unable to access Content-Disposition');
                    }
                    contentType = response.headers.get('content-type');
                    if (options && options.fileNameHeader) {
                        fileName = response.headers.get(options.fileNameHeader);
                    }
                    if (reportDownloadProgress) {
                        observer.next(response);
                    }
                }
                else {
                    try {
                        if (!contentType ||
                            contentType === 'application/json' ||
                            contentType === 'application/json;charset=UTF-8') {
                            const reader = new FileReader();
                            reader.addEventListener('loadend', (event) => {
                                const text = event.srcElement['result'];
                                if (text && JSON.parse(text) && JSON.parse(text).errorMsg) {
                                    // Error message found, no action needed
                                }
                                else {
                                    this.httpUtil.saveDownloadedFile(contentDisposition, response, contentType, fileName);
                                }
                            });
                            reader.readAsText(response);
                        }
                        else {
                            this.httpUtil.saveDownloadedFile(contentDisposition, response, contentType, fileName);
                        }
                        observer.next(response);
                    }
                    catch (ex) {
                        observer.error(response);
                    }
                }
            }, (err) => {
                observer.error(err);
            });
        });
        return downloadFile;
    }
    //Dont use Method "downloadFileByPostRequest" both get/post request support provided in downloadFile method.
    /**
     * download file by post request
     * @param url - The URL to send the download request to.
     * @param json - The payload to send in the download request.
     * @param fileName - The name of the file to download.
     * @param options - The options for the download request.
     * @returns An Observable that emits the response from the download request.
     */
    downloadFileByPostRequest(url, json, fileName, options) {
        const downloadFile = new Observable((observer) => {
            let contentDisposition = null;
            let contentType = null;
            const defaultOptions = {
                reportProgress: true,
                observe: Observe.EVENTS,
                responseType: ResponseType.ARRAYBUFFER,
                headers: new HttpHeaders(),
                // withCredentials: true,
            };
            defaultOptions.headers =
                options && options.headers ? options.headers : new HttpHeaders();
            this.sendPOSTRequest(url, json, defaultOptions)
                .pipe(filter((event) => event.type === HttpEventType.ResponseHeader ||
                event.type === HttpEventType.Response ||
                event.type === HttpEventType.DownloadProgress), map(this.httpUtil.getDownloadProgress))
                .subscribe((response) => {
                if (response?.status && response.status === 'progress') {
                    // Progress event, no action needed
                }
                else if (response.type &&
                    response.type === HttpEventType.ResponseHeader) {
                    contentDisposition = response.headers.get('Content-Disposition');
                    contentType = response.headers.get('content-type');
                }
                else {
                    try {
                        if (!contentType ||
                            contentType === 'application/json' ||
                            contentType === 'application/json;charset=UTF-8') {
                            const reader = new FileReader();
                            reader.addEventListener('loadend', (event) => {
                                const text = event.srcElement['result'];
                                if (JSON.parse(text) && JSON.parse(text).errorMsg) {
                                    // Error message found, no action needed
                                }
                                else {
                                    this.httpUtil.saveDownloadedFile(contentDisposition, response, contentType, fileName);
                                }
                            });
                            reader.readAsText(response);
                        }
                        else {
                            this.httpUtil.saveDownloadedFile(contentDisposition, response, contentType, fileName);
                        }
                        observer.next(response);
                    }
                    catch (ex) {
                        observer.error(response);
                    }
                }
            });
        });
        return downloadFile;
    }
    /**
     * download file by location
     * @param url - The URL to send the download request to.
     */
    downloadFileByLocation(url) {
        const downloadUrl = window.location.protocol + '//' + window.location.hostname + '/' + url;
        window.location.href = downloadUrl;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.12", ngImport: i0, type: HttpService, deps: [{ token: i1.HttpClient }, { token: i2.HttpUtilService }, { token: i1.HttpBackend }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.3.12", ngImport: i0, type: HttpService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.12", ngImport: i0, type: HttpService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: i1.HttpClient }, { type: i2.HttpUtilService }, { type: i1.HttpBackend }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaHR0cC5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvY29tbW9uLWxpYnMvY29yZS9zcmMvbGliL3NlcnZpY2VzL2h0dHAuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFDTCxVQUFVLEVBQ1YsYUFBYSxFQUViLFdBQVcsRUFFWixNQUFNLHNCQUFzQixDQUFDO0FBQzlCLE9BQU8sRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzlDLE9BQU8sRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFHN0MsT0FBTyxFQUFFLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQzs7OztBQUczRDs7R0FFRztBQUtIOztHQUVHO0FBQ0gsTUFBTSxPQUFPLFdBQVc7SUFFdEI7Ozs7OztPQU1HO0lBQ0gsWUFDVSxJQUFnQixFQUNoQixRQUF5QixFQUN6QixXQUF3QjtRQUZ4QixTQUFJLEdBQUosSUFBSSxDQUFZO1FBQ2hCLGFBQVEsR0FBUixRQUFRLENBQWlCO1FBQ3pCLGdCQUFXLEdBQVgsV0FBVyxDQUFhO0lBQ2xDLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILGNBQWMsQ0FBQyxHQUFXLEVBQUUsT0FBc0I7UUFDaEQsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDMUQsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFDekMsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gscUJBQXFCLENBQUMsR0FBVyxFQUFFLE9BQVk7UUFDN0MsSUFBSSxVQUFVLEdBQUcsSUFBSSxVQUFVLENBQUMsSUFBSSxDQUFD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QUFDOzZCQUFNLENBQUM7NEJBQ04sSUFBSSxDQUFDLFFBQVEsQ0FBQyxrQkFBa0IsQ0FDOUIsa0JBQWtCLEVBQ2xCLFFBQVEsRUFDUixXQUFXLEVBQ1gsUUFBUSxDQUNULENBQUM7d0JBQ0osQ0FBQzt3QkFDRCxRQUFRLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO29CQUMxQixDQUFDO29CQUFDLE9BQU8sRUFBRSxFQUFFLENBQUM7d0JBQ1osUUFBUSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQztvQkFDM0IsQ0FBQztnQkFDSCxDQUFDO1lBQ0gsQ0FBQyxDQUFDLENBQUM7UUFDUCxDQUFDLENBQUMsQ0FBQztRQUNILE9BQU8sWUFBWSxDQUFDO0lBQ3RCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxzQkFBc0IsQ0FBQyxHQUFXO1FBQ2hDLE1BQU0sV0FBVyxHQUNmLE1BQU0sQ0FBQyxRQUFRLENBQUMsUUFBUSxHQUFHLElBQUksR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLFFBQVEsR0FBRyxHQUFHLEdBQUcsR0FBRyxDQUFDO1FBQ3pFLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxHQUFHLFdBQVcsQ0FBQztJQUNyQyxDQUFDOytHQXJlVSxXQUFXO21IQUFYLFdBQVcsY0FOVixNQUFNOzs0RkFNUCxXQUFXO2tCQVB2QixVQUFVO21CQUFDO29CQUNWLFVBQVUsRUFBRSxNQUFNO2lCQUNuQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gIEh0dHBDbGllbnQsXG4gIEh0dHBFdmVudFR5cGUsXG4gIEh0dHBFdmVudCxcbiAgSHR0cEhlYWRlcnMsXG4gIEh0dHBCYWNrZW5kXG59IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCB7IE9ic2VydmFibGUsIHRocm93RXJyb3IgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGZpbHRlciwgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgSHR0cFV0aWxTZXJ2aWNlIH0gZnJvbSAnLi9odHRwLXV0aWwuc2VydmljZSc7XG5pbXBvcnQgeyBJSHR0cE9wdGlvbnMgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2h0dHAnO1xuaW1wb3J0IHsgT2JzZXJ2ZSwgUmVzcG9uc2VUeXBlIH0gZnJvbSAnLi4vZW51bXMvaHR0cC5lbnVtJztcbmltcG9ydCB7IFBheWxvYWRUeXBlIH0gZnJvbSAnLi8uLi9pbnRlcmZhY2VzL2h0dHAnO1xuXG4vKipcbiAqIEluamVjdGFibGUgZGVjb3JhdG9yIHRvIHByb3ZpZGUgdGhlIHNlcnZpY2UgYXQgdGhlIHJvb3QgbGV2ZWxcbiAqLyBcbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcblxuLyoqXG4gKiBIdHRwU2VydmljZSBjbGFzc1xuICovIFxuZXhwb3J0IGNsYXNzIEh0dHBTZXJ2aWNlIHtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBIdHRwU2VydmljZS5cbiAgICogQHBhcmFtIGh0dHAgLSBUaGUgSHR0cENsaWVudCBpbnN0YW5jZSBmb3IgbWFraW5nIEhUVFAgcmVxdWVzdHMuXG4gICAqIEBwYXJhbSBodHRwVXRpbCAtIFRoZSBIdHRwVXRpbFNlcnZpY2UgaW5zdGFuY2UgZm9yIGhhbmRsaW5nIEhUVFAgdXRpbGl0aWVzLlxuICAgKiBAcGFyYW0gY29yZVV0aWxzIC0gVGhlIENvcmVVdGlsU2VydmljZSBpbnN0YW5jZSBmb3IgY29yZSB1dGlsaXR5IGZ1bmN0aW9ucy5cbiAgICogQHBhcmFtIGh0dHBiYWNrZW5kIC0gVGhlIEh0dHBCYWNrZW5kIGluc3RhbmNlIGZvciBoYW5kbGluZyBIVFRQIHJlcXVlc3RzLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBodHRwOiBIdHRwQ2xpZW50LCBcbiAgICBwcml2YXRlIGh0dHBVdGlsOiBIdHRwVXRpbFNlcnZpY2UsXG4gICAgcHJpdmF0ZSBodHRwYmFja2VuZDogSHR0cEJhY2tlbmQpIHtcbiAgfVxuXG4gIC8qKlxuICAgKiBIdHRwIEdFVCByZXF1ZXN0XG4gICAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIHRvIHNlbmQgdGhlIEdFVCByZXF1ZXN0IHRvLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciB0aGUgR0VUIHJlcXVlc3QuXG4gICAqIEByZXR1cm5zIEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgcmVzcG9uc2UgZnJvbSB0aGUgR0VUIHJlcXVlc3QuXG4gICAqL1xuICBzZW5kR0VUUmVxdWVzdCh1cmw6IHN0cmluZywgb3B0aW9ucz86IElIdHRwT3B0aW9ucyk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgY29uc3QgaHR0cE9wdGlvbnMgPSB0aGlzLmh0dHBVdGlsLmdldEh0dHBPcHRpb25zKG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLmh0dHAuZ2V0KHVybCwgaHR0cE9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEh0dHAgR0VUIGNhbiBwYXNzIGN1c3RvbSBoZWVhZGVyc1xuICAgKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCB0byBzZW5kIHRoZSBHRVQgcmVxdWVzdCB0by4gXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBHRVQgcmVxdWVzdC5cbiAgICogQHJldHVybnMgQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSByZXNwb25zZSBmcm9tIHRoZSBHRVQgcmVxdWVzdC5cbiAgICovXG4gIHNlbmRHRVRSZXF1ZXN0QmFja2VuZCh1cmw6IHN0cmluZywgb3B0aW9uczogYW55KTogT2JzZXJ2YWJsZTxhbnk+IHsvLytcbiAgICBsZXQgaHR0cENsaWVudCA9IG5ldyBIdHRwQ2xpZW50KHRoaXMuaHR0cGJhY2tlbmQpO1xuICAgIHJldHVybiBodHRwQ2xpZW50LmdldCh1cmwsb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogSHR0cCBERUxFVEUgcmVxdWVzdFxuICAgKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCB0byBzZW5kIHRoZSBERUxFVEUgcmVxdWVzdCB0by5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIERFTEVURSByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHJlc3BvbnNlIGZyb20gdGhlIERFTEVURSByZXF1ZXN0LlxuICAgKi9cbiAgc2VuZERFTEVURVJlcXVlc3QodXJsOiBzdHJpbmcsIG9wdGlvbnM/OiBJSHR0cE9wdGlvbnMpOiBPYnNlcnZhYmxlPGFueT4ge1xuICAgIGNvbnN0IGh0dHBPcHRpb25zID0gdGhpcy5odHRwVXRpbC5nZXRIdHRwT3B0aW9ucyhvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy5odHRwLmRlbGV0ZSh1cmwsIGh0dHBPcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIdHRwIFBPU1QgcmVxdWVzdCAgXG4gICAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIHRvIHNlbmQgdGhlIFBPU1QgcmVxdWVzdCB0by5cbiAgICogQHBhcmFtIGpzb24gLSBUaGUgcGF5bG9hZCB0byBzZW5kIGluIHRoZSBQT1NUIHJlcXVlc3QuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBQT1NUIHJlcXVlc3QuXG4gICAqIEByZXR1cm5zIEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgcmVzcG9uc2UgZnJvbSB0aGUgUE9TVCByZXF1ZXN0LlxuICAgKi9cbiAgc2VuZFBPU1RSZXF1ZXN0KFxuICAgIHVybDogc3RyaW5nLFxuICAgIGpzb246IFBheWxvYWRUeXBlLFxuICAgIG9wdGlvbnM/OiBJSHR0cE9wdGlvbnNcbiAgKTogT2JzZXJ2YWJsZTxhbnk+IHtcbiAgICBpZiAoXG4gICAgICAhKGpzb24gaW5zdGFuY2VvZiBGb3JtRGF0YSkgJiZcbiAgICAgIChqc29uID09PSAnJyB8fCBqc29uID09PSAne30nIHx8IGpzb24gPT09ICdbXScpXG4gICAgKSB7XG4gICAgICByZXR1cm4gdGhyb3dFcnJvcihuZXcgRXJyb3IoJ0pzb24gc2hvdWxkIG5vdCBiZSBlbXB0eScpKTtcbiAgICB9XG4gICAgY29uc3QgaHR0cE9wdGlvbnMgPSB0aGlzLmh0dHBVdGlsLmdldEh0dHBPcHRpb25zKG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLmh0dHAucG9zdCh1cmwsIGpzb24sIGh0dHBPcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIdHRwIFBPU1QgY2FuIHBhc3MgY3VzdG9tIGhlYWRlclxuICAgKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCB0byBzZW5kIHRoZSBQT1NUIHJlcXVlc3QgdG8uXG4gICAqIEBwYXJhbSBqc29uIC0gVGhlIHBheWxvYWQgdG8gc2VuZCBpbiB0aGUgUE9TVCByZXF1ZXN0LlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciB0aGUgUE9TVCByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHJlc3BvbnNlIGZyb20gdGhlIFBPU1QgcmVxdWVzdC5cbiAgICovXG4gIHNlbmRQT1NUUmVxdWVzdEJhY2tlbmQoXG4gICAgdXJsOiBzdHJpbmcsXG4gICAganNvbjogUGF5bG9hZFR5cGUsXG4gICAgb3B0aW9uczogYW55XG4gICk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgbGV0IGh0dHBDbGllbnQgPSBuZXcgSHR0cENsaWVudCh0aGlzLmh0dHBiYWNrZW5kKTtcbiAgICByZXR1cm4gaHR0cENsaWVudC5wb3N0KHVybCwganNvbiwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogSHR0cCBQVVQgcmVxdWVzdCBcbiAgICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdG8gc2VuZCB0aGUgUFVUIHJlcXVlc3QgdG8uXG4gICAqIEBwYXJhbSBqc29uIC0gVGhlIHBheWxvYWQgdG8gc2VuZCBpbiB0aGUgUFVUIHJlcXVlc3QuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBQVVQgcmVxdWVzdC5cbiAgICogQHJldHVybnMgQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSByZXNwb25zZSBmcm9tIHRoZSBQVVQgcmVxdWVzdC5cbiAgICovXG4gIHNlbmRQVVRSZXF1ZXN0KFxuICAgIHVybDogc3RyaW5nLFxuICAgIGpzb246IFBheWxvYWRUeXBlLFxuICAgIG9wdGlvbnM/OiBJSHR0cE9wdGlvbnNcbiAgKTogT2JzZXJ2YWJsZTxhbnk+IHtcbiAgICBpZiAoXG4gICAgICAhKGpzb24gaW5zdGFuY2VvZiBGb3JtRGF0YSkgJiZcbiAgICAgIChqc29uID09PSAnJyB8fCBqc29uID09PSAne30nIHx8IGpzb24gPT09ICdbXScpXG4gICAgKSB7XG4gICAgICByZXR1cm4gdGhyb3dFcnJvcihuZXcgRXJyb3IoJ0pzb24gc2hvdWxkIG5vdCBiZSBlbXB0eScpKTtcbiAgICB9XG4gICAgY29uc3QgaHR0cE9wdGlvbnMgPSB0aGlzLmh0dHBVdGlsLmdldEh0dHBPcHRpb25zKG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLmh0dHAucHV0KHVybCwganNvbiwgaHR0cE9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEh0dHAgUEFUQ0ggcmVxdWVzdFxuICAgKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCB0byBzZW5kIHRoZSBQQVRDSCByZXF1ZXN0IHRvLlxuICAgKiBAcGFyYW0ganNvbiAtIFRoZSBwYXlsb2FkIHRvIHNlbmQgaW4gdGhlIFBBVENIIHJlcXVlc3QuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBQQVRDSCByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHJlc3BvbnNlIGZyb20gdGhlIFBBVENIIHJlcXVlc3QuXG4gICAqL1xuICBzZW5kUEFUQ0hSZXF1ZXN0KFxuICAgIHVybDogc3RyaW5nLFxuICAgIGpzb246IFBheWxvYWRUeXBlLFxuICAgIG9wdGlvbnM/OiBJSHR0cE9wdGlvbnNcbiAgKTogT2JzZXJ2YWJsZTxhbnk+IHtcbiAgICBpZiAoXG4gICAgICAhKGpzb24gaW5zdGFuY2VvZiBGb3JtRGF0YSkgJiZcbiAgICAgIChqc29uID09PSAnJyB8fCBqc29uID09PSAne30nIHx8IGpzb24gPT09ICdbXScpXG4gICAgKSB7XG4gICAgICByZXR1cm4gdGhyb3dFcnJvcihuZXcgRXJyb3IoJ0pzb24gc2hvdWxkIG5vdCBiZSBlbXB0eScpKTtcbiAgICB9XG4gICAgY29uc3QgaHR0cE9wdGlvbnMgPSB0aGlzLmh0dHBVdGlsLmdldEh0dHBPcHRpb25zKG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLmh0dHAucGF0Y2godXJsLCBqc29uLCBodHRwT3B0aW9ucyk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBIdHRwIFByb3h5IHJlcXVlc3RcbiAgICogQHBhcmFtIHByb3h5VXJsIC0gVGhlIFVSTCB0byBzZW5kIHRoZSBwcm94eSByZXF1ZXN0IHRvLlxuICAgKiBAcGFyYW0gb2JqIC0gVGhlIHBheWxvYWQgdG8gc2VuZCBpbiB0aGUgcHJveHkgcmVxdWVzdC5cbiAgICogQHJldHVybnMgQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSByZXNwb25zZSBmcm9tIHRoZSBwcm94eSByZXF1ZXN0LlxuICAgKi9cbiAgICBzZW5kUHJveHlSZXF1ZXN0KHByb3h5VXJsOiBzdHJpbmcsIG9iajogYW55KXtcbiAgICAvLyBsZXQga2V5Q2xvYWtUb2tlbj0gdGhpcy5jb3JlVXRpbHMuZ2V0S2V5Y2xvYWtUb2tlbigpO1xuICAgIC8vIGxldCBoZWFkZXJzPSB7ICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke2tleUNsb2FrVG9rZW59YH1cbiAgLy8gICBpZihvYmouaGVhZGVycyl7XG4gIC8vICAgICBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbihoZWFkZXJzLCBvYmouaGVhZGVycyk7XG4gIC8vICAgfVxuICAvLyAgIGxldCBqc29uOmFueT17XG4gIC8vICAgICBcInVybFwiOiBvYmoudXJsLFxuICAvLyAgICAgXCJhdXRoXCI6SlNPTi5zdHJpbmdpZnkoaGVhZGVycyksXG4gIC8vICAgICBcIm1ldGhvZFR5cGVcIjogb2JqLm1ldGhvZFR5cGUsXG4gIC8vICAgICBcIkNvbnRlbnQtVHlwZVwiOidhcHBsaWNhdGlvbi9qc29uJ1xuICAvLyAgIH1cbiAgLy8gICBpZihvYmoubWV0aG9kVHlwZT09J1BPU1QnKXtcbiAgLy8gICBqc29uWydib2R5J109SlNPTi5zdHJpbmdpZnkob2JqKTtcbiAgLy8gIH1cbiAgLy8gICByZXR1cm4gdGhpcy5zZW5kUE9TVFJlcXVlc3QocHJveHlVcmwsanNvbik7XG4gIH1cblxuICAvKipcbiAgICogdXBsb2FkIGZpbGVcbiAgICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdG8gc2VuZCB0aGUgdXBsb2FkIHJlcXVlc3QgdG8uICBcbiAgICogQHBhcmFtIGpzb24gLSBUaGUgcGF5bG9hZCB0byBzZW5kIGluIHRoZSB1cGxvYWQgcmVxdWVzdC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIHVwbG9hZCByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHJlc3BvbnNlIGZyb20gdGhlIHVwbG9hZCByZXF1ZXN0LlxuICAgKi9cbiAgdXBsb2FkRmlsZShcbiAgICB1cmw6IHN0cmluZyxcbiAgICBqc29uOiBQYXlsb2FkVHlwZSxcbiAgICBvcHRpb25zPzogSUh0dHBPcHRpb25zXG4gICk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgY29uc3QgZGVmYXVsdE9wdGlvbnM6IElIdHRwT3B0aW9ucyA9IHtcbiAgICAgIG9ic2VydmU6IE9ic2VydmUuRVZFTlRTLFxuICAgICAgaGVhZGVyczogbmV3IEh0dHBIZWFkZXJzKCksXG4gICAgICAvLyB3aXRoQ3JlZGVudGlhbHM6IHRydWUsXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5zZW5kUE9TVFJlcXVlc3QodXJsLCBqc29uLCB7XG4gICAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSkucGlwZShcbiAgICAgIGZpbHRlcihcbiAgICAgICAgKGV2ZW50OiBIdHRwRXZlbnQ8YW55PikgPT5cbiAgICAgICAgICBldmVudC50eXBlID09PSBIdHRwRXZlbnRUeXBlLlVwbG9hZFByb2dyZXNzIHx8XG4gICAgICAgICAgZXZlbnQudHlwZSA9PT0gSHR0cEV2ZW50VHlwZS5SZXNwb25zZVxuICAgICAgKSxcbiAgICAgIG1hcCh0aGlzLmh0dHBVdGlsLmdldFVwbG9hZFByb2dyZXNzKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogdXBsb2FkIGZpbGUgYW5kIGRvd25sb2FkIHJlc3BvbnNlXG4gICAqIEBwIGFyYW0gdXJsIC0gVGhlIFVSTCB0byBzZW5kIHRoZSB1cGxvYWQgcmVxdWVzdCB0by5cbiAgICogQHBhcmFtIGpzb24gLSBUaGUgcGF5bG9hZCB0byBzZW5kIGluIHRoZSB1cGxvYWQgcmVxdWVzdC5cbiAgICogQHBhcmFtIGZpbGVOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGZpbGUgdG8gZG93bmxvYWQuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSB1cGxvYWQgcmVxdWVzdC5cbiAgICogQHJldHVybnMgQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSByZXNwb25zZSBmcm9tIHRoZSB1cGxvYWQgcmVxdWVzdC5cbiAgICovXG4gIHVwbG9hZEZpbGVBbmREb3dubG9hZFJlc3BvbnNlKFxuICAgIHVybDogc3RyaW5nLFxuICAgIGpzb246IFBheWxvYWRUeXBlLFxuICAgIGZpbGVOYW1lPzogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBJSHR0cE9wdGlvbnNcbiAgKTogT2JzZXJ2YWJsZTxhbnk+IHtcbiAgICBjb25zdCBkb3dubG9hZEZpbGUgPSBuZXcgT2JzZXJ2YWJsZSgob2JzZXJ2ZXIpID0+IHtcbiAgICAgIGxldCBjb250ZW50RGlzcG9zaXRpb246IGFueSA9IG51bGw7XG4gICAgICBsZXQgY29udGVudFR5cGU6IGFueSA9IG51bGw7XG4gICAgICBjb25zdCBkZWZhdWx0T3B0aW9uczogSUh0dHBPcHRpb25zID0ge1xuICAgICAgICBvYnNlcnZlOiBPYnNlcnZlLkVWRU5UUyxcbiAgICAgICAgaGVhZGVyczogbmV3IEh0dHBIZWFkZXJzKCksXG4gICAgICAgIC8vIHdpdGhDcmVkZW50aWFsczogdHJ1ZSxcbiAgICAgICAgcmVzcG9uc2VUeXBlOiBSZXNwb25zZVR5cGUuQkxPQixcbiAgICAgIH07XG4gICAgICBkZWZhdWx0T3B0aW9ucy5oZWFkZXJzID1cbiAgICAgICAgb3B0aW9ucyAmJiBvcHRpb25zLmhlYWRlcnMgPyBvcHRpb25zLmhlYWRlcnMgOiBuZXcgSHR0cEhlYWRlcnMoKTtcbiAgICAgIHRoaXMuc2VuZFBPU1RSZXF1ZXN0KHVybCwganNvbiwge1xuICAgICAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIH0pXG4gICAgICAgIC5waXBlKFxuICAgICAgICAgIGZpbHRlcihcbiAgICAgICAgICAgIChldmVudDogSHR0cEV2ZW50PGFueT4pID0+XG4gICAgICAgICAgICAgIGV2ZW50LnR5cGUgPT09IEh0dHBFdmVudFR5cGUuUmVzcG9uc2VIZWFkZXIgfHxcbiAgICAgICAgICAgICAgZXZlbnQudHlwZSA9PT0gSHR0cEV2ZW50VHlwZS5SZXNwb25zZSB8fFxuICAgICAgICAgICAgICBldmVudC50eXBlID09PSBIdHRwRXZlbnRUeXBlLkRvd25sb2FkUHJvZ3Jlc3NcbiAgICAgICAgICApLFxuICAgICAgICAgIG1hcCh0aGlzLmh0dHBVdGlsLmdldFVwbG9hZFByb2dyZXNzKVxuICAgICAgICApXG4gICAgICAgIC5zdWJzY3JpYmUoKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAmJiByZXNwb25zZS5zdGF0dXMgPT09ICdwcm9ncmVzcycpIHtcbiAgICAgICAgICAgIC8vIFByb2dyZXNzIGV2ZW50LCBubyBhY3Rpb24gbmVlZGVkXG4gICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIHJlc3BvbnNlLnR5cGUgJiZcbiAgICAgICAgICAgIHJlc3BvbnNlLnR5cGUgPT09ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nIC8vSHR0cEV2ZW50VHlwZS5SZXNwb25zZUhlYWRlclxuICAgICAgICAgICkge1xuICAgICAgICAgICAgY29udGVudERpc3Bvc2l0aW9uID0gJ2F0dGFjaG1lbnQ7IGZpbGVuYW1lPVwiSVBBZGRyZXNzTGlzdC54bHN4XCInOyAvL3Jlc3BvbnNlLmhlYWRlcnMuZ2V0KCdDb250ZW50LURpc3Bvc2l0aW9uJyk7XG4gICAgICAgICAgICBjb250ZW50VHlwZSA9ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nOyAvL3Jlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHRoaXMuaHR0cFV0aWwuc2F2ZURvd25sb2FkZWRGaWxlKFxuICAgICAgICAgICAgICAgIGNvbnRlbnREaXNwb3NpdGlvbixcbiAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZSxcbiAgICAgICAgICAgICAgICBmaWxlTmFtZVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICFjb250ZW50VHlwZSB8fFxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24vanNvbicgfHxcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL2pzb247Y2hhcnNldD1VVEYtOCdcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICAgICAgICByZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVuZCcsIChldmVudDogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gZXZlbnQuc3JjRWxlbWVudFsncmVzdWx0J107XG4gICAgICAgICAgICAgICAgICBpZiAoSlNPTi5wYXJzZSh0ZXh0KSAmJiBKU09OLnBhcnNlKHRleHQpLmVycm9yTXNnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVycm9yIG1lc3NhZ2UgZm91bmQsIG5vIGFjdGlvbiBuZWVkZWRcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaHR0cFV0aWwuc2F2ZURvd25sb2FkZWRGaWxlKFxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnREaXNwb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmh0dHBVdGlsLnNhdmVEb3dubG9hZGVkRmlsZShcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnREaXNwb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgY29udGVudFR5cGUsXG4gICAgICAgICAgICAgICAgICBmaWxlTmFtZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChyZXNwb25zZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcihyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAoZXJyKSA9PiB7XG4gICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRvd25sb2FkRmlsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBkb3dubG9hZEZpbGVcbiAgICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdG8gc2VuZCB0aGUgZG93bmxvYWQgcmVxdWVzdCB0by4gIFxuICAgKiBAcGFyYW0gZmlsZU5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZmlsZSB0byBkb3dubG9hZC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIGRvd25sb2FkIHJlcXVlc3QuXG4gICAqIEBwYXJhbSByZXBvcnREb3dubG9hZFByb2dyZXNzIC0gV2hldGhlciB0byByZXBvcnQgZG93bmxvYWQgcHJvZ3Jlc3MuXG4gICAqIEBwYXJhbSBqc29uIC0gVGhlIHBheWxvYWQgdG8gc2VuZCBpbiB0aGUgZG93bmxvYWQgcmVxdWVzdC5cbiAgICogQHJldHVybnMgQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSByZXNwb25zZSBmcm9tIHRoZSBkb3dubG9hZCByZXF1ZXN0LlxuICAgKi9cbiAgZG93bmxvYWRGaWxlKFxuICAgIHVybDogc3RyaW5nLFxuICAgIGZpbGVOYW1lPzogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBJSHR0cE9wdGlvbnMsXG4gICAgcmVwb3J0RG93bmxvYWRQcm9ncmVzcyA9IGZhbHNlLFxuICAgIGpzb246IFBheWxvYWRUeXBlID0gJydcbiAgKTogT2JzZXJ2YWJsZTxhbnk+IHtcbiAgICBjb25zdCBkb3dubG9hZEZpbGUgPSBuZXcgT2JzZXJ2YWJsZSgob2JzZXJ2ZXIpID0+IHtcbiAgICAgIGxldCBjb250ZW50RGlzcG9zaXRpb246IGFueSA9IG51bGw7XG4gICAgICBsZXQgY29udGVudFR5cGU6IGFueSA9IG51bGw7XG4gICAgICBjb25zdCBkZWZhdWx0T3B0aW9uczogSUh0dHBPcHRpb25zID0ge1xuICAgICAgICByZXBvcnRQcm9ncmVzczogdHJ1ZSxcbiAgICAgICAgb2JzZXJ2ZTogT2JzZXJ2ZS5FVkVOVFMsXG4gICAgICAgIGhlYWRlcnM6IG5ldyBIdHRwSGVhZGVycygpLFxuICAgICAgICByZXNwb25zZVR5cGU6IGpzb24gPyBSZXNwb25zZVR5cGUuQVJSQVlCVUZGRVIgOiBSZXNwb25zZVR5cGUuQkxPQixcbiAgICAgICAgLy8gd2l0aENyZWRlbnRpYWxzOiB0cnVlLFxuICAgICAgfTtcbiAgICAgIGRlZmF1bHRPcHRpb25zLmhlYWRlcnMgPVxuICAgICAgICBvcHRpb25zICYmIG9wdGlvbnMuaGVhZGVycyA/IG9wdGlvbnMuaGVhZGVycyA6IG5ldyBIdHRwSGVhZGVycygpO1xuICAgICAgbGV0IHVybFJlc3BvbnNlID0ganNvblxuICAgICAgICA/IHRoaXMuc2VuZFBPU1RSZXF1ZXN0KHVybCwganNvbiwgZGVmYXVsdE9wdGlvbnMpXG4gICAgICAgIDogdGhpcy5zZW5kR0VUUmVxdWVzdCh1cmwsIGRlZmF1bHRPcHRpb25zKTtcbiAgICAgIHVybFJlc3BvbnNlXG4gICAgICAgIC5waXBlKFxuICAgICAgICAgIGZpbHRlcihcbiAgICAgICAgICAgIChldmVudDogSHR0cEV2ZW50PGFueT4pID0+XG4gICAgICAgICAgICAgIGV2ZW50LnR5cGUgPT09IEh0dHBFdmVudFR5cGUuUmVzcG9uc2VIZWFkZXIgfHxcbiAgICAgICAgICAgICAgZXZlbnQudHlwZSA9PT0gSHR0cEV2ZW50VHlwZS5SZXNwb25zZSB8fFxuICAgICAgICAgICAgICBldmVudC50eXBlID09PSBIdHRwRXZlbnRUeXBlLkRvd25sb2FkUHJvZ3Jlc3NcbiAgICAgICAgICApLFxuICAgICAgICAgIG1hcCh0aGlzLmh0dHBVdGlsLmdldERvd25sb2FkUHJvZ3Jlc3MpXG4gICAgICAgIClcbiAgICAgICAgLnN1YnNjcmliZShcbiAgICAgICAgICAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZT8uc3RhdHVzICYmIHJlc3BvbnNlLnN0YXR1cyA9PT0gJ3Byb2dyZXNzJykge1xuICAgICAgICAgICAgICBpZiAocmVwb3J0RG93bmxvYWRQcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQocmVzcG9uc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICByZXNwb25zZT8udHlwZSAmJlxuICAgICAgICAgICAgICByZXNwb25zZS50eXBlID09PSBIdHRwRXZlbnRUeXBlLlJlc3BvbnNlSGVhZGVyXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgY29udGVudERpc3Bvc2l0aW9uID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ0NvbnRlbnQtRGlzcG9zaXRpb24nKTtcbiAgICAgICAgICAgICAgaWYoIWNvbnRlbnREaXNwb3NpdGlvbil7Y29uc29sZS53YXJuKCdVbmFibGUgdG8gYWNjZXNzIENvbnRlbnQtRGlzcG9zaXRpb24nKX1cbiAgICAgICAgICAgICAgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJyk7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZmlsZU5hbWVIZWFkZXIpIHtcbiAgICAgICAgICAgICAgICBmaWxlTmFtZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KG9wdGlvbnMuZmlsZU5hbWVIZWFkZXIpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHJlcG9ydERvd25sb2FkUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAhY29udGVudFR5cGUgfHxcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24vanNvbicgfHxcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PVVURi04J1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICAgICAgICAgIHJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdsb2FkZW5kJywgKGV2ZW50OiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IGV2ZW50LnNyY0VsZW1lbnRbJ3Jlc3VsdCddO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGV4dCAmJiBKU09OLnBhcnNlKHRleHQpICYmIEpTT04ucGFyc2UodGV4dCkuZXJyb3JNc2cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBFcnJvciBtZXNzYWdlIGZvdW5kLCBubyBhY3Rpb24gbmVlZGVkXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5odHRwVXRpbC5zYXZlRG93bmxvYWRlZEZpbGUoXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RGlzcG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWVcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy5odHRwVXRpbC5zYXZlRG93bmxvYWRlZEZpbGUoXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnREaXNwb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlLFxuICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChyZXNwb25zZSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IocmVzcG9uc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICAoZXJyKSA9PiB7XG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZG93bmxvYWRGaWxlO1xuICB9XG5cbiAgLy9Eb250IHVzZSBNZXRob2QgXCJkb3dubG9hZEZpbGVCeVBvc3RSZXF1ZXN0XCIgYm90aCBnZXQvcG9zdCByZXF1ZXN0IHN1cHBvcnQgcHJvdmlkZWQgaW4gZG93bmxvYWRGaWxlIG1ldGhvZC5cbiAgLyoqXG4gICAqIGRvd25sb2FkIGZpbGUgYnkgcG9zdCByZXF1ZXN0XG4gICAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIHRvIHNlbmQgdGhlIGRvd25sb2FkIHJlcXVlc3QgdG8uXG4gICAqIEBwYXJhbSBqc29uIC0gVGhlIHBheWxvYWQgdG8gc2VuZCBpbiB0aGUgZG93bmxvYWQgcmVxdWVzdC5cbiAgICogQHBhcmFtIGZpbGVOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGZpbGUgdG8gZG93bmxvYWQuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBkb3dubG9hZCByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHJlc3BvbnNlIGZyb20gdGhlIGRvd25sb2FkIHJlcXVlc3QuXG4gICAqL1xuICBkb3dubG9hZEZpbGVCeVBvc3RSZXF1ZXN0KFxuICAgIHVybDogc3RyaW5nLFxuICAgIGpzb246IFBheWxvYWRUeXBlLFxuICAgIGZpbGVOYW1lPzogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBJSHR0cE9wdGlvbnNcbiAgKSB7XG4gICAgY29uc3QgZG93bmxvYWRGaWxlID0gbmV3IE9ic2VydmFibGUoKG9ic2VydmVyKSA9PiB7XG4gICAgICBsZXQgY29udGVudERpc3Bvc2l0aW9uOiBhbnkgPSBudWxsO1xuICAgICAgbGV0IGNvbnRlbnRUeXBlOiBhbnkgPSBudWxsO1xuICAgICAgY29uc3QgZGVmYXVsdE9wdGlvbnM6IElIdHRwT3B0aW9ucyA9IHtcbiAgICAgICAgcmVwb3J0UHJvZ3Jlc3M6IHRydWUsXG4gICAgICAgIG9ic2VydmU6IE9ic2VydmUuRVZFTlRTLFxuICAgICAgICByZXNwb25zZVR5cGU6IFJlc3BvbnNlVHlwZS5BUlJBWUJVRkZFUixcbiAgICAgICAgaGVhZGVyczogbmV3IEh0dHBIZWFkZXJzKCksXG4gICAgICAgIC8vIHdpdGhDcmVkZW50aWFsczogdHJ1ZSxcbiAgICAgIH07XG4gICAgICBkZWZhdWx0T3B0aW9ucy5oZWFkZXJzID1cbiAgICAgICAgb3B0aW9ucyAmJiBvcHRpb25zLmhlYWRlcnMgPyBvcHRpb25zLmhlYWRlcnMgOiBuZXcgSHR0cEhlYWRlcnMoKTtcbiAgICAgIHRoaXMuc2VuZFBPU1RSZXF1ZXN0KHVybCwganNvbiwgZGVmYXVsdE9wdGlvbnMpXG4gICAgICAgIC5waXBlKFxuICAgICAgICAgIGZpbHRlcihcbiAgICAgICAgICAgIChldmVudDogSHR0cEV2ZW50PGFueT4pID0+XG4gICAgICAgICAgICAgIGV2ZW50LnR5cGUgPT09IEh0dHBFdmVudFR5cGUuUmVzcG9uc2VIZWFkZXIgfHxcbiAgICAgICAgICAgICAgZXZlbnQudHlwZSA9PT0gSHR0cEV2ZW50VHlwZS5SZXNwb25zZSB8fFxuICAgICAgICAgICAgICBldmVudC50eXBlID09PSBIdHRwRXZlbnRUeXBlLkRvd25sb2FkUHJvZ3Jlc3NcbiAgICAgICAgICApLFxuICAgICAgICAgIG1hcCh0aGlzLmh0dHBVdGlsLmdldERvd25sb2FkUHJvZ3Jlc3MpXG4gICAgICAgIClcbiAgICAgICAgLnN1YnNjcmliZSgocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICBpZiAocmVzcG9uc2U/LnN0YXR1cyAmJiByZXNwb25zZS5zdGF0dXMgPT09ICdwcm9ncmVzcycpIHtcbiAgICAgICAgICAgIC8vIFByb2dyZXNzIGV2ZW50LCBubyBhY3Rpb24gbmVlZGVkXG4gICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIHJlc3BvbnNlLnR5cGUgJiZcbiAgICAgICAgICAgIHJlc3BvbnNlLnR5cGUgPT09IEh0dHBFdmVudFR5cGUuUmVzcG9uc2VIZWFkZXJcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnRlbnREaXNwb3NpdGlvbiA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdDb250ZW50LURpc3Bvc2l0aW9uJyk7XG4gICAgICAgICAgICBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICFjb250ZW50VHlwZSB8fFxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24vanNvbicgfHxcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL2pzb247Y2hhcnNldD1VVEYtOCdcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICAgICAgICByZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVuZCcsIChldmVudDogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gZXZlbnQuc3JjRWxlbWVudFsncmVzdWx0J107XG4gICAgICAgICAgICAgICAgICBpZiAoSlNPTi5wYXJzZSh0ZXh0KSAmJiBKU09OLnBhcnNlKHRleHQpLmVycm9yTXNnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVycm9yIG1lc3NhZ2UgZm91bmQsIG5vIGFjdGlvbiBuZWVkZWRcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaHR0cFV0aWwuc2F2ZURvd25sb2FkZWRGaWxlKFxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnREaXNwb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmh0dHBVdGlsLnNhdmVEb3dubG9hZGVkRmlsZShcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnREaXNwb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgY29udGVudFR5cGUsXG4gICAgICAgICAgICAgICAgICBmaWxlTmFtZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChyZXNwb25zZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcihyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gZG93bmxvYWRGaWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIGRvd25sb2FkIGZpbGUgYnkgbG9jYXRpb25cbiAgICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdG8gc2VuZCB0aGUgZG93bmxvYWQgcmVxdWVzdCB0by4gIFxuICAgKi9cbiAgZG93bmxvYWRGaWxlQnlMb2NhdGlvbih1cmw6IHN0cmluZykge1xuICAgIGNvbnN0IGRvd25sb2FkVXJsID1cbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgKyAnLycgKyB1cmw7XG4gICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBkb3dubG9hZFVybDtcbiAgfVxufVxuIl19