import { Injectable } from '@angular/core';
import * as i0 from "@angular/core";
import * as i1 from "../services/auth.service";
import * as i2 from "@angular/router";
export class AuthGuard {
    constructor(authService, router) {
        this.authService = authService;
        this.router = router;
    }
    canActivate() {
        // Check storage directly to avoid timing issues with state initialization
        const token = this.authService.getStoredToken();
        const user = this.authService.getStoredUser();
        const refreshToken = this.authService.getStoredRefreshToken();
        // Must have both token and user data to be considered authenticated
        if (!token || !user) {
            this.router.navigate(['/login']);
            return false;
        }
        // Check if token is valid
        const isTokenValid = this.authService.isTokenValid(token);
        if (isTokenValid) {
            return true;
        }
        // Token is expired - check if we have a refresh token
        if (refreshToken) {
            // Allow access - token refresh will happen in background via initializeAuthState
            return true;
        }
        // Token is expired and no refresh token
        // Don't redirect immediately - let initializeAuthState handle it
        // This prevents race conditions where guard runs before state is initialized
        // If state initialization clears data, the next navigation will redirect
        console.warn('Token expired and no refresh token found. Access may be denied after state initialization.');
        // Check auth state as fallback (in case initializeAuthState already ran)
        const isAuthenticated = this.authService.isAuthenticated();
        if (!isAuthenticated) {
            this.router.navigate(['/login']);
            return false;
        }
        // If authenticated in state but token expired and no refresh token, allow for now
        // The HTTP interceptor will handle 401 errors
        return true;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.12", ngImport: i0, type: AuthGuard, deps: [{ token: i1.AuthService }, { token: i2.Router }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.3.12", ngImport: i0, type: AuthGuard, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.12", ngImport: i0, type: AuthGuard, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: () => [{ type: i1.AuthService }, { type: i2.Router }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0aC5ndWFyZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2NvbW1vbi1saWJzL2NvcmUvc3JjL2xpYi9ndWFyZHMvYXV0aC5ndWFyZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDOzs7O0FBTzNDLE1BQU0sT0FBTyxTQUFTO0lBQ3BCLFlBQW9CLFdBQXdCLEVBQVUsTUFBYztRQUFoRCxnQkFBVyxHQUFYLFdBQVcsQ0FBYTtRQUFVLFdBQU0sR0FBTixNQUFNLENBQVE7SUFBRyxDQUFDO0lBRXhFLFdBQVc7UUFDVCwwRUFBMEU7UUFDMUUsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxjQUFjLEVBQUUsQ0FBQztRQUNoRCxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLGFBQWEsRUFBRSxDQUFDO1FBQzlDLE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMscUJBQXFCLEVBQUUsQ0FBQztRQUU5RCxvRUFBb0U7UUFDcEUsSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1lBQ3BCLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNqQyxPQUFPLEtBQUssQ0FBQztRQUNmLENBQUM7UUFFRCwwQkFBMEI7UUFDMUIsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFMUQsSUFBSSxZQUFZLEVBQUUsQ0FBQztZQUNqQixPQUFPLElBQUksQ0FBQztRQUNkLENBQUM7UUFFRCxzREFBc0Q7UUFDdEQsSUFBSSxZQUFZLEVBQUUsQ0FBQztZQUNqQixpRkFBaUY7WUFDakYsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO1FBRUQsd0NBQXdDO1FBQ3hDLGlFQUFpRTtRQUNqRSw2RUFBNkU7UUFDN0UseUVBQXlFO1FBQ3pFLE9BQU8sQ0FBQyxJQUFJLENBQUMsNEZBQTRGLENBQUMsQ0FBQztRQUUzRyx5RUFBeUU7UUFDekUsTUFBTSxlQUFlLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUMzRCxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7WUFDckIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ2pDLE9BQU8sS0FBSyxDQUFDO1FBQ2YsQ0FBQztRQUVELGtGQUFrRjtRQUNsRiw4Q0FBOEM7UUFDOUMsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDOytHQTVDVSxTQUFTO21IQUFULFNBQVMsY0FGUixNQUFNOzs0RkFFUCxTQUFTO2tCQUhyQixVQUFVO21CQUFDO29CQUNWLFVBQVUsRUFBRSxNQUFNO2lCQUNuQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENhbkFjdGl2YXRlLCBSb3V0ZXIgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgQXV0aFNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9hdXRoLnNlcnZpY2UnO1xuXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290J1xufSlcbmV4cG9ydCBjbGFzcyBBdXRoR3VhcmQgaW1wbGVtZW50cyBDYW5BY3RpdmF0ZSB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgYXV0aFNlcnZpY2U6IEF1dGhTZXJ2aWNlLCBwcml2YXRlIHJvdXRlcjogUm91dGVyKSB7fVxuXG4gIGNhbkFjdGl2YXRlKCk6IGJvb2xlYW4ge1xuICAgIC8vIENoZWNrIHN0b3JhZ2UgZGlyZWN0bHkgdG8gYXZvaWQgdGltaW5nIGlzc3VlcyB3aXRoIHN0YXRlIGluaXRpYWxpemF0aW9uXG4gICAgY29uc3QgdG9rZW4gPSB0aGlzLmF1dGhTZXJ2aWNlLmdldFN0b3JlZFRva2VuKCk7XG4gICAgY29uc3QgdXNlciA9IHRoaXMuYXV0aFNlcnZpY2UuZ2V0U3RvcmVkVXNlcigpO1xuICAgIGNvbnN0IHJlZnJlc2hUb2tlbiA9IHRoaXMuYXV0aFNlcnZpY2UuZ2V0U3RvcmVkUmVmcmVzaFRva2VuKCk7XG4gICAgXG4gICAgLy8gTXVzdCBoYXZlIGJvdGggdG9rZW4gYW5kIHVzZXIgZGF0YSB0byBiZSBjb25zaWRlcmVkIGF1dGhlbnRpY2F0ZWRcbiAgICBpZiAoIXRva2VuIHx8ICF1c2VyKSB7XG4gICAgICB0aGlzLnJvdXRlci5uYXZpZ2F0ZShbJy9sb2dpbiddKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgdG9rZW4gaXMgdmFsaWRcbiAgICBjb25zdCBpc1Rva2VuVmFsaWQgPSB0aGlzLmF1dGhTZXJ2aWNlLmlzVG9rZW5WYWxpZCh0b2tlbik7XG4gICAgXG4gICAgaWYgKGlzVG9rZW5WYWxpZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIC8vIFRva2VuIGlzIGV4cGlyZWQgLSBjaGVjayBpZiB3ZSBoYXZlIGEgcmVmcmVzaCB0b2tlblxuICAgIGlmIChyZWZyZXNoVG9rZW4pIHtcbiAgICAgIC8vIEFsbG93IGFjY2VzcyAtIHRva2VuIHJlZnJlc2ggd2lsbCBoYXBwZW4gaW4gYmFja2dyb3VuZCB2aWEgaW5pdGlhbGl6ZUF1dGhTdGF0ZVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIC8vIFRva2VuIGlzIGV4cGlyZWQgYW5kIG5vIHJlZnJlc2ggdG9rZW5cbiAgICAvLyBEb24ndCByZWRpcmVjdCBpbW1lZGlhdGVseSAtIGxldCBpbml0aWFsaXplQXV0aFN0YXRlIGhhbmRsZSBpdFxuICAgIC8vIFRoaXMgcHJldmVudHMgcmFjZSBjb25kaXRpb25zIHdoZXJlIGd1YXJkIHJ1bnMgYmVmb3JlIHN0YXRlIGlzIGluaXRpYWxpemVkXG4gICAgLy8gSWYgc3RhdGUgaW5pdGlhbGl6YXRpb24gY2xlYXJzIGRhdGEsIHRoZSBuZXh0IG5hdmlnYXRpb24gd2lsbCByZWRpcmVjdFxuICAgIGNvbnNvbGUud2FybignVG9rZW4gZXhwaXJlZCBhbmQgbm8gcmVmcmVzaCB0b2tlbiBmb3VuZC4gQWNjZXNzIG1heSBiZSBkZW5pZWQgYWZ0ZXIgc3RhdGUgaW5pdGlhbGl6YXRpb24uJyk7XG4gICAgXG4gICAgLy8gQ2hlY2sgYXV0aCBzdGF0ZSBhcyBmYWxsYmFjayAoaW4gY2FzZSBpbml0aWFsaXplQXV0aFN0YXRlIGFscmVhZHkgcmFuKVxuICAgIGNvbnN0IGlzQXV0aGVudGljYXRlZCA9IHRoaXMuYXV0aFNlcnZpY2UuaXNBdXRoZW50aWNhdGVkKCk7XG4gICAgaWYgKCFpc0F1dGhlbnRpY2F0ZWQpIHtcbiAgICAgIHRoaXMucm91dGVyLm5hdmlnYXRlKFsnL2xvZ2luJ10pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICAvLyBJZiBhdXRoZW50aWNhdGVkIGluIHN0YXRlIGJ1dCB0b2tlbiBleHBpcmVkIGFuZCBubyByZWZyZXNoIHRva2VuLCBhbGxvdyBmb3Igbm93XG4gICAgLy8gVGhlIEhUVFAgaW50ZXJjZXB0b3Igd2lsbCBoYW5kbGUgNDAxIGVycm9yc1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59IFxuIl19