import {
  Router,
  RouterModule
} from "./chunk-BV4LGHFF.js";
import {
  AgGridAngular,
  AgGridModule
} from "./chunk-VTDQMSNB.js";
import {
  AllCommunityModule,
  ModuleRegistry
} from "./chunk-43MM645G.js";
import {
  MatSnackBar
} from "./chunk-77VRKUDO.js";
import {
  MatTab,
  MatTabGroup,
  MatTabsModule
} from "./chunk-P2ACCR7O.js";
import {
  MatDatepicker,
  MatDatepickerInput,
  MatDatepickerModule,
  MatDatepickerToggle
} from "./chunk-XAT3O5T7.js";
import {
  MatMenu,
  MatMenuItem,
  MatMenuModule,
  MatMenuTrigger
} from "./chunk-CC6RK7GO.js";
import {
  MatProgressSpinner,
  MatProgressSpinnerModule
} from "./chunk-RW4WIYUW.js";
import {
  MatProgressBar,
  MatProgressBarModule
} from "./chunk-VDKR6YGH.js";
import {
  MatTooltipModule
} from "./chunk-H2H455HJ.js";
import {
  MatRadioButton,
  MatRadioGroup,
  MatRadioModule
} from "./chunk-3XR5EBGD.js";
import {
  MatSelect,
  MatSelectModule
} from "./chunk-2LY6BI2N.js";
import {
  MatButton,
  MatButtonModule,
  MatFabButton,
  MatIconButton,
  MatMiniFabButton
} from "./chunk-OTPCNZR3.js";
import {
  MatCheckbox,
  MatCheckboxModule
} from "./chunk-PZKRKUBJ.js";
import {
  MAT_DIALOG_DATA,
  MatDialog,
  MatDialogModule,
  MatDialogRef
} from "./chunk-K5IDVLS5.js";
import {
  Overlay,
  OverlayConfig,
  OverlayModule
} from "./chunk-T6E2NSW4.js";
import {
  CdkPortalOutlet,
  PortalModule,
  TemplatePortal
} from "./chunk-RWHEAH7C.js";
import {
  MatInput,
  MatInputModule
} from "./chunk-KAH4AWWF.js";
import {
  MatIcon,
  MatIconModule
} from "./chunk-SEGXQUAR.js";
import {
  DomSanitizer
} from "./chunk-ITCWIC3J.js";
import {
  CdkScrollableModule,
  ViewportRuler
} from "./chunk-BMPG5AR4.js";
import {
  DataSource,
  SelectionModel,
  isDataSource
} from "./chunk-HGRTJHCI.js";
import {
  HttpBackend,
  HttpClient,
  HttpClientModule,
  HttpErrorResponse,
  HttpEventType,
  HttpHeaders,
  HttpParams
} from "./chunk-RKGXA5Q4.js";
import {
  MatCard,
  MatCardModule
} from "./chunk-Z4GW4PRE.js";
import {
  MAT_FORM_FIELD,
  MatError,
  MatFormField,
  MatFormFieldModule,
  MatLabel,
  MatPrefix,
  MatSuffix
} from "./chunk-YV3HTG2S.js";
import {
  animate,
  animateChild,
  group,
  query,
  state,
  style,
  transition,
  trigger
} from "./chunk-C5WRM4C7.js";
import {
  ErrorStateMatcher,
  MAT_OPTGROUP,
  MAT_OPTION_PARENT_COMPONENT,
  MAT_RIPPLE_GLOBAL_OPTIONS,
  MatCommonModule,
  MatNativeDateModule,
  MatOption,
  MatOptionModule,
  MatOptionSelectionChange,
  MatPseudoCheckbox,
  MatRipple,
  MatRippleModule,
  RippleState,
  _countGroupLabelsBeforeOption,
  _getOptionScrollPosition
} from "./chunk-K4OEN2R2.js";
import {
  ActiveDescendantKeyManager,
  BidiModule,
  DOWN_ARROW,
  Directionality,
  ENTER,
  ESCAPE,
  FocusKeyManager,
  FocusMonitor,
  SPACE,
  TAB,
  UP_ARROW,
  addAriaReferencedId,
  hasModifierKey,
  removeAriaReferencedId
} from "./chunk-BHZU6BPX.js";
import {
  Platform,
  _getEventTarget,
  _getFocusedElementPierceShadowDom
} from "./chunk-MVCHEGOW.js";
import {
  DefaultValueAccessor,
  FormControl,
  FormGroup,
  FormsModule,
  MaxValidator,
  MinValidator,
  NG_VALUE_ACCESSOR,
  NgControlStatus,
  NgModel,
  NumberValueAccessor,
  ReactiveFormsModule
} from "./chunk-VE57AO4I.js";
import {
  AsyncPipe,
  CommonModule,
  DOCUMENT,
  DecimalPipe,
  I18nPluralPipe,
  NgClass,
  NgComponentOutlet,
  NgForOf,
  NgIf,
  NgStyle,
  NgSwitch,
  NgSwitchCase,
  NgSwitchDefault,
  NgTemplateOutlet,
  SlicePipe,
  TitleCasePipe,
  formatDate,
  isPlatformBrowser
} from "./chunk-LFWXFD52.js";
import {
  ANIMATION_MODULE_TYPE,
  Attribute,
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  Component,
  ComponentFactoryResolver$1,
  ContentChild,
  ContentChildren,
  Directive,
  ElementRef,
  EventEmitter,
  Host,
  HostListener,
  Inject,
  Injectable,
  InjectionToken,
  Injector,
  Input,
  InputFlags,
  IterableDiffers,
  LOCALE_ID,
  NgModule,
  NgZone,
  Optional,
  Output,
  PLATFORM_ID,
  Pipe,
  QueryList,
  Renderer2,
  SkipSelf,
  TemplateRef,
  ViewChild,
  ViewChildren,
  ViewContainerRef,
  ViewEncapsulation$1,
  booleanAttribute,
  computed,
  effect,
  forwardRef,
  inject,
  numberAttribute,
  runInInjectionContext,
  setClassMetadata,
  signal,
  ɵɵInheritDefinitionFeature,
  ɵɵInputTransformsFeature,
  ɵɵNgOnChangesFeature,
  ɵɵProvidersFeature,
  ɵɵStandaloneFeature,
  ɵɵadvance,
  ɵɵattribute,
  ɵɵclassMap,
  ɵɵclassMapInterpolate1,
  ɵɵclassProp,
  ɵɵconditional,
  ɵɵcontentQuery,
  ɵɵdefineComponent,
  ɵɵdefineDirective,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdefinePipe,
  ɵɵdirectiveInject,
  ɵɵelement,
  ɵɵelementContainer,
  ɵɵelementContainerEnd,
  ɵɵelementContainerStart,
  ɵɵelementEnd,
  ɵɵelementStart,
  ɵɵgetCurrentView,
  ɵɵgetInheritedFactory,
  ɵɵhostProperty,
  ɵɵinject,
  ɵɵinjectAttribute,
  ɵɵlistener,
  ɵɵloadQuery,
  ɵɵnextContext,
  ɵɵpipe,
  ɵɵpipeBind1,
  ɵɵpipeBind2,
  ɵɵpipeBind3,
  ɵɵprojection,
  ɵɵprojectionDef,
  ɵɵproperty,
  ɵɵpureFunction0,
  ɵɵpureFunction1,
  ɵɵpureFunction2,
  ɵɵpureFunction3,
  ɵɵpureFunction4,
  ɵɵpureFunction5,
  ɵɵpureFunction6,
  ɵɵpureFunction7,
  ɵɵpureFunctionV,
  ɵɵqueryRefresh,
  ɵɵreference,
  ɵɵrepeater,
  ɵɵrepeaterCreate,
  ɵɵrepeaterTrackByIdentity,
  ɵɵrepeaterTrackByIndex,
  ɵɵresetView,
  ɵɵrestoreView,
  ɵɵsanitizeHtml,
  ɵɵsanitizeResourceUrl,
  ɵɵsanitizeUrl,
  ɵɵstyleMap,
  ɵɵstyleProp,
  ɵɵtemplate,
  ɵɵtemplateRefExtractor,
  ɵɵtext,
  ɵɵtextInterpolate,
  ɵɵtextInterpolate1,
  ɵɵtextInterpolate2,
  ɵɵtwoWayBindingSet,
  ɵɵtwoWayListener,
  ɵɵtwoWayProperty,
  ɵɵviewQuery
} from "./chunk-YLXROL5I.js";
import {
  defer,
  forkJoin,
  fromEvent,
  isObservable,
  merge
} from "./chunk-RTBI3O22.js";
import {
  BehaviorSubject,
  Observable,
  ReplaySubject,
  Subject,
  Subscription,
  catchError,
  combineLatest,
  count,
  debounceTime,
  delay,
  distinctUntilChanged,
  filter,
  interval,
  map,
  mergeMap,
  of,
  pairwise,
  share,
  startWith,
  switchMap,
  switchMapTo,
  take,
  takeLast,
  takeUntil,
  tap,
  throwError,
  timer
} from "./chunk-XUJVPDVA.js";
import {
  __async,
  __objRest,
  __spreadProps,
  __spreadValues
} from "./chunk-3OV72XIM.js";

// node_modules/@angular/material/fesm2022/autocomplete.mjs
var _c0 = ["panel"];
var _c1 = ["*"];
function MatAutocomplete_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 1, 0);
    ɵɵlistener("@panelAnimation.done", function MatAutocomplete_ng_template_0_Template_div_animation_panelAnimation_done_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._animationDone.next($event));
    });
    ɵɵprojection(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const formFieldId_r3 = ctx.id;
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap(ctx_r1._classList);
    ɵɵclassProp("mat-mdc-autocomplete-visible", ctx_r1.showPanel)("mat-mdc-autocomplete-hidden", !ctx_r1.showPanel)("mat-primary", ctx_r1._color === "primary")("mat-accent", ctx_r1._color === "accent")("mat-warn", ctx_r1._color === "warn");
    ɵɵproperty("id", ctx_r1.id)("@panelAnimation", ctx_r1.isOpen ? "visible" : "hidden");
    ɵɵattribute("aria-label", ctx_r1.ariaLabel || null)("aria-labelledby", ctx_r1._getPanelAriaLabelledby(formFieldId_r3));
  }
}
var panelAnimation = trigger("panelAnimation", [state("void, hidden", style({
  opacity: 0,
  transform: "scaleY(0.8)"
})), transition(":enter, hidden => visible", [group([animate("0.03s linear", style({
  opacity: 1
})), animate("0.12s cubic-bezier(0, 0, 0.2, 1)", style({
  transform: "scaleY(1)"
}))])]), transition(":leave, visible => hidden", [animate("0.075s linear", style({
  opacity: 0
}))])]);
var _uniqueAutocompleteIdCounter = 0;
var MatAutocompleteSelectedEvent = class {
  constructor(source, option) {
    this.source = source;
    this.option = option;
  }
};
var MAT_AUTOCOMPLETE_DEFAULT_OPTIONS = new InjectionToken("mat-autocomplete-default-options", {
  providedIn: "root",
  factory: MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY
});
function MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY() {
  return {
    autoActiveFirstOption: false,
    autoSelectActiveOption: false,
    hideSingleSelectionIndicator: false,
    requireSelection: false
  };
}
var MatAutocomplete = class _MatAutocomplete {
  /** Whether the autocomplete panel is open. */
  get isOpen() {
    return this._isOpen && this.showPanel;
  }
  /** @docs-private Sets the theme color of the panel. */
  _setColor(value) {
    this._color = value;
    this._changeDetectorRef.markForCheck();
  }
  /**
   * Takes classes set on the host mat-autocomplete element and applies them to the panel
   * inside the overlay container to allow for easy styling.
   */
  set classList(value) {
    this._classList = value;
    this._elementRef.nativeElement.className = "";
  }
  /** Whether checkmark indicator for single-selection options is hidden. */
  get hideSingleSelectionIndicator() {
    return this._hideSingleSelectionIndicator;
  }
  set hideSingleSelectionIndicator(value) {
    this._hideSingleSelectionIndicator = value;
    this._syncParentProperties();
  }
  /** Syncs the parent state with the individual options. */
  _syncParentProperties() {
    if (this.options) {
      for (const option of this.options) {
        option._changeDetectorRef.markForCheck();
      }
    }
  }
  constructor(_changeDetectorRef, _elementRef, _defaults, platform) {
    this._changeDetectorRef = _changeDetectorRef;
    this._elementRef = _elementRef;
    this._defaults = _defaults;
    this._activeOptionChanges = Subscription.EMPTY;
    this._animationDone = new EventEmitter();
    this.showPanel = false;
    this._isOpen = false;
    this.displayWith = null;
    this.optionSelected = new EventEmitter();
    this.opened = new EventEmitter();
    this.closed = new EventEmitter();
    this.optionActivated = new EventEmitter();
    this.id = `mat-autocomplete-${_uniqueAutocompleteIdCounter++}`;
    this.inertGroups = platform?.SAFARI || false;
    this.autoActiveFirstOption = !!_defaults.autoActiveFirstOption;
    this.autoSelectActiveOption = !!_defaults.autoSelectActiveOption;
    this.requireSelection = !!_defaults.requireSelection;
    this._hideSingleSelectionIndicator = this._defaults.hideSingleSelectionIndicator ?? false;
  }
  ngAfterContentInit() {
    this._keyManager = new ActiveDescendantKeyManager(this.options).withWrap().skipPredicate(this._skipPredicate);
    this._activeOptionChanges = this._keyManager.change.subscribe((index) => {
      if (this.isOpen) {
        this.optionActivated.emit({
          source: this,
          option: this.options.toArray()[index] || null
        });
      }
    });
    this._setVisibility();
  }
  ngOnDestroy() {
    this._keyManager?.destroy();
    this._activeOptionChanges.unsubscribe();
    this._animationDone.complete();
  }
  /**
   * Sets the panel scrollTop. This allows us to manually scroll to display options
   * above or below the fold, as they are not actually being focused when active.
   */
  _setScrollTop(scrollTop) {
    if (this.panel) {
      this.panel.nativeElement.scrollTop = scrollTop;
    }
  }
  /** Returns the panel's scrollTop. */
  _getScrollTop() {
    return this.panel ? this.panel.nativeElement.scrollTop : 0;
  }
  /** Panel should hide itself when the option list is empty. */
  _setVisibility() {
    this.showPanel = !!this.options.length;
    this._changeDetectorRef.markForCheck();
  }
  /** Emits the `select` event. */
  _emitSelectEvent(option) {
    const event = new MatAutocompleteSelectedEvent(this, option);
    this.optionSelected.emit(event);
  }
  /** Gets the aria-labelledby for the autocomplete panel. */
  _getPanelAriaLabelledby(labelId) {
    if (this.ariaLabel) {
      return null;
    }
    const labelExpression = labelId ? labelId + " " : "";
    return this.ariaLabelledby ? labelExpression + this.ariaLabelledby : labelId;
  }
  // `skipPredicate` determines if key manager should avoid putting a given option in the tab
  // order. Allow disabled list items to receive focus via keyboard to align with WAI ARIA
  // recommendation.
  //
  // Normally WAI ARIA's instructions are to exclude disabled items from the tab order, but it
  // makes a few exceptions for compound widgets.
  //
  // From [Developing a Keyboard Interface](
  // https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/):
  //   "For the following composite widget elements, keep them focusable when disabled: Options in a
  //   Listbox..."
  //
  // The user can focus disabled options using the keyboard, but the user cannot click disabled
  // options.
  _skipPredicate() {
    return false;
  }
  static {
    this.ɵfac = function MatAutocomplete_Factory(t) {
      return new (t || _MatAutocomplete)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(MAT_AUTOCOMPLETE_DEFAULT_OPTIONS), ɵɵdirectiveInject(Platform));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _MatAutocomplete,
      selectors: [["mat-autocomplete"]],
      contentQueries: function MatAutocomplete_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          ɵɵcontentQuery(dirIndex, MatOption, 5);
          ɵɵcontentQuery(dirIndex, MAT_OPTGROUP, 5);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.options = _t);
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.optionGroups = _t);
        }
      },
      viewQuery: function MatAutocomplete_Query(rf, ctx) {
        if (rf & 1) {
          ɵɵviewQuery(TemplateRef, 7);
          ɵɵviewQuery(_c0, 5);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.template = _t.first);
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.panel = _t.first);
        }
      },
      hostAttrs: [1, "mat-mdc-autocomplete"],
      inputs: {
        ariaLabel: [InputFlags.None, "aria-label", "ariaLabel"],
        ariaLabelledby: [InputFlags.None, "aria-labelledby", "ariaLabelledby"],
        displayWith: "displayWith",
        autoActiveFirstOption: [InputFlags.HasDecoratorInputTransform, "autoActiveFirstOption", "autoActiveFirstOption", booleanAttribute],
        autoSelectActiveOption: [InputFlags.HasDecoratorInputTransform, "autoSelectActiveOption", "autoSelectActiveOption", booleanAttribute],
        requireSelection: [InputFlags.HasDecoratorInputTransform, "requireSelection", "requireSelection", booleanAttribute],
        panelWidth: "panelWidth",
        disableRipple: [InputFlags.HasDecoratorInputTransform, "disableRipple", "disableRipple", booleanAttribute],
        classList: [InputFlags.None, "class", "classList"],
        hideSingleSelectionIndicator: [InputFlags.HasDecoratorInputTransform, "hideSingleSelectionIndicator", "hideSingleSelectionIndicator", booleanAttribute]
      },
      outputs: {
        optionSelected: "optionSelected",
        opened: "opened",
        closed: "closed",
        optionActivated: "optionActivated"
      },
      exportAs: ["matAutocomplete"],
      standalone: true,
      features: [ɵɵProvidersFeature([{
        provide: MAT_OPTION_PARENT_COMPONENT,
        useExisting: _MatAutocomplete
      }]), ɵɵInputTransformsFeature, ɵɵStandaloneFeature],
      ngContentSelectors: _c1,
      decls: 1,
      vars: 0,
      consts: [["panel", ""], ["role", "listbox", 1, "mat-mdc-autocomplete-panel", "mdc-menu-surface", "mdc-menu-surface--open", 3, "id"]],
      template: function MatAutocomplete_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef();
          ɵɵtemplate(0, MatAutocomplete_ng_template_0_Template, 3, 16, "ng-template");
        }
      },
      styles: ["div.mat-mdc-autocomplete-panel{width:100%;max-height:256px;visibility:hidden;transform-origin:center top;overflow:auto;padding:8px 0;box-sizing:border-box;position:static;border-radius:var(--mat-autocomplete-container-shape);box-shadow:var(--mat-autocomplete-container-elevation-shadow);background-color:var(--mat-autocomplete-background-color)}.cdk-high-contrast-active div.mat-mdc-autocomplete-panel{outline:solid 1px}.cdk-overlay-pane:not(.mat-mdc-autocomplete-panel-above) div.mat-mdc-autocomplete-panel{border-top-left-radius:0;border-top-right-radius:0}.mat-mdc-autocomplete-panel-above div.mat-mdc-autocomplete-panel{border-bottom-left-radius:0;border-bottom-right-radius:0;transform-origin:center bottom}div.mat-mdc-autocomplete-panel.mat-mdc-autocomplete-visible{visibility:visible}div.mat-mdc-autocomplete-panel.mat-mdc-autocomplete-hidden{visibility:hidden;pointer-events:none}mat-autocomplete{display:none}"],
      encapsulation: 2,
      data: {
        animation: [panelAnimation]
      },
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatAutocomplete, [{
    type: Component,
    args: [{
      selector: "mat-autocomplete",
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      exportAs: "matAutocomplete",
      host: {
        "class": "mat-mdc-autocomplete"
      },
      providers: [{
        provide: MAT_OPTION_PARENT_COMPONENT,
        useExisting: MatAutocomplete
      }],
      animations: [panelAnimation],
      standalone: true,
      template: `<ng-template let-formFieldId="id">
  <div
    class="mat-mdc-autocomplete-panel mdc-menu-surface mdc-menu-surface--open"
    role="listbox"
    [id]="id"
    [class]="_classList"
    [class.mat-mdc-autocomplete-visible]="showPanel"
    [class.mat-mdc-autocomplete-hidden]="!showPanel"
    [class.mat-primary]="_color === 'primary'"
    [class.mat-accent]="_color === 'accent'"
    [class.mat-warn]="_color === 'warn'"
    [attr.aria-label]="ariaLabel || null"
    [attr.aria-labelledby]="_getPanelAriaLabelledby(formFieldId)"
    [@panelAnimation]="isOpen ? 'visible' : 'hidden'"
    (@panelAnimation.done)="_animationDone.next($event)"
    #panel>
    <ng-content></ng-content>
  </div>
</ng-template>
`,
      styles: ["div.mat-mdc-autocomplete-panel{width:100%;max-height:256px;visibility:hidden;transform-origin:center top;overflow:auto;padding:8px 0;box-sizing:border-box;position:static;border-radius:var(--mat-autocomplete-container-shape);box-shadow:var(--mat-autocomplete-container-elevation-shadow);background-color:var(--mat-autocomplete-background-color)}.cdk-high-contrast-active div.mat-mdc-autocomplete-panel{outline:solid 1px}.cdk-overlay-pane:not(.mat-mdc-autocomplete-panel-above) div.mat-mdc-autocomplete-panel{border-top-left-radius:0;border-top-right-radius:0}.mat-mdc-autocomplete-panel-above div.mat-mdc-autocomplete-panel{border-bottom-left-radius:0;border-bottom-right-radius:0;transform-origin:center bottom}div.mat-mdc-autocomplete-panel.mat-mdc-autocomplete-visible{visibility:visible}div.mat-mdc-autocomplete-panel.mat-mdc-autocomplete-hidden{visibility:hidden;pointer-events:none}mat-autocomplete{display:none}"]
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [MAT_AUTOCOMPLETE_DEFAULT_OPTIONS]
    }]
  }, {
    type: Platform
  }], {
    template: [{
      type: ViewChild,
      args: [TemplateRef, {
        static: true
      }]
    }],
    panel: [{
      type: ViewChild,
      args: ["panel"]
    }],
    options: [{
      type: ContentChildren,
      args: [MatOption, {
        descendants: true
      }]
    }],
    optionGroups: [{
      type: ContentChildren,
      args: [MAT_OPTGROUP, {
        descendants: true
      }]
    }],
    ariaLabel: [{
      type: Input,
      args: ["aria-label"]
    }],
    ariaLabelledby: [{
      type: Input,
      args: ["aria-labelledby"]
    }],
    displayWith: [{
      type: Input
    }],
    autoActiveFirstOption: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    autoSelectActiveOption: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    requireSelection: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    panelWidth: [{
      type: Input
    }],
    disableRipple: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    optionSelected: [{
      type: Output
    }],
    opened: [{
      type: Output
    }],
    closed: [{
      type: Output
    }],
    optionActivated: [{
      type: Output
    }],
    classList: [{
      type: Input,
      args: ["class"]
    }],
    hideSingleSelectionIndicator: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }]
  });
})();
var MatAutocompleteOrigin = class _MatAutocompleteOrigin {
  constructor(elementRef) {
    this.elementRef = elementRef;
  }
  static {
    this.ɵfac = function MatAutocompleteOrigin_Factory(t) {
      return new (t || _MatAutocompleteOrigin)(ɵɵdirectiveInject(ElementRef));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _MatAutocompleteOrigin,
      selectors: [["", "matAutocompleteOrigin", ""]],
      exportAs: ["matAutocompleteOrigin"],
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatAutocompleteOrigin, [{
    type: Directive,
    args: [{
      selector: "[matAutocompleteOrigin]",
      exportAs: "matAutocompleteOrigin",
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }], null);
})();
var MAT_AUTOCOMPLETE_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => MatAutocompleteTrigger),
  multi: true
};
function getMatAutocompleteMissingPanelError() {
  return Error("Attempting to open an undefined instance of `mat-autocomplete`. Make sure that the id passed to the `matAutocomplete` is correct and that you're attempting to open it after the ngAfterContentInit hook.");
}
var MAT_AUTOCOMPLETE_SCROLL_STRATEGY = new InjectionToken("mat-autocomplete-scroll-strategy", {
  providedIn: "root",
  factory: () => {
    const overlay = inject(Overlay);
    return () => overlay.scrollStrategies.reposition();
  }
});
function MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY(overlay) {
  return () => overlay.scrollStrategies.reposition();
}
var MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER = {
  provide: MAT_AUTOCOMPLETE_SCROLL_STRATEGY,
  deps: [Overlay],
  useFactory: MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY
};
var MatAutocompleteTrigger = class _MatAutocompleteTrigger {
  constructor(_element, _overlay, _viewContainerRef, _zone, _changeDetectorRef, scrollStrategy, _dir, _formField, _document, _viewportRuler, _defaults) {
    this._element = _element;
    this._overlay = _overlay;
    this._viewContainerRef = _viewContainerRef;
    this._zone = _zone;
    this._changeDetectorRef = _changeDetectorRef;
    this._dir = _dir;
    this._formField = _formField;
    this._document = _document;
    this._viewportRuler = _viewportRuler;
    this._defaults = _defaults;
    this._componentDestroyed = false;
    this._manuallyFloatingLabel = false;
    this._viewportSubscription = Subscription.EMPTY;
    this._canOpenOnNextFocus = true;
    this._closeKeyEventStream = new Subject();
    this._windowBlurHandler = () => {
      this._canOpenOnNextFocus = this._document.activeElement !== this._element.nativeElement || this.panelOpen;
    };
    this._onChange = () => {
    };
    this._onTouched = () => {
    };
    this.position = "auto";
    this.autocompleteAttribute = "off";
    this._aboveClass = "mat-mdc-autocomplete-panel-above";
    this._overlayAttached = false;
    this.optionSelections = defer(() => {
      const options = this.autocomplete ? this.autocomplete.options : null;
      if (options) {
        return options.changes.pipe(startWith(options), switchMap(() => merge(...options.map((option) => option.onSelectionChange))));
      }
      return this._zone.onStable.pipe(take(1), switchMap(() => this.optionSelections));
    });
    this._handlePanelKeydown = (event) => {
      if (event.keyCode === ESCAPE && !hasModifierKey(event) || event.keyCode === UP_ARROW && hasModifierKey(event, "altKey")) {
        if (this._pendingAutoselectedOption) {
          this._updateNativeInputValue(this._valueBeforeAutoSelection ?? "");
          this._pendingAutoselectedOption = null;
        }
        this._closeKeyEventStream.next();
        this._resetActiveItem();
        event.stopPropagation();
        event.preventDefault();
      }
    };
    this._trackedModal = null;
    this._scrollStrategy = scrollStrategy;
  }
  ngAfterViewInit() {
    const window2 = this._getWindow();
    if (typeof window2 !== "undefined") {
      this._zone.runOutsideAngular(() => window2.addEventListener("blur", this._windowBlurHandler));
    }
  }
  ngOnChanges(changes) {
    if (changes["position"] && this._positionStrategy) {
      this._setStrategyPositions(this._positionStrategy);
      if (this.panelOpen) {
        this._overlayRef.updatePosition();
      }
    }
  }
  ngOnDestroy() {
    const window2 = this._getWindow();
    if (typeof window2 !== "undefined") {
      window2.removeEventListener("blur", this._windowBlurHandler);
    }
    this._viewportSubscription.unsubscribe();
    this._componentDestroyed = true;
    this._destroyPanel();
    this._closeKeyEventStream.complete();
    this._clearFromModal();
  }
  /** Whether or not the autocomplete panel is open. */
  get panelOpen() {
    return this._overlayAttached && this.autocomplete.showPanel;
  }
  /** Opens the autocomplete suggestion panel. */
  openPanel() {
    this._openPanelInternal();
  }
  /** Closes the autocomplete suggestion panel. */
  closePanel() {
    this._resetLabel();
    if (!this._overlayAttached) {
      return;
    }
    if (this.panelOpen) {
      this._zone.run(() => {
        this.autocomplete.closed.emit();
      });
    }
    if (this.autocomplete._latestOpeningTrigger === this) {
      this.autocomplete._isOpen = false;
      this.autocomplete._latestOpeningTrigger = null;
    }
    this._overlayAttached = false;
    this._pendingAutoselectedOption = null;
    if (this._overlayRef && this._overlayRef.hasAttached()) {
      this._overlayRef.detach();
      this._closingActionsSubscription.unsubscribe();
    }
    this._updatePanelState();
    if (!this._componentDestroyed) {
      this._changeDetectorRef.detectChanges();
    }
    if (this._trackedModal) {
      removeAriaReferencedId(this._trackedModal, "aria-owns", this.autocomplete.id);
    }
  }
  /**
   * Updates the position of the autocomplete suggestion panel to ensure that it fits all options
   * within the viewport.
   */
  updatePosition() {
    if (this._overlayAttached) {
      this._overlayRef.updatePosition();
    }
  }
  /**
   * A stream of actions that should close the autocomplete panel, including
   * when an option is selected, on blur, and when TAB is pressed.
   */
  get panelClosingActions() {
    return merge(this.optionSelections, this.autocomplete._keyManager.tabOut.pipe(filter(() => this._overlayAttached)), this._closeKeyEventStream, this._getOutsideClickStream(), this._overlayRef ? this._overlayRef.detachments().pipe(filter(() => this._overlayAttached)) : of()).pipe(
      // Normalize the output so we return a consistent type.
      map((event) => event instanceof MatOptionSelectionChange ? event : null)
    );
  }
  /** The currently active option, coerced to MatOption type. */
  get activeOption() {
    if (this.autocomplete && this.autocomplete._keyManager) {
      return this.autocomplete._keyManager.activeItem;
    }
    return null;
  }
  /** Stream of clicks outside of the autocomplete panel. */
  _getOutsideClickStream() {
    return merge(fromEvent(this._document, "click"), fromEvent(this._document, "auxclick"), fromEvent(this._document, "touchend")).pipe(filter((event) => {
      const clickTarget = _getEventTarget(event);
      const formField = this._formField ? this._formField.getConnectedOverlayOrigin().nativeElement : null;
      const customOrigin = this.connectedTo ? this.connectedTo.elementRef.nativeElement : null;
      return this._overlayAttached && clickTarget !== this._element.nativeElement && // Normally focus moves inside `mousedown` so this condition will almost always be
      // true. Its main purpose is to handle the case where the input is focused from an
      // outside click which propagates up to the `body` listener within the same sequence
      // and causes the panel to close immediately (see #3106).
      this._document.activeElement !== this._element.nativeElement && (!formField || !formField.contains(clickTarget)) && (!customOrigin || !customOrigin.contains(clickTarget)) && !!this._overlayRef && !this._overlayRef.overlayElement.contains(clickTarget);
    }));
  }
  // Implemented as part of ControlValueAccessor.
  writeValue(value) {
    Promise.resolve(null).then(() => this._assignOptionValue(value));
  }
  // Implemented as part of ControlValueAccessor.
  registerOnChange(fn) {
    this._onChange = fn;
  }
  // Implemented as part of ControlValueAccessor.
  registerOnTouched(fn) {
    this._onTouched = fn;
  }
  // Implemented as part of ControlValueAccessor.
  setDisabledState(isDisabled) {
    this._element.nativeElement.disabled = isDisabled;
  }
  _handleKeydown(event) {
    const keyCode = event.keyCode;
    const hasModifier = hasModifierKey(event);
    if (keyCode === ESCAPE && !hasModifier) {
      event.preventDefault();
    }
    this._valueOnLastKeydown = this._element.nativeElement.value;
    if (this.activeOption && keyCode === ENTER && this.panelOpen && !hasModifier) {
      this.activeOption._selectViaInteraction();
      this._resetActiveItem();
      event.preventDefault();
    } else if (this.autocomplete) {
      const prevActiveItem = this.autocomplete._keyManager.activeItem;
      const isArrowKey = keyCode === UP_ARROW || keyCode === DOWN_ARROW;
      if (keyCode === TAB || isArrowKey && !hasModifier && this.panelOpen) {
        this.autocomplete._keyManager.onKeydown(event);
      } else if (isArrowKey && this._canOpen()) {
        this._openPanelInternal(this._valueOnLastKeydown);
      }
      if (isArrowKey || this.autocomplete._keyManager.activeItem !== prevActiveItem) {
        this._scrollToOption(this.autocomplete._keyManager.activeItemIndex || 0);
        if (this.autocomplete.autoSelectActiveOption && this.activeOption) {
          if (!this._pendingAutoselectedOption) {
            this._valueBeforeAutoSelection = this._valueOnLastKeydown;
          }
          this._pendingAutoselectedOption = this.activeOption;
          this._assignOptionValue(this.activeOption.value);
        }
      }
    }
  }
  _handleInput(event) {
    let target = event.target;
    let value = target.value;
    if (target.type === "number") {
      value = value == "" ? null : parseFloat(value);
    }
    if (this._previousValue !== value) {
      this._previousValue = value;
      this._pendingAutoselectedOption = null;
      if (!this.autocomplete || !this.autocomplete.requireSelection) {
        this._onChange(value);
      }
      if (!value) {
        this._clearPreviousSelectedOption(null, false);
      } else if (this.panelOpen && !this.autocomplete.requireSelection) {
        const selectedOption = this.autocomplete.options?.find((option) => option.selected);
        if (selectedOption) {
          const display = this._getDisplayValue(selectedOption.value);
          if (value !== display) {
            selectedOption.deselect(false);
          }
        }
      }
      if (this._canOpen() && this._document.activeElement === event.target) {
        const valueOnAttach = this._valueOnLastKeydown ?? this._element.nativeElement.value;
        this._valueOnLastKeydown = null;
        this._openPanelInternal(valueOnAttach);
      }
    }
  }
  _handleFocus() {
    if (!this._canOpenOnNextFocus) {
      this._canOpenOnNextFocus = true;
    } else if (this._canOpen()) {
      this._previousValue = this._element.nativeElement.value;
      this._attachOverlay(this._previousValue);
      this._floatLabel(true);
    }
  }
  _handleClick() {
    if (this._canOpen() && !this.panelOpen) {
      this._openPanelInternal();
    }
  }
  /**
   * In "auto" mode, the label will animate down as soon as focus is lost.
   * This causes the value to jump when selecting an option with the mouse.
   * This method manually floats the label until the panel can be closed.
   * @param shouldAnimate Whether the label should be animated when it is floated.
   */
  _floatLabel(shouldAnimate = false) {
    if (this._formField && this._formField.floatLabel === "auto") {
      if (shouldAnimate) {
        this._formField._animateAndLockLabel();
      } else {
        this._formField.floatLabel = "always";
      }
      this._manuallyFloatingLabel = true;
    }
  }
  /** If the label has been manually elevated, return it to its normal state. */
  _resetLabel() {
    if (this._manuallyFloatingLabel) {
      if (this._formField) {
        this._formField.floatLabel = "auto";
      }
      this._manuallyFloatingLabel = false;
    }
  }
  /**
   * This method listens to a stream of panel closing actions and resets the
   * stream every time the option list changes.
   */
  _subscribeToClosingActions() {
    const firstStable = this._zone.onStable.pipe(take(1));
    const optionChanges = this.autocomplete.options.changes.pipe(
      tap(() => this._positionStrategy.reapplyLastPosition()),
      // Defer emitting to the stream until the next tick, because changing
      // bindings in here will cause "changed after checked" errors.
      delay(0)
    );
    return merge(firstStable, optionChanges).pipe(
      // create a new stream of panelClosingActions, replacing any previous streams
      // that were created, and flatten it so our stream only emits closing events...
      switchMap(() => {
        this._zone.run(() => {
          const wasOpen = this.panelOpen;
          this._resetActiveItem();
          this._updatePanelState();
          this._changeDetectorRef.detectChanges();
          if (this.panelOpen) {
            this._overlayRef.updatePosition();
          }
          if (wasOpen !== this.panelOpen) {
            if (this.panelOpen) {
              this._emitOpened();
            } else {
              this.autocomplete.closed.emit();
            }
          }
        });
        return this.panelClosingActions;
      }),
      // when the first closing event occurs...
      take(1)
    ).subscribe((event) => this._setValueAndClose(event));
  }
  /**
   * Emits the opened event once it's known that the panel will be shown and stores
   * the state of the trigger right before the opening sequence was finished.
   */
  _emitOpened() {
    this.autocomplete.opened.emit();
  }
  /** Destroys the autocomplete suggestion panel. */
  _destroyPanel() {
    if (this._overlayRef) {
      this.closePanel();
      this._overlayRef.dispose();
      this._overlayRef = null;
    }
  }
  /** Given a value, returns the string that should be shown within the input. */
  _getDisplayValue(value) {
    const autocomplete = this.autocomplete;
    return autocomplete && autocomplete.displayWith ? autocomplete.displayWith(value) : value;
  }
  _assignOptionValue(value) {
    const toDisplay = this._getDisplayValue(value);
    if (value == null) {
      this._clearPreviousSelectedOption(null, false);
    }
    this._updateNativeInputValue(toDisplay != null ? toDisplay : "");
  }
  _updateNativeInputValue(value) {
    if (this._formField) {
      this._formField._control.value = value;
    } else {
      this._element.nativeElement.value = value;
    }
    this._previousValue = value;
  }
  /**
   * This method closes the panel, and if a value is specified, also sets the associated
   * control to that value. It will also mark the control as dirty if this interaction
   * stemmed from the user.
   */
  _setValueAndClose(event) {
    const panel = this.autocomplete;
    const toSelect = event ? event.source : this._pendingAutoselectedOption;
    if (toSelect) {
      this._clearPreviousSelectedOption(toSelect);
      this._assignOptionValue(toSelect.value);
      this._onChange(toSelect.value);
      panel._emitSelectEvent(toSelect);
      this._element.nativeElement.focus();
    } else if (panel.requireSelection && this._element.nativeElement.value !== this._valueOnAttach) {
      this._clearPreviousSelectedOption(null);
      this._assignOptionValue(null);
      if (panel._animationDone) {
        panel._animationDone.pipe(take(1)).subscribe(() => this._onChange(null));
      } else {
        this._onChange(null);
      }
    }
    this.closePanel();
  }
  /**
   * Clear any previous selected option and emit a selection change event for this option
   */
  _clearPreviousSelectedOption(skip, emitEvent) {
    this.autocomplete?.options?.forEach((option) => {
      if (option !== skip && option.selected) {
        option.deselect(emitEvent);
      }
    });
  }
  _openPanelInternal(valueOnAttach = this._element.nativeElement.value) {
    this._attachOverlay(valueOnAttach);
    this._floatLabel();
    if (this._trackedModal) {
      const panelId = this.autocomplete.id;
      addAriaReferencedId(this._trackedModal, "aria-owns", panelId);
    }
  }
  _attachOverlay(valueOnAttach) {
    if (!this.autocomplete && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getMatAutocompleteMissingPanelError();
    }
    let overlayRef = this._overlayRef;
    if (!overlayRef) {
      this._portal = new TemplatePortal(this.autocomplete.template, this._viewContainerRef, {
        id: this._formField?.getLabelId()
      });
      overlayRef = this._overlay.create(this._getOverlayConfig());
      this._overlayRef = overlayRef;
      this._viewportSubscription = this._viewportRuler.change().subscribe(() => {
        if (this.panelOpen && overlayRef) {
          overlayRef.updateSize({
            width: this._getPanelWidth()
          });
        }
      });
    } else {
      this._positionStrategy.setOrigin(this._getConnectedElement());
      overlayRef.updateSize({
        width: this._getPanelWidth()
      });
    }
    if (overlayRef && !overlayRef.hasAttached()) {
      overlayRef.attach(this._portal);
      this._valueOnAttach = valueOnAttach;
      this._valueOnLastKeydown = null;
      this._closingActionsSubscription = this._subscribeToClosingActions();
    }
    const wasOpen = this.panelOpen;
    this.autocomplete._isOpen = this._overlayAttached = true;
    this.autocomplete._latestOpeningTrigger = this;
    this.autocomplete._setColor(this._formField?.color);
    this._updatePanelState();
    this._applyModalPanelOwnership();
    if (this.panelOpen && wasOpen !== this.panelOpen) {
      this._emitOpened();
    }
  }
  /** Updates the panel's visibility state and any trigger state tied to id. */
  _updatePanelState() {
    this.autocomplete._setVisibility();
    if (this.panelOpen) {
      const overlayRef = this._overlayRef;
      if (!this._keydownSubscription) {
        this._keydownSubscription = overlayRef.keydownEvents().subscribe(this._handlePanelKeydown);
      }
      if (!this._outsideClickSubscription) {
        this._outsideClickSubscription = overlayRef.outsidePointerEvents().subscribe();
      }
    } else {
      this._keydownSubscription?.unsubscribe();
      this._outsideClickSubscription?.unsubscribe();
      this._keydownSubscription = this._outsideClickSubscription = null;
    }
  }
  _getOverlayConfig() {
    return new OverlayConfig({
      positionStrategy: this._getOverlayPosition(),
      scrollStrategy: this._scrollStrategy(),
      width: this._getPanelWidth(),
      direction: this._dir ?? void 0,
      panelClass: this._defaults?.overlayPanelClass
    });
  }
  _getOverlayPosition() {
    const strategy = this._overlay.position().flexibleConnectedTo(this._getConnectedElement()).withFlexibleDimensions(false).withPush(false);
    this._setStrategyPositions(strategy);
    this._positionStrategy = strategy;
    return strategy;
  }
  /** Sets the positions on a position strategy based on the directive's input state. */
  _setStrategyPositions(positionStrategy) {
    const belowPositions = [{
      originX: "start",
      originY: "bottom",
      overlayX: "start",
      overlayY: "top"
    }, {
      originX: "end",
      originY: "bottom",
      overlayX: "end",
      overlayY: "top"
    }];
    const panelClass = this._aboveClass;
    const abovePositions = [{
      originX: "start",
      originY: "top",
      overlayX: "start",
      overlayY: "bottom",
      panelClass
    }, {
      originX: "end",
      originY: "top",
      overlayX: "end",
      overlayY: "bottom",
      panelClass
    }];
    let positions;
    if (this.position === "above") {
      positions = abovePositions;
    } else if (this.position === "below") {
      positions = belowPositions;
    } else {
      positions = [...belowPositions, ...abovePositions];
    }
    positionStrategy.withPositions(positions);
  }
  _getConnectedElement() {
    if (this.connectedTo) {
      return this.connectedTo.elementRef;
    }
    return this._formField ? this._formField.getConnectedOverlayOrigin() : this._element;
  }
  _getPanelWidth() {
    return this.autocomplete.panelWidth || this._getHostWidth();
  }
  /** Returns the width of the input element, so the panel width can match it. */
  _getHostWidth() {
    return this._getConnectedElement().nativeElement.getBoundingClientRect().width;
  }
  /**
   * Reset the active item to -1. This is so that pressing arrow keys will activate the correct
   * option.
   *
   * If the consumer opted-in to automatically activatating the first option, activate the first
   * *enabled* option.
   */
  _resetActiveItem() {
    const autocomplete = this.autocomplete;
    if (autocomplete.autoActiveFirstOption) {
      let firstEnabledOptionIndex = -1;
      for (let index = 0; index < autocomplete.options.length; index++) {
        const option = autocomplete.options.get(index);
        if (!option.disabled) {
          firstEnabledOptionIndex = index;
          break;
        }
      }
      autocomplete._keyManager.setActiveItem(firstEnabledOptionIndex);
    } else {
      autocomplete._keyManager.setActiveItem(-1);
    }
  }
  /** Determines whether the panel can be opened. */
  _canOpen() {
    const element = this._element.nativeElement;
    return !element.readOnly && !element.disabled && !this.autocompleteDisabled;
  }
  /** Use defaultView of injected document if available or fallback to global window reference */
  _getWindow() {
    return this._document?.defaultView || window;
  }
  /** Scrolls to a particular option in the list. */
  _scrollToOption(index) {
    const autocomplete = this.autocomplete;
    const labelCount = _countGroupLabelsBeforeOption(index, autocomplete.options, autocomplete.optionGroups);
    if (index === 0 && labelCount === 1) {
      autocomplete._setScrollTop(0);
    } else if (autocomplete.panel) {
      const option = autocomplete.options.toArray()[index];
      if (option) {
        const element = option._getHostElement();
        const newScrollPosition = _getOptionScrollPosition(element.offsetTop, element.offsetHeight, autocomplete._getScrollTop(), autocomplete.panel.nativeElement.offsetHeight);
        autocomplete._setScrollTop(newScrollPosition);
      }
    }
  }
  /**
   * If the autocomplete trigger is inside of an `aria-modal` element, connect
   * that modal to the options panel with `aria-owns`.
   *
   * For some browser + screen reader combinations, when navigation is inside
   * of an `aria-modal` element, the screen reader treats everything outside
   * of that modal as hidden or invisible.
   *
   * This causes a problem when the combobox trigger is _inside_ of a modal, because the
   * options panel is rendered _outside_ of that modal, preventing screen reader navigation
   * from reaching the panel.
   *
   * We can work around this issue by applying `aria-owns` to the modal with the `id` of
   * the options panel. This effectively communicates to assistive technology that the
   * options panel is part of the same interaction as the modal.
   *
   * At time of this writing, this issue is present in VoiceOver.
   * See https://github.com/angular/components/issues/20694
   */
  _applyModalPanelOwnership() {
    const modal = this._element.nativeElement.closest('body > .cdk-overlay-container [aria-modal="true"]');
    if (!modal) {
      return;
    }
    const panelId = this.autocomplete.id;
    if (this._trackedModal) {
      removeAriaReferencedId(this._trackedModal, "aria-owns", panelId);
    }
    addAriaReferencedId(modal, "aria-owns", panelId);
    this._trackedModal = modal;
  }
  /** Clears the references to the listbox overlay element from the modal it was added to. */
  _clearFromModal() {
    if (this._trackedModal) {
      const panelId = this.autocomplete.id;
      removeAriaReferencedId(this._trackedModal, "aria-owns", panelId);
      this._trackedModal = null;
    }
  }
  static {
    this.ɵfac = function MatAutocompleteTrigger_Factory(t) {
      return new (t || _MatAutocompleteTrigger)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Overlay), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(MAT_AUTOCOMPLETE_SCROLL_STRATEGY), ɵɵdirectiveInject(Directionality, 8), ɵɵdirectiveInject(MAT_FORM_FIELD, 9), ɵɵdirectiveInject(DOCUMENT, 8), ɵɵdirectiveInject(ViewportRuler), ɵɵdirectiveInject(MAT_AUTOCOMPLETE_DEFAULT_OPTIONS, 8));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _MatAutocompleteTrigger,
      selectors: [["input", "matAutocomplete", ""], ["textarea", "matAutocomplete", ""]],
      hostAttrs: [1, "mat-mdc-autocomplete-trigger"],
      hostVars: 7,
      hostBindings: function MatAutocompleteTrigger_HostBindings(rf, ctx) {
        if (rf & 1) {
          ɵɵlistener("focusin", function MatAutocompleteTrigger_focusin_HostBindingHandler() {
            return ctx._handleFocus();
          })("blur", function MatAutocompleteTrigger_blur_HostBindingHandler() {
            return ctx._onTouched();
          })("input", function MatAutocompleteTrigger_input_HostBindingHandler($event) {
            return ctx._handleInput($event);
          })("keydown", function MatAutocompleteTrigger_keydown_HostBindingHandler($event) {
            return ctx._handleKeydown($event);
          })("click", function MatAutocompleteTrigger_click_HostBindingHandler() {
            return ctx._handleClick();
          });
        }
        if (rf & 2) {
          ɵɵattribute("autocomplete", ctx.autocompleteAttribute)("role", ctx.autocompleteDisabled ? null : "combobox")("aria-autocomplete", ctx.autocompleteDisabled ? null : "list")("aria-activedescendant", ctx.panelOpen && ctx.activeOption ? ctx.activeOption.id : null)("aria-expanded", ctx.autocompleteDisabled ? null : ctx.panelOpen.toString())("aria-controls", ctx.autocompleteDisabled || !ctx.panelOpen ? null : ctx.autocomplete == null ? null : ctx.autocomplete.id)("aria-haspopup", ctx.autocompleteDisabled ? null : "listbox");
        }
      },
      inputs: {
        autocomplete: [InputFlags.None, "matAutocomplete", "autocomplete"],
        position: [InputFlags.None, "matAutocompletePosition", "position"],
        connectedTo: [InputFlags.None, "matAutocompleteConnectedTo", "connectedTo"],
        autocompleteAttribute: [InputFlags.None, "autocomplete", "autocompleteAttribute"],
        autocompleteDisabled: [InputFlags.HasDecoratorInputTransform, "matAutocompleteDisabled", "autocompleteDisabled", booleanAttribute]
      },
      exportAs: ["matAutocompleteTrigger"],
      standalone: true,
      features: [ɵɵProvidersFeature([MAT_AUTOCOMPLETE_VALUE_ACCESSOR]), ɵɵInputTransformsFeature, ɵɵNgOnChangesFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatAutocompleteTrigger, [{
    type: Directive,
    args: [{
      selector: `input[matAutocomplete], textarea[matAutocomplete]`,
      host: {
        "class": "mat-mdc-autocomplete-trigger",
        "[attr.autocomplete]": "autocompleteAttribute",
        "[attr.role]": 'autocompleteDisabled ? null : "combobox"',
        "[attr.aria-autocomplete]": 'autocompleteDisabled ? null : "list"',
        "[attr.aria-activedescendant]": "(panelOpen && activeOption) ? activeOption.id : null",
        "[attr.aria-expanded]": "autocompleteDisabled ? null : panelOpen.toString()",
        "[attr.aria-controls]": "(autocompleteDisabled || !panelOpen) ? null : autocomplete?.id",
        "[attr.aria-haspopup]": 'autocompleteDisabled ? null : "listbox"',
        // Note: we use `focusin`, as opposed to `focus`, in order to open the panel
        // a little earlier. This avoids issues where IE delays the focusing of the input.
        "(focusin)": "_handleFocus()",
        "(blur)": "_onTouched()",
        "(input)": "_handleInput($event)",
        "(keydown)": "_handleKeydown($event)",
        "(click)": "_handleClick()"
      },
      exportAs: "matAutocompleteTrigger",
      providers: [MAT_AUTOCOMPLETE_VALUE_ACCESSOR],
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Overlay
  }, {
    type: ViewContainerRef
  }, {
    type: NgZone
  }, {
    type: ChangeDetectorRef
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY]
    }]
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }, {
    type: MatFormField,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [MAT_FORM_FIELD]
    }, {
      type: Host
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: ViewportRuler
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [MAT_AUTOCOMPLETE_DEFAULT_OPTIONS]
    }]
  }], {
    autocomplete: [{
      type: Input,
      args: ["matAutocomplete"]
    }],
    position: [{
      type: Input,
      args: ["matAutocompletePosition"]
    }],
    connectedTo: [{
      type: Input,
      args: ["matAutocompleteConnectedTo"]
    }],
    autocompleteAttribute: [{
      type: Input,
      args: ["autocomplete"]
    }],
    autocompleteDisabled: [{
      type: Input,
      args: [{
        alias: "matAutocompleteDisabled",
        transform: booleanAttribute
      }]
    }]
  });
})();
var MatAutocompleteModule = class _MatAutocompleteModule {
  static {
    this.ɵfac = function MatAutocompleteModule_Factory(t) {
      return new (t || _MatAutocompleteModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _MatAutocompleteModule,
      imports: [OverlayModule, MatOptionModule, MatCommonModule, CommonModule, MatAutocomplete, MatAutocompleteTrigger, MatAutocompleteOrigin],
      exports: [CdkScrollableModule, MatAutocomplete, MatOptionModule, MatCommonModule, MatAutocompleteTrigger, MatAutocompleteOrigin]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      providers: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER],
      imports: [OverlayModule, MatOptionModule, MatCommonModule, CommonModule, CdkScrollableModule, MatOptionModule, MatCommonModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatAutocompleteModule, [{
    type: NgModule,
    args: [{
      imports: [OverlayModule, MatOptionModule, MatCommonModule, CommonModule, MatAutocomplete, MatAutocompleteTrigger, MatAutocompleteOrigin],
      exports: [CdkScrollableModule, MatAutocomplete, MatOptionModule, MatCommonModule, MatAutocompleteTrigger, MatAutocompleteOrigin],
      providers: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER]
    }]
  }], null, null);
})();

// node_modules/positioning/dist/positioning.js
var Positioning = (
  /** @class */
  function() {
    function Positioning2() {
    }
    Positioning2.prototype.getAllStyles = function(element) {
      return window.getComputedStyle(element);
    };
    Positioning2.prototype.getStyle = function(element, prop) {
      return this.getAllStyles(element)[prop];
    };
    Positioning2.prototype.isStaticPositioned = function(element) {
      return (this.getStyle(element, "position") || "static") === "static";
    };
    Positioning2.prototype.offsetParent = function(element) {
      var offsetParentEl = element.offsetParent || document.documentElement;
      while (offsetParentEl && offsetParentEl !== document.documentElement && this.isStaticPositioned(offsetParentEl)) {
        offsetParentEl = offsetParentEl.offsetParent;
      }
      return offsetParentEl || document.documentElement;
    };
    Positioning2.prototype.position = function(element, round) {
      if (round === void 0) {
        round = true;
      }
      var elPosition;
      var parentOffset = { width: 0, height: 0, top: 0, bottom: 0, left: 0, right: 0 };
      if (this.getStyle(element, "position") === "fixed") {
        elPosition = element.getBoundingClientRect();
        elPosition = {
          top: elPosition.top,
          bottom: elPosition.bottom,
          left: elPosition.left,
          right: elPosition.right,
          height: elPosition.height,
          width: elPosition.width
        };
      } else {
        var offsetParentEl = this.offsetParent(element);
        elPosition = this.offset(element, false);
        if (offsetParentEl !== document.documentElement) {
          parentOffset = this.offset(offsetParentEl, false);
        }
        parentOffset.top += offsetParentEl.clientTop;
        parentOffset.left += offsetParentEl.clientLeft;
      }
      elPosition.top -= parentOffset.top;
      elPosition.bottom -= parentOffset.top;
      elPosition.left -= parentOffset.left;
      elPosition.right -= parentOffset.left;
      if (round) {
        elPosition.top = Math.round(elPosition.top);
        elPosition.bottom = Math.round(elPosition.bottom);
        elPosition.left = Math.round(elPosition.left);
        elPosition.right = Math.round(elPosition.right);
      }
      return elPosition;
    };
    Positioning2.prototype.offset = function(element, round) {
      if (round === void 0) {
        round = true;
      }
      var elBcr = element.getBoundingClientRect();
      var viewportOffset = {
        top: window.pageYOffset - document.documentElement.clientTop,
        left: window.pageXOffset - document.documentElement.clientLeft
      };
      var elOffset = {
        height: elBcr.height || element.offsetHeight,
        width: elBcr.width || element.offsetWidth,
        top: elBcr.top + viewportOffset.top,
        bottom: elBcr.bottom + viewportOffset.top,
        left: elBcr.left + viewportOffset.left,
        right: elBcr.right + viewportOffset.left
      };
      if (round) {
        elOffset.height = Math.round(elOffset.height);
        elOffset.width = Math.round(elOffset.width);
        elOffset.top = Math.round(elOffset.top);
        elOffset.bottom = Math.round(elOffset.bottom);
        elOffset.left = Math.round(elOffset.left);
        elOffset.right = Math.round(elOffset.right);
      }
      return elOffset;
    };
    Positioning2.prototype.positionElements = function(hostElement, targetElement, placement, appendToBody) {
      var _a = placement.split("-"), _b = _a[0], placementPrimary = _b === void 0 ? "top" : _b, _c = _a[1], placementSecondary = _c === void 0 ? "center" : _c;
      var hostElPosition = appendToBody ? this.offset(hostElement, false) : this.position(hostElement, false);
      var targetElStyles = this.getAllStyles(targetElement);
      var marginTop = parseFloat(targetElStyles.marginTop);
      var marginBottom = parseFloat(targetElStyles.marginBottom);
      var marginLeft = parseFloat(targetElStyles.marginLeft);
      var marginRight = parseFloat(targetElStyles.marginRight);
      var topPosition = 0;
      var leftPosition = 0;
      switch (placementPrimary) {
        case "top":
          topPosition = hostElPosition.top - (targetElement.offsetHeight + marginTop + marginBottom);
          break;
        case "bottom":
          topPosition = hostElPosition.top + hostElPosition.height;
          break;
        case "left":
          leftPosition = hostElPosition.left - (targetElement.offsetWidth + marginLeft + marginRight);
          break;
        case "right":
          leftPosition = hostElPosition.left + hostElPosition.width;
          break;
      }
      switch (placementSecondary) {
        case "top":
          topPosition = hostElPosition.top;
          break;
        case "bottom":
          topPosition = hostElPosition.top + hostElPosition.height - targetElement.offsetHeight;
          break;
        case "left":
          leftPosition = hostElPosition.left;
          break;
        case "right":
          leftPosition = hostElPosition.left + hostElPosition.width - targetElement.offsetWidth;
          break;
        case "center":
          if (placementPrimary === "top" || placementPrimary === "bottom") {
            leftPosition = hostElPosition.left + hostElPosition.width / 2 - targetElement.offsetWidth / 2;
          } else {
            topPosition = hostElPosition.top + hostElPosition.height / 2 - targetElement.offsetHeight / 2;
          }
          break;
      }
      targetElement.style.transform = "translate(" + Math.round(leftPosition) + "px, " + Math.round(topPosition) + "px)";
      var targetElBCR = targetElement.getBoundingClientRect();
      var html = document.documentElement;
      var windowHeight = window.innerHeight || html.clientHeight;
      var windowWidth = window.innerWidth || html.clientWidth;
      return targetElBCR.left >= 0 && targetElBCR.top >= 0 && targetElBCR.right <= windowWidth && targetElBCR.bottom <= windowHeight;
    };
    return Positioning2;
  }()
);
var placementSeparator = /\s+/;
var positionService = new Positioning();
function positionElements(hostElement, targetElement, placement, appendToBody, baseClass) {
  var placementVals = Array.isArray(placement) ? placement : placement.split(placementSeparator);
  var allowedPlacements = [
    "top",
    "bottom",
    "left",
    "right",
    "top-left",
    "top-right",
    "bottom-left",
    "bottom-right",
    "left-top",
    "left-bottom",
    "right-top",
    "right-bottom"
  ];
  var classList = targetElement.classList;
  var addClassesToTarget = function(targetPlacement) {
    var _a = targetPlacement.split("-"), primary = _a[0], secondary = _a[1];
    var classes = [];
    if (baseClass) {
      classes.push(baseClass + "-" + primary);
      if (secondary) {
        classes.push(baseClass + "-" + primary + "-" + secondary);
      }
      classes.forEach(function(classname) {
        classList.add(classname);
      });
    }
    return classes;
  };
  if (baseClass) {
    allowedPlacements.forEach(function(placementToRemove) {
      classList.remove(baseClass + "-" + placementToRemove);
    });
  }
  var hasAuto = placementVals.findIndex(function(val) {
    return val === "auto";
  });
  if (hasAuto >= 0) {
    allowedPlacements.forEach(function(obj) {
      if (placementVals.find(function(val) {
        return val.search("^" + obj) !== -1;
      }) == null) {
        placementVals.splice(hasAuto++, 1, obj);
      }
    });
  }
  var style2 = targetElement.style;
  style2.position = "absolute";
  style2.top = "0";
  style2.left = "0";
  style2["will-change"] = "transform";
  var testPlacement;
  var isInViewport = false;
  for (var _i = 0, placementVals_1 = placementVals; _i < placementVals_1.length; _i++) {
    testPlacement = placementVals_1[_i];
    var addedClasses = addClassesToTarget(testPlacement);
    if (positionService.positionElements(hostElement, targetElement, testPlacement, appendToBody)) {
      isInViewport = true;
      break;
    }
    if (baseClass) {
      addedClasses.forEach(function(classname) {
        classList.remove(classname);
      });
    }
  }
  if (!isInViewport) {
    testPlacement = placementVals[0];
    addClassesToTarget(testPlacement);
    positionService.positionElements(hostElement, targetElement, testPlacement, appendToBody);
  }
  return testPlacement;
}

// node_modules/calendar-utils/calendar-utils.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var DAYS_OF_WEEK;
(function(DAYS_OF_WEEK2) {
  DAYS_OF_WEEK2[DAYS_OF_WEEK2["SUNDAY"] = 0] = "SUNDAY";
  DAYS_OF_WEEK2[DAYS_OF_WEEK2["MONDAY"] = 1] = "MONDAY";
  DAYS_OF_WEEK2[DAYS_OF_WEEK2["TUESDAY"] = 2] = "TUESDAY";
  DAYS_OF_WEEK2[DAYS_OF_WEEK2["WEDNESDAY"] = 3] = "WEDNESDAY";
  DAYS_OF_WEEK2[DAYS_OF_WEEK2["THURSDAY"] = 4] = "THURSDAY";
  DAYS_OF_WEEK2[DAYS_OF_WEEK2["FRIDAY"] = 5] = "FRIDAY";
  DAYS_OF_WEEK2[DAYS_OF_WEEK2["SATURDAY"] = 6] = "SATURDAY";
})(DAYS_OF_WEEK || (DAYS_OF_WEEK = {}));
var DEFAULT_WEEKEND_DAYS = [
  DAYS_OF_WEEK.SUNDAY,
  DAYS_OF_WEEK.SATURDAY
];
var DAYS_IN_WEEK = 7;
var HOURS_IN_DAY = 24;
var MINUTES_IN_HOUR = 60;
var SECONDS_IN_DAY = 60 * 60 * 24;
function getExcludedSeconds(dateAdapter, _a) {
  var startDate = _a.startDate, seconds = _a.seconds, excluded = _a.excluded, precision = _a.precision;
  if (excluded.length < 1) {
    return 0;
  }
  var addSeconds2 = dateAdapter.addSeconds, getDay2 = dateAdapter.getDay, addDays2 = dateAdapter.addDays;
  var endDate = addSeconds2(startDate, seconds - 1);
  var dayStart = getDay2(startDate);
  var dayEnd = getDay2(endDate);
  var result = 0;
  var current = startDate;
  var _loop_1 = function() {
    var day = getDay2(current);
    if (excluded.some(function(excludedDay) {
      return excludedDay === day;
    })) {
      result += calculateExcludedSeconds(dateAdapter, {
        dayStart,
        dayEnd,
        day,
        precision,
        startDate,
        endDate
      });
    }
    current = addDays2(current, 1);
  };
  while (current < endDate) {
    _loop_1();
  }
  return result;
}
function calculateExcludedSeconds(dateAdapter, _a) {
  var precision = _a.precision, day = _a.day, dayStart = _a.dayStart, dayEnd = _a.dayEnd, startDate = _a.startDate, endDate = _a.endDate;
  var differenceInSeconds2 = dateAdapter.differenceInSeconds, endOfDay2 = dateAdapter.endOfDay, startOfDay2 = dateAdapter.startOfDay;
  if (precision === "minutes") {
    if (day === dayStart) {
      return differenceInSeconds2(endOfDay2(startDate), startDate) + 1;
    } else if (day === dayEnd) {
      return differenceInSeconds2(endDate, startOfDay2(endDate)) + 1;
    }
  }
  return SECONDS_IN_DAY;
}
function getWeekViewEventSpan(dateAdapter, _a) {
  var event = _a.event, offset = _a.offset, startOfWeekDate = _a.startOfWeekDate, excluded = _a.excluded, precision = _a.precision, totalDaysInView = _a.totalDaysInView;
  var max2 = dateAdapter.max, differenceInSeconds2 = dateAdapter.differenceInSeconds, addDays2 = dateAdapter.addDays, endOfDay2 = dateAdapter.endOfDay, differenceInDays2 = dateAdapter.differenceInDays;
  var span = SECONDS_IN_DAY;
  var begin = max2([event.start, startOfWeekDate]);
  if (event.end) {
    switch (precision) {
      case "minutes":
        span = differenceInSeconds2(event.end, begin);
        break;
      default:
        span = differenceInDays2(addDays2(endOfDay2(event.end), 1), begin) * SECONDS_IN_DAY;
        break;
    }
  }
  var offsetSeconds = offset * SECONDS_IN_DAY;
  var totalLength = offsetSeconds + span;
  var secondsInView = totalDaysInView * SECONDS_IN_DAY;
  if (totalLength > secondsInView) {
    span = secondsInView - offsetSeconds;
  }
  span -= getExcludedSeconds(dateAdapter, {
    startDate: begin,
    seconds: span,
    excluded,
    precision
  });
  return span / SECONDS_IN_DAY;
}
function getWeekViewEventOffset(dateAdapter, _a) {
  var event = _a.event, startOfWeekDate = _a.startOfWeek, excluded = _a.excluded, precision = _a.precision;
  var differenceInDays2 = dateAdapter.differenceInDays, startOfDay2 = dateAdapter.startOfDay, differenceInSeconds2 = dateAdapter.differenceInSeconds;
  if (event.start < startOfWeekDate) {
    return 0;
  }
  var offset = 0;
  switch (precision) {
    case "days":
      offset = differenceInDays2(startOfDay2(event.start), startOfWeekDate) * SECONDS_IN_DAY;
      break;
    case "minutes":
      offset = differenceInSeconds2(event.start, startOfWeekDate);
      break;
  }
  offset -= getExcludedSeconds(dateAdapter, {
    startDate: startOfWeekDate,
    seconds: offset,
    excluded,
    precision
  });
  return Math.abs(offset / SECONDS_IN_DAY);
}
function isEventIsPeriod(dateAdapter, _a) {
  var event = _a.event, periodStart = _a.periodStart, periodEnd = _a.periodEnd;
  var isSameSecond2 = dateAdapter.isSameSecond;
  var eventStart = event.start;
  var eventEnd = event.end || event.start;
  if (eventStart > periodStart && eventStart < periodEnd) {
    return true;
  }
  if (eventEnd > periodStart && eventEnd < periodEnd) {
    return true;
  }
  if (eventStart < periodStart && eventEnd > periodEnd) {
    return true;
  }
  if (isSameSecond2(eventStart, periodStart) || isSameSecond2(eventStart, periodEnd)) {
    return true;
  }
  if (isSameSecond2(eventEnd, periodStart) || isSameSecond2(eventEnd, periodEnd)) {
    return true;
  }
  return false;
}
function getEventsInPeriod(dateAdapter, _a) {
  var events = _a.events, periodStart = _a.periodStart, periodEnd = _a.periodEnd;
  return events.filter(function(event) {
    return isEventIsPeriod(dateAdapter, { event, periodStart, periodEnd });
  });
}
function getWeekDay(dateAdapter, _a) {
  var date = _a.date, _b = _a.weekendDays, weekendDays = _b === void 0 ? DEFAULT_WEEKEND_DAYS : _b;
  var startOfDay2 = dateAdapter.startOfDay, isSameDay2 = dateAdapter.isSameDay, getDay2 = dateAdapter.getDay;
  var today = startOfDay2(/* @__PURE__ */ new Date());
  var day = getDay2(date);
  return {
    date,
    day,
    isPast: date < today,
    isToday: isSameDay2(date, today),
    isFuture: date > today,
    isWeekend: weekendDays.indexOf(day) > -1
  };
}
function getWeekViewHeader(dateAdapter, _a) {
  var viewDate = _a.viewDate, weekStartsOn = _a.weekStartsOn, _b = _a.excluded, excluded = _b === void 0 ? [] : _b, weekendDays = _a.weekendDays, _c = _a.viewStart, viewStart = _c === void 0 ? dateAdapter.startOfWeek(viewDate, { weekStartsOn }) : _c, _d = _a.viewEnd, viewEnd = _d === void 0 ? dateAdapter.addDays(viewStart, DAYS_IN_WEEK) : _d;
  var addDays2 = dateAdapter.addDays, getDay2 = dateAdapter.getDay;
  var days = [];
  var date = viewStart;
  while (date < viewEnd) {
    if (!excluded.some(function(e) {
      return getDay2(date) === e;
    })) {
      days.push(getWeekDay(dateAdapter, { date, weekendDays }));
    }
    date = addDays2(date, 1);
  }
  return days;
}
function getDifferenceInDaysWithExclusions(dateAdapter, _a) {
  var date1 = _a.date1, date2 = _a.date2, excluded = _a.excluded;
  var date = date1;
  var diff = 0;
  while (date < date2) {
    if (excluded.indexOf(dateAdapter.getDay(date)) === -1) {
      diff++;
    }
    date = dateAdapter.addDays(date, 1);
  }
  return diff;
}
function getAllDayWeekEvents(dateAdapter, _a) {
  var _b = _a.events, events = _b === void 0 ? [] : _b, _c = _a.excluded, excluded = _c === void 0 ? [] : _c, _d = _a.precision, precision = _d === void 0 ? "days" : _d, _e = _a.absolutePositionedEvents, absolutePositionedEvents = _e === void 0 ? false : _e, viewStart = _a.viewStart, viewEnd = _a.viewEnd;
  viewStart = dateAdapter.startOfDay(viewStart);
  viewEnd = dateAdapter.endOfDay(viewEnd);
  var differenceInSeconds2 = dateAdapter.differenceInSeconds, differenceInDays2 = dateAdapter.differenceInDays;
  var maxRange = getDifferenceInDaysWithExclusions(dateAdapter, {
    date1: viewStart,
    date2: viewEnd,
    excluded
  });
  var totalDaysInView = differenceInDays2(viewEnd, viewStart) + 1;
  var eventsMapped = events.filter(function(event) {
    return event.allDay;
  }).map(function(event) {
    var offset = getWeekViewEventOffset(dateAdapter, {
      event,
      startOfWeek: viewStart,
      excluded,
      precision
    });
    var span = getWeekViewEventSpan(dateAdapter, {
      event,
      offset,
      startOfWeekDate: viewStart,
      excluded,
      precision,
      totalDaysInView
    });
    return { event, offset, span };
  }).filter(function(e) {
    return e.offset < maxRange;
  }).filter(function(e) {
    return e.span > 0;
  }).map(function(entry) {
    return {
      event: entry.event,
      offset: entry.offset,
      span: entry.span,
      startsBeforeWeek: entry.event.start < viewStart,
      endsAfterWeek: (entry.event.end || entry.event.start) > viewEnd
    };
  }).sort(function(itemA, itemB) {
    var startSecondsDiff = differenceInSeconds2(itemA.event.start, itemB.event.start);
    if (startSecondsDiff === 0) {
      return differenceInSeconds2(itemB.event.end || itemB.event.start, itemA.event.end || itemA.event.start);
    }
    return startSecondsDiff;
  });
  var allDayEventRows = [];
  var allocatedEvents = [];
  eventsMapped.forEach(function(event, index) {
    if (allocatedEvents.indexOf(event) === -1) {
      allocatedEvents.push(event);
      var rowSpan_1 = event.span + event.offset;
      var otherRowEvents = eventsMapped.slice(index + 1).filter(function(nextEvent) {
        if (nextEvent.offset >= rowSpan_1 && rowSpan_1 + nextEvent.span <= totalDaysInView && allocatedEvents.indexOf(nextEvent) === -1) {
          var nextEventOffset = nextEvent.offset - rowSpan_1;
          if (!absolutePositionedEvents) {
            nextEvent.offset = nextEventOffset;
          }
          rowSpan_1 += nextEvent.span + nextEventOffset;
          allocatedEvents.push(nextEvent);
          return true;
        }
      });
      var weekEvents = __spreadArray([event], otherRowEvents, true);
      var id = weekEvents.filter(function(weekEvent) {
        return weekEvent.event.id;
      }).map(function(weekEvent) {
        return weekEvent.event.id;
      }).join("-");
      allDayEventRows.push(__assign({ row: weekEvents }, id ? { id } : {}));
    }
  });
  return allDayEventRows;
}
function getWeekViewHourGrid(dateAdapter, _a) {
  var events = _a.events, viewDate = _a.viewDate, hourSegments = _a.hourSegments, hourDuration = _a.hourDuration, dayStart = _a.dayStart, dayEnd = _a.dayEnd, weekStartsOn = _a.weekStartsOn, excluded = _a.excluded, weekendDays = _a.weekendDays, segmentHeight = _a.segmentHeight, viewStart = _a.viewStart, viewEnd = _a.viewEnd, minimumEventHeight = _a.minimumEventHeight;
  var dayViewHourGrid = getDayViewHourGrid(dateAdapter, {
    viewDate,
    hourSegments,
    hourDuration,
    dayStart,
    dayEnd
  });
  var weekDays = getWeekViewHeader(dateAdapter, {
    viewDate,
    weekStartsOn,
    excluded,
    weekendDays,
    viewStart,
    viewEnd
  });
  var setHours = dateAdapter.setHours, setMinutes = dateAdapter.setMinutes, getHours = dateAdapter.getHours, getMinutes = dateAdapter.getMinutes;
  return weekDays.map(function(day) {
    var dayView = getDayView(dateAdapter, {
      events,
      viewDate: day.date,
      hourSegments,
      dayStart,
      dayEnd,
      segmentHeight,
      eventWidth: 1,
      hourDuration,
      minimumEventHeight
    });
    var hours = dayViewHourGrid.map(function(hour) {
      var segments = hour.segments.map(function(segment) {
        var date = setMinutes(setHours(day.date, getHours(segment.date)), getMinutes(segment.date));
        return __assign(__assign({}, segment), { date });
      });
      return __assign(__assign({}, hour), { segments });
    });
    function getColumnCount(allEvents, prevOverlappingEvents) {
      var columnCount = Math.max.apply(Math, prevOverlappingEvents.map(function(iEvent) {
        return iEvent.left + 1;
      }));
      var nextOverlappingEvents = allEvents.filter(function(iEvent) {
        return iEvent.left >= columnCount;
      }).filter(function(iEvent) {
        return getOverLappingWeekViewEvents(prevOverlappingEvents, iEvent.top, iEvent.top + iEvent.height).length > 0;
      });
      if (nextOverlappingEvents.length > 0) {
        return getColumnCount(allEvents, nextOverlappingEvents);
      } else {
        return columnCount;
      }
    }
    var mappedEvents = dayView.events.map(function(event) {
      var columnCount = getColumnCount(dayView.events, getOverLappingWeekViewEvents(dayView.events, event.top, event.top + event.height));
      var width = 100 / columnCount;
      return __assign(__assign({}, event), { left: event.left * width, width });
    });
    return {
      hours,
      date: day.date,
      events: mappedEvents.map(function(event) {
        var overLappingEvents = getOverLappingWeekViewEvents(mappedEvents.filter(function(otherEvent) {
          return otherEvent.left > event.left;
        }), event.top, event.top + event.height);
        if (overLappingEvents.length > 0) {
          return __assign(__assign({}, event), { width: Math.min.apply(Math, overLappingEvents.map(function(otherEvent) {
            return otherEvent.left;
          })) - event.left });
        }
        return event;
      })
    };
  });
}
function getWeekView(dateAdapter, _a) {
  var _b = _a.events, events = _b === void 0 ? [] : _b, viewDate = _a.viewDate, weekStartsOn = _a.weekStartsOn, _c = _a.excluded, excluded = _c === void 0 ? [] : _c, _d = _a.precision, precision = _d === void 0 ? "days" : _d, _e = _a.absolutePositionedEvents, absolutePositionedEvents = _e === void 0 ? false : _e, hourSegments = _a.hourSegments, hourDuration = _a.hourDuration, dayStart = _a.dayStart, dayEnd = _a.dayEnd, weekendDays = _a.weekendDays, segmentHeight = _a.segmentHeight, minimumEventHeight = _a.minimumEventHeight, _f = _a.viewStart, viewStart = _f === void 0 ? dateAdapter.startOfWeek(viewDate, { weekStartsOn }) : _f, _g = _a.viewEnd, viewEnd = _g === void 0 ? dateAdapter.endOfWeek(viewDate, { weekStartsOn }) : _g;
  if (!events) {
    events = [];
  }
  var startOfDay2 = dateAdapter.startOfDay, endOfDay2 = dateAdapter.endOfDay;
  viewStart = startOfDay2(viewStart);
  viewEnd = endOfDay2(viewEnd);
  var eventsInPeriod = getEventsInPeriod(dateAdapter, {
    events,
    periodStart: viewStart,
    periodEnd: viewEnd
  });
  var header = getWeekViewHeader(dateAdapter, {
    viewDate,
    weekStartsOn,
    excluded,
    weekendDays,
    viewStart,
    viewEnd
  });
  return {
    allDayEventRows: getAllDayWeekEvents(dateAdapter, {
      events: eventsInPeriod,
      excluded,
      precision,
      absolutePositionedEvents,
      viewStart,
      viewEnd
    }),
    period: {
      events: eventsInPeriod,
      start: header[0].date,
      end: endOfDay2(header[header.length - 1].date)
    },
    hourColumns: getWeekViewHourGrid(dateAdapter, {
      events,
      viewDate,
      hourSegments,
      hourDuration,
      dayStart,
      dayEnd,
      weekStartsOn,
      excluded,
      weekendDays,
      segmentHeight,
      viewStart,
      viewEnd,
      minimumEventHeight
    })
  };
}
function getMonthView(dateAdapter, _a) {
  var _b = _a.events, events = _b === void 0 ? [] : _b, viewDate = _a.viewDate, weekStartsOn = _a.weekStartsOn, _c = _a.excluded, excluded = _c === void 0 ? [] : _c, _d = _a.viewStart, viewStart = _d === void 0 ? dateAdapter.startOfMonth(viewDate) : _d, _e = _a.viewEnd, viewEnd = _e === void 0 ? dateAdapter.endOfMonth(viewDate) : _e, weekendDays = _a.weekendDays;
  if (!events) {
    events = [];
  }
  var startOfWeek2 = dateAdapter.startOfWeek, endOfWeek2 = dateAdapter.endOfWeek, differenceInDays2 = dateAdapter.differenceInDays, startOfDay2 = dateAdapter.startOfDay, addHours2 = dateAdapter.addHours, endOfDay2 = dateAdapter.endOfDay, isSameMonth2 = dateAdapter.isSameMonth, getDay2 = dateAdapter.getDay;
  var start = startOfWeek2(viewStart, { weekStartsOn });
  var end = endOfWeek2(viewEnd, { weekStartsOn });
  var eventsInMonth = getEventsInPeriod(dateAdapter, {
    events,
    periodStart: start,
    periodEnd: end
  });
  var initialViewDays = [];
  var previousDate;
  var _loop_2 = function(i2) {
    var date;
    if (previousDate) {
      date = startOfDay2(addHours2(previousDate, HOURS_IN_DAY));
      if (previousDate.getTime() === date.getTime()) {
        date = startOfDay2(addHours2(previousDate, HOURS_IN_DAY + 1));
      }
      previousDate = date;
    } else {
      date = previousDate = start;
    }
    if (!excluded.some(function(e) {
      return getDay2(date) === e;
    })) {
      var day = getWeekDay(dateAdapter, {
        date,
        weekendDays
      });
      var eventsInPeriod = getEventsInPeriod(dateAdapter, {
        events: eventsInMonth,
        periodStart: startOfDay2(date),
        periodEnd: endOfDay2(date)
      });
      day.inMonth = isSameMonth2(date, viewDate);
      day.events = eventsInPeriod;
      day.badgeTotal = eventsInPeriod.length;
      initialViewDays.push(day);
    }
  };
  for (var i = 0; i < differenceInDays2(end, start) + 1; i++) {
    _loop_2(i);
  }
  var days = [];
  var totalDaysVisibleInWeek = DAYS_IN_WEEK - excluded.length;
  if (totalDaysVisibleInWeek < DAYS_IN_WEEK) {
    for (var i = 0; i < initialViewDays.length; i += totalDaysVisibleInWeek) {
      var row = initialViewDays.slice(i, i + totalDaysVisibleInWeek);
      var isRowInMonth = row.some(function(day) {
        return viewStart <= day.date && day.date < viewEnd;
      });
      if (isRowInMonth) {
        days = __spreadArray(__spreadArray([], days, true), row, true);
      }
    }
  } else {
    days = initialViewDays;
  }
  var rows = Math.floor(days.length / totalDaysVisibleInWeek);
  var rowOffsets = [];
  for (var i = 0; i < rows; i++) {
    rowOffsets.push(i * totalDaysVisibleInWeek);
  }
  return {
    rowOffsets,
    totalDaysVisibleInWeek,
    days,
    period: {
      start: days[0].date,
      end: endOfDay2(days[days.length - 1].date),
      events: eventsInMonth
    }
  };
}
function getOverLappingWeekViewEvents(events, top, bottom) {
  return events.filter(function(previousEvent) {
    var previousEventTop = previousEvent.top;
    var previousEventBottom = previousEvent.top + previousEvent.height;
    if (top < previousEventBottom && previousEventBottom < bottom) {
      return true;
    } else if (top < previousEventTop && previousEventTop < bottom) {
      return true;
    } else if (previousEventTop <= top && bottom <= previousEventBottom) {
      return true;
    }
    return false;
  });
}
function getDayView(dateAdapter, _a) {
  var events = _a.events, viewDate = _a.viewDate, hourSegments = _a.hourSegments, dayStart = _a.dayStart, dayEnd = _a.dayEnd, eventWidth = _a.eventWidth, segmentHeight = _a.segmentHeight, hourDuration = _a.hourDuration, minimumEventHeight = _a.minimumEventHeight;
  var setMinutes = dateAdapter.setMinutes, setHours = dateAdapter.setHours, startOfDay2 = dateAdapter.startOfDay, startOfMinute2 = dateAdapter.startOfMinute, endOfDay2 = dateAdapter.endOfDay, differenceInMinutes2 = dateAdapter.differenceInMinutes;
  var startOfView = setMinutes(setHours(startOfDay2(viewDate), sanitiseHours(dayStart.hour)), sanitiseMinutes(dayStart.minute));
  var endOfView = setMinutes(setHours(startOfMinute2(endOfDay2(viewDate)), sanitiseHours(dayEnd.hour)), sanitiseMinutes(dayEnd.minute));
  endOfView.setSeconds(59, 999);
  var previousDayEvents = [];
  var eventsInPeriod = getEventsInPeriod(dateAdapter, {
    events: events.filter(function(event) {
      return !event.allDay;
    }),
    periodStart: startOfView,
    periodEnd: endOfView
  });
  var dayViewEvents = eventsInPeriod.sort(function(eventA, eventB) {
    return eventA.start.valueOf() - eventB.start.valueOf();
  }).map(function(event) {
    var eventStart = event.start;
    var eventEnd = event.end || eventStart;
    var startsBeforeDay = eventStart < startOfView;
    var endsAfterDay = eventEnd > endOfView;
    var hourHeightModifier = hourSegments * segmentHeight / (hourDuration || MINUTES_IN_HOUR);
    var top = 0;
    if (eventStart > startOfView) {
      var eventOffset = dateAdapter.getTimezoneOffset(eventStart);
      var startOffset = dateAdapter.getTimezoneOffset(startOfView);
      var diff = startOffset - eventOffset;
      top += differenceInMinutes2(eventStart, startOfView) + diff;
    }
    top *= hourHeightModifier;
    top = Math.floor(top);
    var startDate = startsBeforeDay ? startOfView : eventStart;
    var endDate = endsAfterDay ? endOfView : eventEnd;
    var timezoneOffset = dateAdapter.getTimezoneOffset(startDate) - dateAdapter.getTimezoneOffset(endDate);
    var height = differenceInMinutes2(endDate, startDate) + timezoneOffset;
    if (!event.end) {
      height = segmentHeight;
    } else {
      height *= hourHeightModifier;
    }
    if (minimumEventHeight && height < minimumEventHeight) {
      height = minimumEventHeight;
    }
    height = Math.floor(height);
    var bottom = top + height;
    var overlappingPreviousEvents = getOverLappingWeekViewEvents(previousDayEvents, top, bottom);
    var left = 0;
    while (overlappingPreviousEvents.some(function(previousEvent) {
      return previousEvent.left === left;
    })) {
      left += eventWidth;
    }
    var dayEvent = {
      event,
      height,
      width: eventWidth,
      top,
      left,
      startsBeforeDay,
      endsAfterDay
    };
    previousDayEvents.push(dayEvent);
    return dayEvent;
  });
  var width = Math.max.apply(Math, dayViewEvents.map(function(event) {
    return event.left + event.width;
  }));
  var allDayEvents = getEventsInPeriod(dateAdapter, {
    events: events.filter(function(event) {
      return event.allDay;
    }),
    periodStart: startOfDay2(startOfView),
    periodEnd: endOfDay2(endOfView)
  });
  return {
    events: dayViewEvents,
    width,
    allDayEvents,
    period: {
      events: eventsInPeriod,
      start: startOfView,
      end: endOfView
    }
  };
}
function sanitiseHours(hours) {
  return Math.max(Math.min(23, hours), 0);
}
function sanitiseMinutes(minutes) {
  return Math.max(Math.min(59, minutes), 0);
}
function getDayViewHourGrid(dateAdapter, _a) {
  var viewDate = _a.viewDate, hourSegments = _a.hourSegments, hourDuration = _a.hourDuration, dayStart = _a.dayStart, dayEnd = _a.dayEnd;
  var setMinutes = dateAdapter.setMinutes, setHours = dateAdapter.setHours, startOfDay2 = dateAdapter.startOfDay, startOfMinute2 = dateAdapter.startOfMinute, endOfDay2 = dateAdapter.endOfDay, addMinutes2 = dateAdapter.addMinutes, addDays2 = dateAdapter.addDays;
  var hours = [];
  var startOfView = setMinutes(setHours(startOfDay2(viewDate), sanitiseHours(dayStart.hour)), sanitiseMinutes(dayStart.minute));
  var endOfView = setMinutes(setHours(startOfMinute2(endOfDay2(viewDate)), sanitiseHours(dayEnd.hour)), sanitiseMinutes(dayEnd.minute));
  var segmentDuration = (hourDuration || MINUTES_IN_HOUR) / hourSegments;
  var startOfViewDay = startOfDay2(viewDate);
  var endOfViewDay = endOfDay2(viewDate);
  var dateAdjustment = function(d) {
    return d;
  };
  if (dateAdapter.getTimezoneOffset(startOfViewDay) !== dateAdapter.getTimezoneOffset(endOfViewDay)) {
    startOfViewDay = addDays2(startOfViewDay, 1);
    startOfView = addDays2(startOfView, 1);
    endOfView = addDays2(endOfView, 1);
    dateAdjustment = function(d) {
      return addDays2(d, -1);
    };
  }
  var dayDuration = hourDuration ? HOURS_IN_DAY * 60 / hourDuration : MINUTES_IN_HOUR;
  for (var i = 0; i < dayDuration; i++) {
    var segments = [];
    for (var j = 0; j < hourSegments; j++) {
      var date = addMinutes2(addMinutes2(startOfView, i * (hourDuration || MINUTES_IN_HOUR)), j * segmentDuration);
      if (date >= startOfView && date < endOfView) {
        segments.push({
          date: dateAdjustment(date),
          displayDate: date,
          isStart: j === 0
        });
      }
    }
    if (segments.length > 0) {
      hours.push({ segments });
    }
  }
  return hours;
}
var EventValidationErrorMessage;
(function(EventValidationErrorMessage2) {
  EventValidationErrorMessage2["NotArray"] = "Events must be an array";
  EventValidationErrorMessage2["StartPropertyMissing"] = "Event is missing the `start` property";
  EventValidationErrorMessage2["StartPropertyNotDate"] = "Event `start` property should be a javascript date object. Do `new Date(event.start)` to fix it.";
  EventValidationErrorMessage2["EndPropertyNotDate"] = "Event `end` property should be a javascript date object. Do `new Date(event.end)` to fix it.";
  EventValidationErrorMessage2["EndsBeforeStart"] = "Event `start` property occurs after the `end`";
})(EventValidationErrorMessage || (EventValidationErrorMessage = {}));
function validateEvents(events, log) {
  var isValid2 = true;
  function isError(msg, event) {
    log(msg, event);
    isValid2 = false;
  }
  if (!Array.isArray(events)) {
    log(EventValidationErrorMessage.NotArray, events);
    return false;
  }
  events.forEach(function(event) {
    if (!event.start) {
      isError(EventValidationErrorMessage.StartPropertyMissing, event);
    } else if (!(event.start instanceof Date)) {
      isError(EventValidationErrorMessage.StartPropertyNotDate, event);
    }
    if (event.end) {
      if (!(event.end instanceof Date)) {
        isError(EventValidationErrorMessage.EndPropertyNotDate, event);
      }
      if (event.start > event.end) {
        isError(EventValidationErrorMessage.EndsBeforeStart, event);
      }
    }
  });
  return isValid2;
}

// node_modules/@mattlewis92/dom-autoscroller/dist/bundle.es.js
function getDef(f, d) {
  if (typeof f === "undefined") {
    return typeof d === "undefined" ? f : d;
  }
  return f;
}
function boolean(func, def) {
  func = getDef(func, def);
  if (typeof func === "function") {
    return function f() {
      var arguments$1 = arguments;
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments$1[_key];
      }
      return !!func.apply(this, args);
    };
  }
  return !!func ? function() {
    return true;
  } : function() {
    return false;
  };
}
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
  return typeof obj;
} : function(obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
};
var isElement$1 = function(input) {
  return input != null && (typeof input === "undefined" ? "undefined" : _typeof(input)) === "object" && input.nodeType === 1 && _typeof(input.style) === "object" && _typeof(input.ownerDocument) === "object";
};
function indexOfElement(elements, element) {
  element = resolveElement(element, true);
  if (!isElement$1(element)) {
    return -1;
  }
  for (var i = 0; i < elements.length; i++) {
    if (elements[i] === element) {
      return i;
    }
  }
  return -1;
}
function hasElement(elements, element) {
  return -1 !== indexOfElement(elements, element);
}
function pushElements(elements, toAdd) {
  for (var i = 0; i < toAdd.length; i++) {
    if (!hasElement(elements, toAdd[i])) {
      elements.push(toAdd[i]);
    }
  }
  return toAdd;
}
function addElements(elements) {
  var arguments$1 = arguments;
  var toAdd = [], len = arguments.length - 1;
  while (len-- > 0) {
    toAdd[len] = arguments$1[len + 1];
  }
  toAdd = toAdd.map(resolveElement);
  return pushElements(elements, toAdd);
}
function removeElements(elements) {
  var arguments$1 = arguments;
  var toRemove = [], len = arguments.length - 1;
  while (len-- > 0) {
    toRemove[len] = arguments$1[len + 1];
  }
  return toRemove.map(resolveElement).reduce(function(last, e) {
    var index = indexOfElement(elements, e);
    if (index !== -1) {
      return last.concat(elements.splice(index, 1));
    }
    return last;
  }, []);
}
function resolveElement(element, noThrow) {
  if (typeof element === "string") {
    try {
      return document.querySelector(element);
    } catch (e) {
      throw e;
    }
  }
  if (!isElement$1(element) && !noThrow) {
    throw new TypeError(element + " is not a DOM element.");
  }
  return element;
}
function createPointCB(object, options) {
  options = options || {};
  var allowUpdate = boolean(options.allowUpdate, true);
  return function pointCB(event) {
    event = event || window.event;
    object.target = event.target || event.srcElement || event.originalTarget;
    object.element = this;
    object.type = event.type;
    if (!allowUpdate(event)) {
      return;
    }
    if (event.targetTouches) {
      object.x = event.targetTouches[0].clientX;
      object.y = event.targetTouches[0].clientY;
      object.pageX = event.targetTouches[0].pageX;
      object.pageY = event.targetTouches[0].pageY;
      object.screenX = event.targetTouches[0].screenX;
      object.screenY = event.targetTouches[0].screenY;
    } else {
      if (event.pageX === null && event.clientX !== null) {
        var eventDoc = event.target && event.target.ownerDocument || document;
        var doc = eventDoc.documentElement;
        var body = eventDoc.body;
        object.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
        object.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
      } else {
        object.pageX = event.pageX;
        object.pageY = event.pageY;
      }
      object.x = event.clientX;
      object.y = event.clientY;
      object.screenX = event.screenX;
      object.screenY = event.screenY;
    }
    object.clientX = object.x;
    object.clientY = object.y;
  };
}
function createWindowRect() {
  var props = {
    top: { value: 0, enumerable: true },
    left: { value: 0, enumerable: true },
    right: { value: window.innerWidth, enumerable: true },
    bottom: { value: window.innerHeight, enumerable: true },
    width: { value: window.innerWidth, enumerable: true },
    height: { value: window.innerHeight, enumerable: true },
    x: { value: 0, enumerable: true },
    y: { value: 0, enumerable: true }
  };
  if (Object.create) {
    return Object.create({}, props);
  } else {
    var rect = {};
    Object.defineProperties(rect, props);
    return rect;
  }
}
function getClientRect(el) {
  if (el === window) {
    return createWindowRect();
  } else {
    try {
      var rect = el.getBoundingClientRect();
      if (rect.x === void 0) {
        rect.x = rect.left;
        rect.y = rect.top;
      }
      return rect;
    } catch (e) {
      throw new TypeError("Can't call getBoundingClientRect on " + el);
    }
  }
}
function pointInside(point, el) {
  var rect = getClientRect(el);
  return point.y > rect.top && point.y < rect.bottom && point.x > rect.left && point.x < rect.right;
}
var objectCreate = void 0;
if (typeof Object.create != "function") {
  objectCreate = /* @__PURE__ */ function(undefined$1) {
    var Temp = function Temp2() {
    };
    return function(prototype, propertiesObject) {
      if (prototype !== Object(prototype) && prototype !== null) {
        throw TypeError("Argument must be an object, or null");
      }
      Temp.prototype = prototype || {};
      var result = new Temp();
      Temp.prototype = null;
      if (propertiesObject !== undefined$1) {
        Object.defineProperties(result, propertiesObject);
      }
      if (prototype === null) {
        result.__proto__ = null;
      }
      return result;
    };
  }();
} else {
  objectCreate = Object.create;
}
var objectCreate$1 = objectCreate;
var mouseEventProps = ["altKey", "button", "buttons", "clientX", "clientY", "ctrlKey", "metaKey", "movementX", "movementY", "offsetX", "offsetY", "pageX", "pageY", "region", "relatedTarget", "screenX", "screenY", "shiftKey", "which", "x", "y"];
function createDispatcher(element) {
  var defaultSettings = {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    ctrlKey: false,
    shiftKey: false,
    altKey: false,
    metaKey: false,
    button: 0,
    buttons: 1,
    relatedTarget: null,
    region: null
  };
  if (element !== void 0) {
    element.addEventListener("mousemove", onMove);
  }
  function onMove(e) {
    for (var i = 0; i < mouseEventProps.length; i++) {
      defaultSettings[mouseEventProps[i]] = e[mouseEventProps[i]];
    }
  }
  var dispatch = function() {
    if (MouseEvent) {
      return function m1(element2, initMove, data) {
        var evt = new MouseEvent("mousemove", createMoveInit(defaultSettings, initMove));
        setSpecial(evt, data);
        return element2.dispatchEvent(evt);
      };
    } else if (typeof document.createEvent === "function") {
      return function m2(element2, initMove, data) {
        var settings = createMoveInit(defaultSettings, initMove);
        var evt = document.createEvent("MouseEvents");
        evt.initMouseEvent(
          "mousemove",
          true,
          //can bubble
          true,
          //cancelable
          window,
          //view
          0,
          //detail
          settings.screenX,
          //0, //screenX
          settings.screenY,
          //0, //screenY
          settings.clientX,
          //80, //clientX
          settings.clientY,
          //20, //clientY
          settings.ctrlKey,
          //false, //ctrlKey
          settings.altKey,
          //false, //altKey
          settings.shiftKey,
          //false, //shiftKey
          settings.metaKey,
          //false, //metaKey
          settings.button,
          //0, //button
          settings.relatedTarget
          //null //relatedTarget
        );
        setSpecial(evt, data);
        return element2.dispatchEvent(evt);
      };
    } else if (typeof document.createEventObject === "function") {
      return function m3(element2, initMove, data) {
        var evt = document.createEventObject();
        var settings = createMoveInit(defaultSettings, initMove);
        for (var name in settings) {
          evt[name] = settings[name];
        }
        setSpecial(evt, data);
        return element2.dispatchEvent(evt);
      };
    }
  }();
  function destroy() {
    if (element) {
      element.removeEventListener("mousemove", onMove, false);
    }
    defaultSettings = null;
  }
  return {
    destroy,
    dispatch
  };
}
function createMoveInit(defaultSettings, initMove) {
  initMove = initMove || {};
  var settings = objectCreate$1(defaultSettings);
  for (var i = 0; i < mouseEventProps.length; i++) {
    if (initMove[mouseEventProps[i]] !== void 0) {
      settings[mouseEventProps[i]] = initMove[mouseEventProps[i]];
    }
  }
  return settings;
}
function setSpecial(e, data) {
  console.log("data ", data);
  e.data = data || {};
  e.dispatched = "mousemove";
}
var prefix = ["webkit", "moz", "ms", "o"];
var requestFrame = function() {
  if (typeof window === "undefined") {
    return function() {
    };
  }
  for (var i = 0, limit = prefix.length; i < limit && !window.requestAnimationFrame; ++i) {
    window.requestAnimationFrame = window[prefix[i] + "RequestAnimationFrame"];
  }
  if (!window.requestAnimationFrame) {
    var lastTime = 0;
    window.requestAnimationFrame = function(callback) {
      var now = (/* @__PURE__ */ new Date()).getTime();
      var ttc = Math.max(0, 16 - now - lastTime);
      var timer2 = window.setTimeout(function() {
        return callback(now + ttc);
      }, ttc);
      lastTime = now + ttc;
      return timer2;
    };
  }
  return window.requestAnimationFrame.bind(window);
}();
var cancelFrame = function() {
  if (typeof window === "undefined") {
    return function() {
    };
  }
  for (var i = 0, limit = prefix.length; i < limit && !window.cancelAnimationFrame; ++i) {
    window.cancelAnimationFrame = window[prefix[i] + "CancelAnimationFrame"] || window[prefix[i] + "CancelRequestAnimationFrame"];
  }
  if (!window.cancelAnimationFrame) {
    window.cancelAnimationFrame = function(timer2) {
      window.clearTimeout(timer2);
    };
  }
  return window.cancelAnimationFrame.bind(window);
}();
function AutoScroller(elements, options) {
  if (options === void 0) options = {};
  var self = this;
  var maxSpeed = 4, scrolling = false;
  if (typeof options.margin !== "object") {
    var margin = options.margin || -1;
    this.margin = {
      left: margin,
      right: margin,
      top: margin,
      bottom: margin
    };
  } else {
    this.margin = options.margin;
  }
  this.scrollWhenOutside = options.scrollWhenOutside || false;
  var point = {}, pointCB = createPointCB(point), dispatcher = createDispatcher(), down = false;
  window.addEventListener("mousemove", pointCB, false);
  window.addEventListener("touchmove", pointCB, false);
  if (!isNaN(options.maxSpeed)) {
    maxSpeed = options.maxSpeed;
  }
  if (typeof maxSpeed !== "object") {
    maxSpeed = {
      left: maxSpeed,
      right: maxSpeed,
      top: maxSpeed,
      bottom: maxSpeed
    };
  }
  this.autoScroll = boolean(options.autoScroll);
  this.syncMove = boolean(options.syncMove, false);
  this.destroy = function(forceCleanAnimation) {
    window.removeEventListener("mousemove", pointCB, false);
    window.removeEventListener("touchmove", pointCB, false);
    window.removeEventListener("mousedown", onDown, false);
    window.removeEventListener("touchstart", onDown, false);
    window.removeEventListener("mouseup", onUp, false);
    window.removeEventListener("touchend", onUp, false);
    window.removeEventListener("pointerup", onUp, false);
    window.removeEventListener("mouseleave", onMouseOut, false);
    window.removeEventListener("mousemove", onMove, false);
    window.removeEventListener("touchmove", onMove, false);
    window.removeEventListener("scroll", setScroll, true);
    elements = [];
    if (forceCleanAnimation) {
      cleanAnimation();
    }
  };
  this.add = function() {
    var element = [], len = arguments.length;
    while (len--) element[len] = arguments[len];
    addElements.apply(void 0, [elements].concat(element));
    return this;
  };
  this.remove = function() {
    var element = [], len = arguments.length;
    while (len--) element[len] = arguments[len];
    return removeElements.apply(void 0, [elements].concat(element));
  };
  var hasWindow = null, windowAnimationFrame;
  if (Object.prototype.toString.call(elements) !== "[object Array]") {
    elements = [elements];
  }
  (function(temp) {
    elements = [];
    temp.forEach(function(element) {
      if (element === window) {
        hasWindow = window;
      } else {
        self.add(element);
      }
    });
  })(elements);
  Object.defineProperties(this, {
    down: {
      get: function() {
        return down;
      }
    },
    maxSpeed: {
      get: function() {
        return maxSpeed;
      }
    },
    point: {
      get: function() {
        return point;
      }
    },
    scrolling: {
      get: function() {
        return scrolling;
      }
    }
  });
  var current = null, animationFrame;
  window.addEventListener("mousedown", onDown, false);
  window.addEventListener("touchstart", onDown, false);
  window.addEventListener("mouseup", onUp, false);
  window.addEventListener("touchend", onUp, false);
  window.addEventListener("pointerup", onUp, false);
  window.addEventListener("mousemove", onMove, false);
  window.addEventListener("touchmove", onMove, false);
  window.addEventListener("mouseleave", onMouseOut, false);
  window.addEventListener("scroll", setScroll, true);
  function setScroll(e) {
    for (var i = 0; i < elements.length; i++) {
      if (elements[i] === e.target) {
        scrolling = true;
        break;
      }
    }
    if (scrolling) {
      requestFrame(function() {
        return scrolling = false;
      });
    }
  }
  function onDown() {
    down = true;
  }
  function onUp() {
    down = false;
    cleanAnimation();
  }
  function cleanAnimation() {
    cancelFrame(animationFrame);
    cancelFrame(windowAnimationFrame);
  }
  function onMouseOut() {
    down = false;
  }
  function getTarget(target) {
    if (!target) {
      return null;
    }
    if (current === target) {
      return target;
    }
    if (hasElement(elements, target)) {
      return target;
    }
    while (target = target.parentNode) {
      if (hasElement(elements, target)) {
        return target;
      }
    }
    return null;
  }
  function getElementUnderPoint() {
    var underPoint = null;
    for (var i = 0; i < elements.length; i++) {
      if (inside(point, elements[i])) {
        underPoint = elements[i];
      }
    }
    return underPoint;
  }
  function onMove(event) {
    if (!self.autoScroll()) {
      return;
    }
    if (event["dispatched"]) {
      return;
    }
    var target = event.target, body = document.body;
    if (current && !inside(point, current)) {
      if (!self.scrollWhenOutside) {
        current = null;
      }
    }
    if (target && target.parentNode === body) {
      target = getElementUnderPoint();
    } else {
      target = getTarget(target);
      if (!target) {
        target = getElementUnderPoint();
      }
    }
    if (target && target !== current) {
      current = target;
    }
    if (hasWindow) {
      cancelFrame(windowAnimationFrame);
      windowAnimationFrame = requestFrame(scrollWindow);
    }
    if (!current) {
      return;
    }
    cancelFrame(animationFrame);
    animationFrame = requestFrame(scrollTick);
  }
  function scrollWindow() {
    autoScroll(hasWindow);
    cancelFrame(windowAnimationFrame);
    windowAnimationFrame = requestFrame(scrollWindow);
  }
  function scrollTick() {
    if (!current) {
      return;
    }
    autoScroll(current);
    cancelFrame(animationFrame);
    animationFrame = requestFrame(scrollTick);
  }
  function autoScroll(el) {
    var rect = getClientRect(el), scrollx, scrolly;
    if (point.x < rect.left + self.margin.left) {
      scrollx = Math.floor(
        Math.max(-1, (point.x - rect.left) / self.margin.left - 1) * self.maxSpeed.left
      );
    } else if (point.x > rect.right - self.margin.right) {
      scrollx = Math.ceil(
        Math.min(1, (point.x - rect.right) / self.margin.right + 1) * self.maxSpeed.right
      );
    } else {
      scrollx = 0;
    }
    if (point.y < rect.top + self.margin.top) {
      scrolly = Math.floor(
        Math.max(-1, (point.y - rect.top) / self.margin.top - 1) * self.maxSpeed.top
      );
    } else if (point.y > rect.bottom - self.margin.bottom) {
      scrolly = Math.ceil(
        Math.min(1, (point.y - rect.bottom) / self.margin.bottom + 1) * self.maxSpeed.bottom
      );
    } else {
      scrolly = 0;
    }
    if (self.syncMove()) {
      dispatcher.dispatch(el, {
        pageX: point.pageX + scrollx,
        pageY: point.pageY + scrolly,
        clientX: point.x + scrollx,
        clientY: point.y + scrolly
      });
    }
    setTimeout(function() {
      if (scrolly) {
        scrollY(el, scrolly);
      }
      if (scrollx) {
        scrollX(el, scrollx);
      }
    });
  }
  function scrollY(el, amount) {
    if (el === window) {
      window.scrollTo(el.pageXOffset, el.pageYOffset + amount);
    } else {
      el.scrollTop += amount;
    }
  }
  function scrollX(el, amount) {
    if (el === window) {
      window.scrollTo(el.pageXOffset + amount, el.pageYOffset);
    } else {
      el.scrollLeft += amount;
    }
  }
}
function AutoScrollerFactory(element, options) {
  return new AutoScroller(element, options);
}
function inside(point, el, rect) {
  if (!rect) {
    return pointInside(point, el);
  } else {
    return point.y > rect.top && point.y < rect.bottom && point.x > rect.left && point.x < rect.right;
  }
}
var bundle_es_default = AutoScrollerFactory;

// node_modules/angular-draggable-droppable/fesm2020/angular-draggable-droppable.mjs
function addClass(renderer, element, classToAdd) {
  if (classToAdd) {
    classToAdd.split(" ").forEach((className) => renderer.addClass(element.nativeElement, className));
  }
}
function removeClass(renderer, element, classToRemove) {
  if (classToRemove) {
    classToRemove.split(" ").forEach((className) => renderer.removeClass(element.nativeElement, className));
  }
}
var DraggableHelper = class {
  constructor() {
    this.currentDrag = new Subject();
  }
};
DraggableHelper.ɵfac = function DraggableHelper_Factory(t) {
  return new (t || DraggableHelper)();
};
DraggableHelper.ɵprov = ɵɵdefineInjectable({
  token: DraggableHelper,
  factory: DraggableHelper.ɵfac,
  providedIn: "root"
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DraggableHelper, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var DraggableScrollContainerDirective = class {
  /**
   * @hidden
   */
  constructor(elementRef) {
    this.elementRef = elementRef;
  }
};
DraggableScrollContainerDirective.ɵfac = function DraggableScrollContainerDirective_Factory(t) {
  return new (t || DraggableScrollContainerDirective)(ɵɵdirectiveInject(ElementRef));
};
DraggableScrollContainerDirective.ɵdir = ɵɵdefineDirective({
  type: DraggableScrollContainerDirective,
  selectors: [["", "mwlDraggableScrollContainer", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DraggableScrollContainerDirective, [{
    type: Directive,
    args: [{
      selector: "[mwlDraggableScrollContainer]"
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, null);
})();
var DraggableDirective = class {
  /**
   * @hidden
   */
  constructor(element, renderer, draggableHelper, zone, vcr, scrollContainer, document2) {
    this.element = element;
    this.renderer = renderer;
    this.draggableHelper = draggableHelper;
    this.zone = zone;
    this.vcr = vcr;
    this.scrollContainer = scrollContainer;
    this.document = document2;
    this.dragAxis = {
      x: true,
      y: true
    };
    this.dragSnapGrid = {};
    this.ghostDragEnabled = true;
    this.showOriginalElementWhileDragging = false;
    this.dragCursor = "";
    this.autoScroll = {
      margin: 20
    };
    this.dragPointerDown = new EventEmitter();
    this.dragStart = new EventEmitter();
    this.ghostElementCreated = new EventEmitter();
    this.dragging = new EventEmitter();
    this.dragEnd = new EventEmitter();
    this.pointerDown$ = new Subject();
    this.pointerMove$ = new Subject();
    this.pointerUp$ = new Subject();
    this.eventListenerSubscriptions = {};
    this.destroy$ = new Subject();
    this.timeLongPress = {
      timerBegin: 0,
      timerEnd: 0
    };
  }
  ngOnInit() {
    this.checkEventListeners();
    const pointerDragged$ = this.pointerDown$.pipe(filter(() => this.canDrag()), mergeMap((pointerDownEvent) => {
      if (pointerDownEvent.event.stopPropagation && !this.scrollContainer) {
        pointerDownEvent.event.stopPropagation();
      }
      const globalDragStyle = this.renderer.createElement("style");
      this.renderer.setAttribute(globalDragStyle, "type", "text/css");
      this.renderer.appendChild(globalDragStyle, this.renderer.createText(`
          body * {
           -moz-user-select: none;
           -ms-user-select: none;
           -webkit-user-select: none;
           user-select: none;
          }
        `));
      requestAnimationFrame(() => {
        this.document.head.appendChild(globalDragStyle);
      });
      const startScrollPosition = this.getScrollPosition();
      const scrollContainerScroll$ = new Observable((observer) => {
        const scrollContainer = this.scrollContainer ? this.scrollContainer.elementRef.nativeElement : "window";
        return this.renderer.listen(scrollContainer, "scroll", (e) => observer.next(e));
      }).pipe(startWith(startScrollPosition), map(() => this.getScrollPosition()));
      const currentDrag$ = new Subject();
      const cancelDrag$ = new ReplaySubject();
      if (this.dragPointerDown.observers.length > 0) {
        this.zone.run(() => {
          this.dragPointerDown.next({
            x: 0,
            y: 0
          });
        });
      }
      const dragComplete$ = merge(this.pointerUp$, this.pointerDown$, cancelDrag$, this.destroy$).pipe(share());
      const pointerMove = combineLatest([this.pointerMove$, scrollContainerScroll$]).pipe(map(([pointerMoveEvent, scroll]) => {
        return {
          currentDrag$,
          transformX: pointerMoveEvent.clientX - pointerDownEvent.clientX,
          transformY: pointerMoveEvent.clientY - pointerDownEvent.clientY,
          clientX: pointerMoveEvent.clientX,
          clientY: pointerMoveEvent.clientY,
          scrollLeft: scroll.left,
          scrollTop: scroll.top,
          target: pointerMoveEvent.event.target
        };
      }), map((moveData) => {
        if (this.dragSnapGrid.x) {
          moveData.transformX = Math.round(moveData.transformX / this.dragSnapGrid.x) * this.dragSnapGrid.x;
        }
        if (this.dragSnapGrid.y) {
          moveData.transformY = Math.round(moveData.transformY / this.dragSnapGrid.y) * this.dragSnapGrid.y;
        }
        return moveData;
      }), map((moveData) => {
        if (!this.dragAxis.x) {
          moveData.transformX = 0;
        }
        if (!this.dragAxis.y) {
          moveData.transformY = 0;
        }
        return moveData;
      }), map((moveData) => {
        const scrollX = moveData.scrollLeft - startScrollPosition.left;
        const scrollY = moveData.scrollTop - startScrollPosition.top;
        return __spreadProps(__spreadValues({}, moveData), {
          x: moveData.transformX + scrollX,
          y: moveData.transformY + scrollY
        });
      }), filter(({
        x,
        y,
        transformX,
        transformY
      }) => !this.validateDrag || this.validateDrag({
        x,
        y,
        transform: {
          x: transformX,
          y: transformY
        }
      })), takeUntil(dragComplete$), share());
      const dragStarted$ = pointerMove.pipe(take(1), share());
      const dragEnded$ = pointerMove.pipe(takeLast(1), share());
      dragStarted$.subscribe(({
        clientX,
        clientY,
        x,
        y
      }) => {
        if (this.dragStart.observers.length > 0) {
          this.zone.run(() => {
            this.dragStart.next({
              cancelDrag$
            });
          });
        }
        this.scroller = bundle_es_default([this.scrollContainer ? this.scrollContainer.elementRef.nativeElement : this.document.defaultView], __spreadProps(__spreadValues({}, this.autoScroll), {
          autoScroll() {
            return true;
          }
        }));
        addClass(this.renderer, this.element, this.dragActiveClass);
        if (this.ghostDragEnabled) {
          const rect = this.element.nativeElement.getBoundingClientRect();
          const clone = this.element.nativeElement.cloneNode(true);
          if (!this.showOriginalElementWhileDragging) {
            this.renderer.setStyle(this.element.nativeElement, "visibility", "hidden");
          }
          if (this.ghostElementAppendTo) {
            this.ghostElementAppendTo.appendChild(clone);
          } else {
            this.element.nativeElement.parentNode.insertBefore(clone, this.element.nativeElement.nextSibling);
          }
          this.ghostElement = clone;
          this.document.body.style.cursor = this.dragCursor;
          this.setElementStyles(clone, {
            position: "fixed",
            top: `${rect.top}px`,
            left: `${rect.left}px`,
            width: `${rect.width}px`,
            height: `${rect.height}px`,
            cursor: this.dragCursor,
            margin: "0",
            willChange: "transform",
            pointerEvents: "none"
          });
          if (this.ghostElementTemplate) {
            const viewRef = this.vcr.createEmbeddedView(this.ghostElementTemplate);
            clone.innerHTML = "";
            viewRef.rootNodes.filter((node) => node instanceof Node).forEach((node) => {
              clone.appendChild(node);
            });
            dragEnded$.subscribe(() => {
              this.vcr.remove(this.vcr.indexOf(viewRef));
            });
          }
          if (this.ghostElementCreated.observers.length > 0) {
            this.zone.run(() => {
              this.ghostElementCreated.emit({
                clientX: clientX - x,
                clientY: clientY - y,
                element: clone
              });
            });
          }
          dragEnded$.subscribe(() => {
            clone.parentElement.removeChild(clone);
            this.ghostElement = null;
            this.renderer.setStyle(this.element.nativeElement, "visibility", "");
          });
        }
        this.draggableHelper.currentDrag.next(currentDrag$);
      });
      dragEnded$.pipe(mergeMap((dragEndData) => {
        const dragEndData$ = cancelDrag$.pipe(count(), take(1), map((calledCount) => __spreadProps(__spreadValues({}, dragEndData), {
          dragCancelled: calledCount > 0
        })));
        cancelDrag$.complete();
        return dragEndData$;
      })).subscribe(({
        x,
        y,
        dragCancelled
      }) => {
        this.scroller.destroy();
        if (this.dragEnd.observers.length > 0) {
          this.zone.run(() => {
            this.dragEnd.next({
              x,
              y,
              dragCancelled
            });
          });
        }
        removeClass(this.renderer, this.element, this.dragActiveClass);
        currentDrag$.complete();
      });
      merge(dragComplete$, dragEnded$).pipe(take(1)).subscribe(() => {
        requestAnimationFrame(() => {
          this.document.head.removeChild(globalDragStyle);
        });
      });
      return pointerMove;
    }), share());
    merge(pointerDragged$.pipe(take(1), map((value) => [, value])), pointerDragged$.pipe(pairwise())).pipe(filter(([previous, next]) => {
      if (!previous) {
        return true;
      }
      return previous.x !== next.x || previous.y !== next.y;
    }), map(([previous, next]) => next)).subscribe(({
      x,
      y,
      currentDrag$,
      clientX,
      clientY,
      transformX,
      transformY,
      target
    }) => {
      if (this.dragging.observers.length > 0) {
        this.zone.run(() => {
          this.dragging.next({
            x,
            y
          });
        });
      }
      requestAnimationFrame(() => {
        if (this.ghostElement) {
          const transform = `translate3d(${transformX}px, ${transformY}px, 0px)`;
          this.setElementStyles(this.ghostElement, {
            transform,
            "-webkit-transform": transform,
            "-ms-transform": transform,
            "-moz-transform": transform,
            "-o-transform": transform
          });
        }
      });
      currentDrag$.next({
        clientX,
        clientY,
        dropData: this.dropData,
        target
      });
    });
  }
  ngOnChanges(changes) {
    if (changes.dragAxis) {
      this.checkEventListeners();
    }
  }
  ngOnDestroy() {
    this.unsubscribeEventListeners();
    this.pointerDown$.complete();
    this.pointerMove$.complete();
    this.pointerUp$.complete();
    this.destroy$.next();
  }
  checkEventListeners() {
    const canDrag = this.canDrag();
    const hasEventListeners = Object.keys(this.eventListenerSubscriptions).length > 0;
    if (canDrag && !hasEventListeners) {
      this.zone.runOutsideAngular(() => {
        this.eventListenerSubscriptions.mousedown = this.renderer.listen(this.element.nativeElement, "mousedown", (event) => {
          this.onMouseDown(event);
        });
        this.eventListenerSubscriptions.mouseup = this.renderer.listen("document", "mouseup", (event) => {
          this.onMouseUp(event);
        });
        this.eventListenerSubscriptions.touchstart = this.renderer.listen(this.element.nativeElement, "touchstart", (event) => {
          this.onTouchStart(event);
        });
        this.eventListenerSubscriptions.touchend = this.renderer.listen("document", "touchend", (event) => {
          this.onTouchEnd(event);
        });
        this.eventListenerSubscriptions.touchcancel = this.renderer.listen("document", "touchcancel", (event) => {
          this.onTouchEnd(event);
        });
        this.eventListenerSubscriptions.mouseenter = this.renderer.listen(this.element.nativeElement, "mouseenter", () => {
          this.onMouseEnter();
        });
        this.eventListenerSubscriptions.mouseleave = this.renderer.listen(this.element.nativeElement, "mouseleave", () => {
          this.onMouseLeave();
        });
      });
    } else if (!canDrag && hasEventListeners) {
      this.unsubscribeEventListeners();
    }
  }
  onMouseDown(event) {
    if (event.button === 0) {
      if (!this.eventListenerSubscriptions.mousemove) {
        this.eventListenerSubscriptions.mousemove = this.renderer.listen("document", "mousemove", (mouseMoveEvent) => {
          this.pointerMove$.next({
            event: mouseMoveEvent,
            clientX: mouseMoveEvent.clientX,
            clientY: mouseMoveEvent.clientY
          });
        });
      }
      this.pointerDown$.next({
        event,
        clientX: event.clientX,
        clientY: event.clientY
      });
    }
  }
  onMouseUp(event) {
    if (event.button === 0) {
      if (this.eventListenerSubscriptions.mousemove) {
        this.eventListenerSubscriptions.mousemove();
        delete this.eventListenerSubscriptions.mousemove;
      }
      this.pointerUp$.next({
        event,
        clientX: event.clientX,
        clientY: event.clientY
      });
    }
  }
  onTouchStart(event) {
    let startScrollPosition;
    let isDragActivated;
    let hasContainerScrollbar;
    if (this.touchStartLongPress) {
      this.timeLongPress.timerBegin = Date.now();
      isDragActivated = false;
      hasContainerScrollbar = this.hasScrollbar();
      startScrollPosition = this.getScrollPosition();
    }
    if (!this.eventListenerSubscriptions.touchmove) {
      const contextMenuListener = fromEvent(this.document, "contextmenu").subscribe((e) => {
        e.preventDefault();
      });
      const touchMoveListener = fromEvent(this.document, "touchmove", {
        passive: false
      }).subscribe((touchMoveEvent) => {
        if (this.touchStartLongPress && !isDragActivated && hasContainerScrollbar) {
          isDragActivated = this.shouldBeginDrag(event, touchMoveEvent, startScrollPosition);
        }
        if (!this.touchStartLongPress || !hasContainerScrollbar || isDragActivated) {
          touchMoveEvent.preventDefault();
          this.pointerMove$.next({
            event: touchMoveEvent,
            clientX: touchMoveEvent.targetTouches[0].clientX,
            clientY: touchMoveEvent.targetTouches[0].clientY
          });
        }
      });
      this.eventListenerSubscriptions.touchmove = () => {
        contextMenuListener.unsubscribe();
        touchMoveListener.unsubscribe();
      };
    }
    this.pointerDown$.next({
      event,
      clientX: event.touches[0].clientX,
      clientY: event.touches[0].clientY
    });
  }
  onTouchEnd(event) {
    if (this.eventListenerSubscriptions.touchmove) {
      this.eventListenerSubscriptions.touchmove();
      delete this.eventListenerSubscriptions.touchmove;
      if (this.touchStartLongPress) {
        this.enableScroll();
      }
    }
    this.pointerUp$.next({
      event,
      clientX: event.changedTouches[0].clientX,
      clientY: event.changedTouches[0].clientY
    });
  }
  onMouseEnter() {
    this.setCursor(this.dragCursor);
  }
  onMouseLeave() {
    this.setCursor("");
  }
  canDrag() {
    return this.dragAxis.x || this.dragAxis.y;
  }
  setCursor(value) {
    if (!this.eventListenerSubscriptions.mousemove) {
      this.renderer.setStyle(this.element.nativeElement, "cursor", value);
    }
  }
  unsubscribeEventListeners() {
    Object.keys(this.eventListenerSubscriptions).forEach((type) => {
      this.eventListenerSubscriptions[type]();
      delete this.eventListenerSubscriptions[type];
    });
  }
  setElementStyles(element, styles) {
    Object.keys(styles).forEach((key) => {
      this.renderer.setStyle(element, key, styles[key]);
    });
  }
  getScrollElement() {
    if (this.scrollContainer) {
      return this.scrollContainer.elementRef.nativeElement;
    } else {
      return this.document.body;
    }
  }
  getScrollPosition() {
    if (this.scrollContainer) {
      return {
        top: this.scrollContainer.elementRef.nativeElement.scrollTop,
        left: this.scrollContainer.elementRef.nativeElement.scrollLeft
      };
    } else {
      return {
        top: window.pageYOffset || this.document.documentElement.scrollTop,
        left: window.pageXOffset || this.document.documentElement.scrollLeft
      };
    }
  }
  shouldBeginDrag(event, touchMoveEvent, startScrollPosition) {
    const moveScrollPosition = this.getScrollPosition();
    const deltaScroll = {
      top: Math.abs(moveScrollPosition.top - startScrollPosition.top),
      left: Math.abs(moveScrollPosition.left - startScrollPosition.left)
    };
    const deltaX = Math.abs(touchMoveEvent.targetTouches[0].clientX - event.touches[0].clientX) - deltaScroll.left;
    const deltaY = Math.abs(touchMoveEvent.targetTouches[0].clientY - event.touches[0].clientY) - deltaScroll.top;
    const deltaTotal = deltaX + deltaY;
    const longPressConfig = this.touchStartLongPress;
    if (deltaTotal > longPressConfig.delta || deltaScroll.top > 0 || deltaScroll.left > 0) {
      this.timeLongPress.timerBegin = Date.now();
    }
    this.timeLongPress.timerEnd = Date.now();
    const duration = this.timeLongPress.timerEnd - this.timeLongPress.timerBegin;
    if (duration >= longPressConfig.delay) {
      this.disableScroll();
      return true;
    }
    return false;
  }
  enableScroll() {
    if (this.scrollContainer) {
      this.renderer.setStyle(this.scrollContainer.elementRef.nativeElement, "overflow", "");
    }
    this.renderer.setStyle(this.document.body, "overflow", "");
  }
  disableScroll() {
    if (this.scrollContainer) {
      this.renderer.setStyle(this.scrollContainer.elementRef.nativeElement, "overflow", "hidden");
    }
    this.renderer.setStyle(this.document.body, "overflow", "hidden");
  }
  hasScrollbar() {
    const scrollContainer = this.getScrollElement();
    const containerHasHorizontalScroll = scrollContainer.scrollWidth > scrollContainer.clientWidth;
    const containerHasVerticalScroll = scrollContainer.scrollHeight > scrollContainer.clientHeight;
    return containerHasHorizontalScroll || containerHasVerticalScroll;
  }
};
DraggableDirective.ɵfac = function DraggableDirective_Factory(t) {
  return new (t || DraggableDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(DraggableHelper), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(DraggableScrollContainerDirective, 8), ɵɵdirectiveInject(DOCUMENT));
};
DraggableDirective.ɵdir = ɵɵdefineDirective({
  type: DraggableDirective,
  selectors: [["", "mwlDraggable", ""]],
  inputs: {
    dropData: "dropData",
    dragAxis: "dragAxis",
    dragSnapGrid: "dragSnapGrid",
    ghostDragEnabled: "ghostDragEnabled",
    showOriginalElementWhileDragging: "showOriginalElementWhileDragging",
    validateDrag: "validateDrag",
    dragCursor: "dragCursor",
    dragActiveClass: "dragActiveClass",
    ghostElementAppendTo: "ghostElementAppendTo",
    ghostElementTemplate: "ghostElementTemplate",
    touchStartLongPress: "touchStartLongPress",
    autoScroll: "autoScroll"
  },
  outputs: {
    dragPointerDown: "dragPointerDown",
    dragStart: "dragStart",
    ghostElementCreated: "ghostElementCreated",
    dragging: "dragging",
    dragEnd: "dragEnd"
  },
  features: [ɵɵNgOnChangesFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DraggableDirective, [{
    type: Directive,
    args: [{
      selector: "[mwlDraggable]"
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: DraggableHelper
    }, {
      type: NgZone
    }, {
      type: ViewContainerRef
    }, {
      type: DraggableScrollContainerDirective,
      decorators: [{
        type: Optional
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [DOCUMENT]
      }]
    }];
  }, {
    dropData: [{
      type: Input
    }],
    dragAxis: [{
      type: Input
    }],
    dragSnapGrid: [{
      type: Input
    }],
    ghostDragEnabled: [{
      type: Input
    }],
    showOriginalElementWhileDragging: [{
      type: Input
    }],
    validateDrag: [{
      type: Input
    }],
    dragCursor: [{
      type: Input
    }],
    dragActiveClass: [{
      type: Input
    }],
    ghostElementAppendTo: [{
      type: Input
    }],
    ghostElementTemplate: [{
      type: Input
    }],
    touchStartLongPress: [{
      type: Input
    }],
    autoScroll: [{
      type: Input
    }],
    dragPointerDown: [{
      type: Output
    }],
    dragStart: [{
      type: Output
    }],
    ghostElementCreated: [{
      type: Output
    }],
    dragging: [{
      type: Output
    }],
    dragEnd: [{
      type: Output
    }]
  });
})();
function isCoordinateWithinRectangle(clientX, clientY, rect) {
  return clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;
}
var DroppableDirective = class {
  constructor(element, draggableHelper, zone, renderer, scrollContainer) {
    this.element = element;
    this.draggableHelper = draggableHelper;
    this.zone = zone;
    this.renderer = renderer;
    this.scrollContainer = scrollContainer;
    this.dragEnter = new EventEmitter();
    this.dragLeave = new EventEmitter();
    this.dragOver = new EventEmitter();
    this.drop = new EventEmitter();
  }
  ngOnInit() {
    this.currentDragSubscription = this.draggableHelper.currentDrag.subscribe((drag$) => {
      addClass(this.renderer, this.element, this.dragActiveClass);
      const droppableElement = {
        updateCache: true
      };
      const deregisterScrollListener = this.renderer.listen(this.scrollContainer ? this.scrollContainer.elementRef.nativeElement : "window", "scroll", () => {
        droppableElement.updateCache = true;
      });
      let currentDragEvent;
      const overlaps$ = drag$.pipe(map(({
        clientX,
        clientY,
        dropData,
        target
      }) => {
        currentDragEvent = {
          clientX,
          clientY,
          dropData,
          target
        };
        if (droppableElement.updateCache) {
          droppableElement.rect = this.element.nativeElement.getBoundingClientRect();
          if (this.scrollContainer) {
            droppableElement.scrollContainerRect = this.scrollContainer.elementRef.nativeElement.getBoundingClientRect();
          }
          droppableElement.updateCache = false;
        }
        const isWithinElement = isCoordinateWithinRectangle(clientX, clientY, droppableElement.rect);
        const isDropAllowed = !this.validateDrop || this.validateDrop({
          clientX,
          clientY,
          target,
          dropData
        });
        if (droppableElement.scrollContainerRect) {
          return isWithinElement && isDropAllowed && isCoordinateWithinRectangle(clientX, clientY, droppableElement.scrollContainerRect);
        } else {
          return isWithinElement && isDropAllowed;
        }
      }));
      const overlapsChanged$ = overlaps$.pipe(distinctUntilChanged());
      let dragOverActive;
      overlapsChanged$.pipe(filter((overlapsNow) => overlapsNow)).subscribe(() => {
        dragOverActive = true;
        addClass(this.renderer, this.element, this.dragOverClass);
        if (this.dragEnter.observers.length > 0) {
          this.zone.run(() => {
            this.dragEnter.next(currentDragEvent);
          });
        }
      });
      overlaps$.pipe(filter((overlapsNow) => overlapsNow)).subscribe(() => {
        if (this.dragOver.observers.length > 0) {
          this.zone.run(() => {
            this.dragOver.next(currentDragEvent);
          });
        }
      });
      overlapsChanged$.pipe(pairwise(), filter(([didOverlap, overlapsNow]) => didOverlap && !overlapsNow)).subscribe(() => {
        dragOverActive = false;
        removeClass(this.renderer, this.element, this.dragOverClass);
        if (this.dragLeave.observers.length > 0) {
          this.zone.run(() => {
            this.dragLeave.next(currentDragEvent);
          });
        }
      });
      drag$.subscribe({
        complete: () => {
          deregisterScrollListener();
          removeClass(this.renderer, this.element, this.dragActiveClass);
          if (dragOverActive) {
            removeClass(this.renderer, this.element, this.dragOverClass);
            if (this.drop.observers.length > 0) {
              this.zone.run(() => {
                this.drop.next(currentDragEvent);
              });
            }
          }
        }
      });
    });
  }
  ngOnDestroy() {
    if (this.currentDragSubscription) {
      this.currentDragSubscription.unsubscribe();
    }
  }
};
DroppableDirective.ɵfac = function DroppableDirective_Factory(t) {
  return new (t || DroppableDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(DraggableHelper), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(DraggableScrollContainerDirective, 8));
};
DroppableDirective.ɵdir = ɵɵdefineDirective({
  type: DroppableDirective,
  selectors: [["", "mwlDroppable", ""]],
  inputs: {
    dragOverClass: "dragOverClass",
    dragActiveClass: "dragActiveClass",
    validateDrop: "validateDrop"
  },
  outputs: {
    dragEnter: "dragEnter",
    dragLeave: "dragLeave",
    dragOver: "dragOver",
    drop: "drop"
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DroppableDirective, [{
    type: Directive,
    args: [{
      selector: "[mwlDroppable]"
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: DraggableHelper
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: DraggableScrollContainerDirective,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    dragOverClass: [{
      type: Input
    }],
    dragActiveClass: [{
      type: Input
    }],
    validateDrop: [{
      type: Input
    }],
    dragEnter: [{
      type: Output
    }],
    dragLeave: [{
      type: Output
    }],
    dragOver: [{
      type: Output
    }],
    drop: [{
      type: Output
    }]
  });
})();
var DragAndDropModule = class {
};
DragAndDropModule.ɵfac = function DragAndDropModule_Factory(t) {
  return new (t || DragAndDropModule)();
};
DragAndDropModule.ɵmod = ɵɵdefineNgModule({
  type: DragAndDropModule,
  declarations: [DraggableDirective, DroppableDirective, DraggableScrollContainerDirective],
  exports: [DraggableDirective, DroppableDirective, DraggableScrollContainerDirective]
});
DragAndDropModule.ɵinj = ɵɵdefineInjector({});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragAndDropModule, [{
    type: NgModule,
    args: [{
      declarations: [DraggableDirective, DroppableDirective, DraggableScrollContainerDirective],
      exports: [DraggableDirective, DroppableDirective, DraggableScrollContainerDirective]
    }]
  }], null, null);
})();

// node_modules/angular-resizable-element/fesm2020/angular-resizable-element.mjs
var IS_TOUCH_DEVICE = (() => {
  if (typeof window === "undefined") {
    return false;
  } else {
    return "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
  }
})();
function deepCloneNode(node) {
  const clone = node.cloneNode(true);
  const descendantsWithId = clone.querySelectorAll("[id]");
  const nodeName = node.nodeName.toLowerCase();
  clone.removeAttribute("id");
  descendantsWithId.forEach((descendant) => {
    descendant.removeAttribute("id");
  });
  if (nodeName === "canvas") {
    transferCanvasData(node, clone);
  } else if (nodeName === "input" || nodeName === "select" || nodeName === "textarea") {
    transferInputData(node, clone);
  }
  transferData("canvas", node, clone, transferCanvasData);
  transferData("input, textarea, select", node, clone, transferInputData);
  return clone;
}
function transferData(selector, node, clone, callback) {
  const descendantElements = node.querySelectorAll(selector);
  if (descendantElements.length) {
    const cloneElements = clone.querySelectorAll(selector);
    for (let i = 0; i < descendantElements.length; i++) {
      callback(descendantElements[i], cloneElements[i]);
    }
  }
}
var cloneUniqueId = 0;
function transferInputData(source, clone) {
  if (clone.type !== "file") {
    clone.value = source.value;
  }
  if (clone.type === "radio" && clone.name) {
    clone.name = `mat-clone-${clone.name}-${cloneUniqueId++}`;
  }
}
function transferCanvasData(source, clone) {
  const context = clone.getContext("2d");
  if (context) {
    try {
      context.drawImage(source, 0, 0);
    } catch {
    }
  }
}
function getNewBoundingRectangle(startingRect, edges, clientX, clientY) {
  const newBoundingRect = {
    top: startingRect.top,
    bottom: startingRect.bottom,
    left: startingRect.left,
    right: startingRect.right
  };
  if (edges.top) {
    newBoundingRect.top += clientY;
  }
  if (edges.bottom) {
    newBoundingRect.bottom += clientY;
  }
  if (edges.left) {
    newBoundingRect.left += clientX;
  }
  if (edges.right) {
    newBoundingRect.right += clientX;
  }
  newBoundingRect.height = newBoundingRect.bottom - newBoundingRect.top;
  newBoundingRect.width = newBoundingRect.right - newBoundingRect.left;
  return newBoundingRect;
}
function getElementRect(element, ghostElementPositioning) {
  let translateX = 0;
  let translateY = 0;
  const style2 = element.nativeElement.style;
  const transformProperties = ["transform", "-ms-transform", "-moz-transform", "-o-transform"];
  const transform = transformProperties.map((property) => style2[property]).find((value) => !!value);
  if (transform && transform.includes("translate")) {
    translateX = transform.replace(/.*translate3?d?\((-?[0-9]*)px, (-?[0-9]*)px.*/, "$1");
    translateY = transform.replace(/.*translate3?d?\((-?[0-9]*)px, (-?[0-9]*)px.*/, "$2");
  }
  if (ghostElementPositioning === "absolute") {
    return {
      height: element.nativeElement.offsetHeight,
      width: element.nativeElement.offsetWidth,
      top: element.nativeElement.offsetTop - translateY,
      bottom: element.nativeElement.offsetHeight + element.nativeElement.offsetTop - translateY,
      left: element.nativeElement.offsetLeft - translateX,
      right: element.nativeElement.offsetWidth + element.nativeElement.offsetLeft - translateX
    };
  } else {
    const boundingRect = element.nativeElement.getBoundingClientRect();
    return {
      height: boundingRect.height,
      width: boundingRect.width,
      top: boundingRect.top - translateY,
      bottom: boundingRect.bottom - translateY,
      left: boundingRect.left - translateX,
      right: boundingRect.right - translateX,
      scrollTop: element.nativeElement.scrollTop,
      scrollLeft: element.nativeElement.scrollLeft
    };
  }
}
var DEFAULT_RESIZE_CURSORS = Object.freeze({
  topLeft: "nw-resize",
  topRight: "ne-resize",
  bottomLeft: "sw-resize",
  bottomRight: "se-resize",
  leftOrRight: "col-resize",
  topOrBottom: "row-resize"
});
function getResizeCursor(edges, cursors) {
  if (edges.left && edges.top) {
    return cursors.topLeft;
  } else if (edges.right && edges.top) {
    return cursors.topRight;
  } else if (edges.left && edges.bottom) {
    return cursors.bottomLeft;
  } else if (edges.right && edges.bottom) {
    return cursors.bottomRight;
  } else if (edges.left || edges.right) {
    return cursors.leftOrRight;
  } else if (edges.top || edges.bottom) {
    return cursors.topOrBottom;
  } else {
    return "";
  }
}
function getEdgesDiff({
  edges,
  initialRectangle,
  newRectangle
}) {
  const edgesDiff = {};
  Object.keys(edges).forEach((edge) => {
    edgesDiff[edge] = (newRectangle[edge] || 0) - (initialRectangle[edge] || 0);
  });
  return edgesDiff;
}
var RESIZE_ACTIVE_CLASS = "resize-active";
var RESIZE_GHOST_ELEMENT_CLASS = "resize-ghost-element";
var MOUSE_MOVE_THROTTLE_MS = 50;
var ResizableDirective = class {
  /**
   * @hidden
   */
  constructor(platformId, renderer, elm, zone) {
    this.platformId = platformId;
    this.renderer = renderer;
    this.elm = elm;
    this.zone = zone;
    this.enableGhostResize = false;
    this.resizeSnapGrid = {};
    this.resizeCursors = DEFAULT_RESIZE_CURSORS;
    this.ghostElementPositioning = "fixed";
    this.allowNegativeResizes = false;
    this.mouseMoveThrottleMS = MOUSE_MOVE_THROTTLE_MS;
    this.resizeStart = new EventEmitter();
    this.resizing = new EventEmitter();
    this.resizeEnd = new EventEmitter();
    this.mouseup = new Subject();
    this.mousedown = new Subject();
    this.mousemove = new Subject();
    this.destroy$ = new Subject();
    this.pointerEventListeners = PointerEventListeners.getInstance(renderer, zone);
  }
  /**
   * @hidden
   */
  ngOnInit() {
    const mousedown$ = merge(this.pointerEventListeners.pointerDown, this.mousedown);
    const mousemove$ = merge(this.pointerEventListeners.pointerMove, this.mousemove).pipe(tap(({
      event
    }) => {
      if (currentResize && event.cancelable) {
        event.preventDefault();
      }
    }), share());
    const mouseup$ = merge(this.pointerEventListeners.pointerUp, this.mouseup);
    let currentResize;
    const removeGhostElement = () => {
      if (currentResize && currentResize.clonedNode) {
        this.elm.nativeElement.parentElement.removeChild(currentResize.clonedNode);
        this.renderer.setStyle(this.elm.nativeElement, "visibility", "inherit");
      }
    };
    const getResizeCursors = () => {
      return __spreadValues(__spreadValues({}, DEFAULT_RESIZE_CURSORS), this.resizeCursors);
    };
    const mousedrag = mousedown$.pipe(mergeMap((startCoords) => {
      function getDiff(moveCoords) {
        return {
          clientX: moveCoords.clientX - startCoords.clientX,
          clientY: moveCoords.clientY - startCoords.clientY
        };
      }
      const getSnapGrid = () => {
        const snapGrid = {
          x: 1,
          y: 1
        };
        if (currentResize) {
          if (this.resizeSnapGrid.left && currentResize.edges.left) {
            snapGrid.x = +this.resizeSnapGrid.left;
          } else if (this.resizeSnapGrid.right && currentResize.edges.right) {
            snapGrid.x = +this.resizeSnapGrid.right;
          }
          if (this.resizeSnapGrid.top && currentResize.edges.top) {
            snapGrid.y = +this.resizeSnapGrid.top;
          } else if (this.resizeSnapGrid.bottom && currentResize.edges.bottom) {
            snapGrid.y = +this.resizeSnapGrid.bottom;
          }
        }
        return snapGrid;
      };
      function getGrid(coords, snapGrid) {
        return {
          x: Math.ceil(coords.clientX / snapGrid.x),
          y: Math.ceil(coords.clientY / snapGrid.y)
        };
      }
      return merge(mousemove$.pipe(take(1)).pipe(map((coords) => [, coords])), mousemove$.pipe(pairwise())).pipe(map(([previousCoords, newCoords]) => {
        return [previousCoords ? getDiff(previousCoords) : previousCoords, getDiff(newCoords)];
      })).pipe(filter(([previousCoords, newCoords]) => {
        if (!previousCoords) {
          return true;
        }
        const snapGrid = getSnapGrid();
        const previousGrid = getGrid(previousCoords, snapGrid);
        const newGrid = getGrid(newCoords, snapGrid);
        return previousGrid.x !== newGrid.x || previousGrid.y !== newGrid.y;
      })).pipe(map(([, newCoords]) => {
        const snapGrid = getSnapGrid();
        return {
          clientX: Math.round(newCoords.clientX / snapGrid.x) * snapGrid.x,
          clientY: Math.round(newCoords.clientY / snapGrid.y) * snapGrid.y
        };
      })).pipe(takeUntil(merge(mouseup$, mousedown$)));
    })).pipe(filter(() => !!currentResize));
    mousedrag.pipe(map(({
      clientX,
      clientY
    }) => {
      return getNewBoundingRectangle(currentResize.startingRect, currentResize.edges, clientX, clientY);
    })).pipe(filter((newBoundingRect) => {
      return this.allowNegativeResizes || !!(newBoundingRect.height && newBoundingRect.width && newBoundingRect.height > 0 && newBoundingRect.width > 0);
    })).pipe(filter((newBoundingRect) => {
      return this.validateResize ? this.validateResize({
        rectangle: newBoundingRect,
        edges: getEdgesDiff({
          edges: currentResize.edges,
          initialRectangle: currentResize.startingRect,
          newRectangle: newBoundingRect
        })
      }) : true;
    }), takeUntil(this.destroy$)).subscribe((newBoundingRect) => {
      if (currentResize && currentResize.clonedNode) {
        this.renderer.setStyle(currentResize.clonedNode, "height", `${newBoundingRect.height}px`);
        this.renderer.setStyle(currentResize.clonedNode, "width", `${newBoundingRect.width}px`);
        this.renderer.setStyle(currentResize.clonedNode, "top", `${newBoundingRect.top}px`);
        this.renderer.setStyle(currentResize.clonedNode, "left", `${newBoundingRect.left}px`);
      }
      if (this.resizing.observers.length > 0) {
        this.zone.run(() => {
          this.resizing.emit({
            edges: getEdgesDiff({
              edges: currentResize.edges,
              initialRectangle: currentResize.startingRect,
              newRectangle: newBoundingRect
            }),
            rectangle: newBoundingRect
          });
        });
      }
      currentResize.currentRect = newBoundingRect;
    });
    mousedown$.pipe(map(({
      edges
    }) => {
      return edges || {};
    }), filter((edges) => {
      return Object.keys(edges).length > 0;
    }), takeUntil(this.destroy$)).subscribe((edges) => {
      if (currentResize) {
        removeGhostElement();
      }
      const startingRect = getElementRect(this.elm, this.ghostElementPositioning);
      currentResize = {
        edges,
        startingRect,
        currentRect: startingRect
      };
      const resizeCursors = getResizeCursors();
      const cursor = getResizeCursor(currentResize.edges, resizeCursors);
      this.renderer.setStyle(document.body, "cursor", cursor);
      this.setElementClass(this.elm, RESIZE_ACTIVE_CLASS, true);
      if (this.enableGhostResize) {
        currentResize.clonedNode = deepCloneNode(this.elm.nativeElement);
        this.elm.nativeElement.parentElement.appendChild(currentResize.clonedNode);
        this.renderer.setStyle(this.elm.nativeElement, "visibility", "hidden");
        this.renderer.setStyle(currentResize.clonedNode, "position", this.ghostElementPositioning);
        this.renderer.setStyle(currentResize.clonedNode, "left", `${currentResize.startingRect.left}px`);
        this.renderer.setStyle(currentResize.clonedNode, "top", `${currentResize.startingRect.top}px`);
        this.renderer.setStyle(currentResize.clonedNode, "height", `${currentResize.startingRect.height}px`);
        this.renderer.setStyle(currentResize.clonedNode, "width", `${currentResize.startingRect.width}px`);
        this.renderer.setStyle(currentResize.clonedNode, "cursor", getResizeCursor(currentResize.edges, resizeCursors));
        this.renderer.addClass(currentResize.clonedNode, RESIZE_GHOST_ELEMENT_CLASS);
        currentResize.clonedNode.scrollTop = currentResize.startingRect.scrollTop;
        currentResize.clonedNode.scrollLeft = currentResize.startingRect.scrollLeft;
      }
      if (this.resizeStart.observers.length > 0) {
        this.zone.run(() => {
          this.resizeStart.emit({
            edges: getEdgesDiff({
              edges,
              initialRectangle: startingRect,
              newRectangle: startingRect
            }),
            rectangle: getNewBoundingRectangle(startingRect, {}, 0, 0)
          });
        });
      }
    });
    mouseup$.pipe(takeUntil(this.destroy$)).subscribe(() => {
      if (currentResize) {
        this.renderer.removeClass(this.elm.nativeElement, RESIZE_ACTIVE_CLASS);
        this.renderer.setStyle(document.body, "cursor", "");
        this.renderer.setStyle(this.elm.nativeElement, "cursor", "");
        if (this.resizeEnd.observers.length > 0) {
          this.zone.run(() => {
            this.resizeEnd.emit({
              edges: getEdgesDiff({
                edges: currentResize.edges,
                initialRectangle: currentResize.startingRect,
                newRectangle: currentResize.currentRect
              }),
              rectangle: currentResize.currentRect
            });
          });
        }
        removeGhostElement();
        currentResize = null;
      }
    });
  }
  /**
   * @hidden
   */
  ngOnDestroy() {
    if (isPlatformBrowser(this.platformId)) {
      this.renderer.setStyle(document.body, "cursor", "");
    }
    this.mousedown.complete();
    this.mouseup.complete();
    this.mousemove.complete();
    this.destroy$.next();
  }
  setElementClass(elm, name, add2) {
    if (add2) {
      this.renderer.addClass(elm.nativeElement, name);
    } else {
      this.renderer.removeClass(elm.nativeElement, name);
    }
  }
};
ResizableDirective.ɵfac = function ResizableDirective_Factory(t) {
  return new (t || ResizableDirective)(ɵɵdirectiveInject(PLATFORM_ID), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
ResizableDirective.ɵdir = ɵɵdefineDirective({
  type: ResizableDirective,
  selectors: [["", "mwlResizable", ""]],
  inputs: {
    validateResize: "validateResize",
    enableGhostResize: "enableGhostResize",
    resizeSnapGrid: "resizeSnapGrid",
    resizeCursors: "resizeCursors",
    ghostElementPositioning: "ghostElementPositioning",
    allowNegativeResizes: "allowNegativeResizes",
    mouseMoveThrottleMS: "mouseMoveThrottleMS"
  },
  outputs: {
    resizeStart: "resizeStart",
    resizing: "resizing",
    resizeEnd: "resizeEnd"
  },
  exportAs: ["mwlResizable"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ResizableDirective, [{
    type: Directive,
    args: [{
      selector: "[mwlResizable]",
      exportAs: "mwlResizable"
    }]
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, {
    validateResize: [{
      type: Input
    }],
    enableGhostResize: [{
      type: Input
    }],
    resizeSnapGrid: [{
      type: Input
    }],
    resizeCursors: [{
      type: Input
    }],
    ghostElementPositioning: [{
      type: Input
    }],
    allowNegativeResizes: [{
      type: Input
    }],
    mouseMoveThrottleMS: [{
      type: Input
    }],
    resizeStart: [{
      type: Output
    }],
    resizing: [{
      type: Output
    }],
    resizeEnd: [{
      type: Output
    }]
  });
})();
var PointerEventListeners = class _PointerEventListeners {
  constructor(renderer, zone) {
    this.pointerDown = new Observable((observer) => {
      let unsubscribeMouseDown;
      let unsubscribeTouchStart;
      zone.runOutsideAngular(() => {
        unsubscribeMouseDown = renderer.listen("document", "mousedown", (event) => {
          observer.next({
            clientX: event.clientX,
            clientY: event.clientY,
            event
          });
        });
        if (IS_TOUCH_DEVICE) {
          unsubscribeTouchStart = renderer.listen("document", "touchstart", (event) => {
            observer.next({
              clientX: event.touches[0].clientX,
              clientY: event.touches[0].clientY,
              event
            });
          });
        }
      });
      return () => {
        unsubscribeMouseDown();
        if (IS_TOUCH_DEVICE) {
          unsubscribeTouchStart();
        }
      };
    }).pipe(share());
    this.pointerMove = new Observable((observer) => {
      let unsubscribeMouseMove;
      let unsubscribeTouchMove;
      zone.runOutsideAngular(() => {
        unsubscribeMouseMove = renderer.listen("document", "mousemove", (event) => {
          observer.next({
            clientX: event.clientX,
            clientY: event.clientY,
            event
          });
        });
        if (IS_TOUCH_DEVICE) {
          unsubscribeTouchMove = renderer.listen("document", "touchmove", (event) => {
            observer.next({
              clientX: event.targetTouches[0].clientX,
              clientY: event.targetTouches[0].clientY,
              event
            });
          });
        }
      });
      return () => {
        unsubscribeMouseMove();
        if (IS_TOUCH_DEVICE) {
          unsubscribeTouchMove();
        }
      };
    }).pipe(share());
    this.pointerUp = new Observable((observer) => {
      let unsubscribeMouseUp;
      let unsubscribeTouchEnd;
      let unsubscribeTouchCancel;
      zone.runOutsideAngular(() => {
        unsubscribeMouseUp = renderer.listen("document", "mouseup", (event) => {
          observer.next({
            clientX: event.clientX,
            clientY: event.clientY,
            event
          });
        });
        if (IS_TOUCH_DEVICE) {
          unsubscribeTouchEnd = renderer.listen("document", "touchend", (event) => {
            observer.next({
              clientX: event.changedTouches[0].clientX,
              clientY: event.changedTouches[0].clientY,
              event
            });
          });
          unsubscribeTouchCancel = renderer.listen("document", "touchcancel", (event) => {
            observer.next({
              clientX: event.changedTouches[0].clientX,
              clientY: event.changedTouches[0].clientY,
              event
            });
          });
        }
      });
      return () => {
        unsubscribeMouseUp();
        if (IS_TOUCH_DEVICE) {
          unsubscribeTouchEnd();
          unsubscribeTouchCancel();
        }
      };
    }).pipe(share());
  }
  static getInstance(renderer, zone) {
    if (!_PointerEventListeners.instance) {
      _PointerEventListeners.instance = new _PointerEventListeners(renderer, zone);
    }
    return _PointerEventListeners.instance;
  }
};
var ResizeHandleDirective = class {
  constructor(renderer, element, zone, resizableDirective) {
    this.renderer = renderer;
    this.element = element;
    this.zone = zone;
    this.resizableDirective = resizableDirective;
    this.resizeEdges = {};
    this.eventListeners = {};
    this.destroy$ = new Subject();
  }
  ngOnInit() {
    this.zone.runOutsideAngular(() => {
      this.listenOnTheHost("mousedown").subscribe((event) => {
        this.onMousedown(event, event.clientX, event.clientY);
      });
      this.listenOnTheHost("mouseup").subscribe((event) => {
        this.onMouseup(event.clientX, event.clientY);
      });
      if (IS_TOUCH_DEVICE) {
        this.listenOnTheHost("touchstart").subscribe((event) => {
          this.onMousedown(event, event.touches[0].clientX, event.touches[0].clientY);
        });
        merge(this.listenOnTheHost("touchend"), this.listenOnTheHost("touchcancel")).subscribe((event) => {
          this.onMouseup(event.changedTouches[0].clientX, event.changedTouches[0].clientY);
        });
      }
    });
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.unsubscribeEventListeners();
  }
  /**
   * @hidden
   */
  onMousedown(event, clientX, clientY) {
    if (event.cancelable) {
      event.preventDefault();
    }
    if (!this.eventListeners.touchmove) {
      this.eventListeners.touchmove = this.renderer.listen(this.element.nativeElement, "touchmove", (touchMoveEvent) => {
        this.onMousemove(touchMoveEvent, touchMoveEvent.targetTouches[0].clientX, touchMoveEvent.targetTouches[0].clientY);
      });
    }
    if (!this.eventListeners.mousemove) {
      this.eventListeners.mousemove = this.renderer.listen(this.element.nativeElement, "mousemove", (mouseMoveEvent) => {
        this.onMousemove(mouseMoveEvent, mouseMoveEvent.clientX, mouseMoveEvent.clientY);
      });
    }
    this.resizable.mousedown.next({
      clientX,
      clientY,
      edges: this.resizeEdges
    });
  }
  /**
   * @hidden
   */
  onMouseup(clientX, clientY) {
    this.unsubscribeEventListeners();
    this.resizable.mouseup.next({
      clientX,
      clientY,
      edges: this.resizeEdges
    });
  }
  // directive might be passed from DI or as an input
  get resizable() {
    return this.resizableDirective || this.resizableContainer;
  }
  onMousemove(event, clientX, clientY) {
    this.resizable.mousemove.next({
      clientX,
      clientY,
      edges: this.resizeEdges,
      event
    });
  }
  unsubscribeEventListeners() {
    Object.keys(this.eventListeners).forEach((type) => {
      this.eventListeners[type]();
      delete this.eventListeners[type];
    });
  }
  listenOnTheHost(eventName) {
    return fromEvent(this.element.nativeElement, eventName).pipe(takeUntil(this.destroy$));
  }
};
ResizeHandleDirective.ɵfac = function ResizeHandleDirective_Factory(t) {
  return new (t || ResizeHandleDirective)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ResizableDirective, 8));
};
ResizeHandleDirective.ɵdir = ɵɵdefineDirective({
  type: ResizeHandleDirective,
  selectors: [["", "mwlResizeHandle", ""]],
  inputs: {
    resizeEdges: "resizeEdges",
    resizableContainer: "resizableContainer"
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ResizeHandleDirective, [{
    type: Directive,
    args: [{
      selector: "[mwlResizeHandle]"
    }]
  }], function() {
    return [{
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: ResizableDirective,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    resizeEdges: [{
      type: Input
    }],
    resizableContainer: [{
      type: Input
    }]
  });
})();
var ResizableModule = class {
};
ResizableModule.ɵfac = function ResizableModule_Factory(t) {
  return new (t || ResizableModule)();
};
ResizableModule.ɵmod = ɵɵdefineNgModule({
  type: ResizableModule,
  declarations: [ResizableDirective, ResizeHandleDirective],
  exports: [ResizableDirective, ResizeHandleDirective]
});
ResizableModule.ɵinj = ɵɵdefineInjector({});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ResizableModule, [{
    type: NgModule,
    args: [{
      declarations: [ResizableDirective, ResizeHandleDirective],
      exports: [ResizableDirective, ResizeHandleDirective]
    }]
  }], null, null);
})();

// node_modules/angular-calendar/fesm2020/angular-calendar.mjs
var _c02 = (a0, a1) => ({
  event: a0,
  trackByActionId: a1
});
var _c12 = (a0) => ({
  action: a0
});
function CalendarEventActionsComponent_ng_template_0_span_0_a_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 5);
    ɵɵpipe(1, "calendarA11y");
    ɵɵlistener("mwlClick", function CalendarEventActionsComponent_ng_template_0_span_0_a_1_Template_a_mwlClick_0_listener($event) {
      const action_r2 = ɵɵrestoreView(_r1).$implicit;
      const event_r3 = ɵɵnextContext(2).event;
      return ɵɵresetView(action_r2.onClick({
        event: event_r3,
        sourceEvent: $event
      }));
    })("mwlKeydownEnter", function CalendarEventActionsComponent_ng_template_0_span_0_a_1_Template_a_mwlKeydownEnter_0_listener($event) {
      const action_r2 = ɵɵrestoreView(_r1).$implicit;
      const event_r3 = ɵɵnextContext(2).event;
      return ɵɵresetView(action_r2.onClick({
        event: event_r3,
        sourceEvent: $event
      }));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const action_r2 = ctx.$implicit;
    ɵɵproperty("ngClass", action_r2.cssClass)("innerHtml", action_r2.label, ɵɵsanitizeHtml);
    ɵɵattribute("aria-label", ɵɵpipeBind2(1, 3, ɵɵpureFunction1(6, _c12, action_r2), "actionButtonLabel"));
  }
}
function CalendarEventActionsComponent_ng_template_0_span_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 3);
    ɵɵtemplate(1, CalendarEventActionsComponent_ng_template_0_span_0_a_1_Template, 2, 8, "a", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    const event_r3 = ctx_r3.event;
    const trackByActionId_r5 = ctx_r3.trackByActionId;
    ɵɵadvance();
    ɵɵproperty("ngForOf", event_r3.actions)("ngForTrackBy", trackByActionId_r5);
  }
}
function CalendarEventActionsComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, CalendarEventActionsComponent_ng_template_0_span_0_Template, 2, 2, "span", 2);
  }
  if (rf & 2) {
    const event_r3 = ctx.event;
    ɵɵproperty("ngIf", event_r3.actions);
  }
}
function CalendarEventActionsComponent_ng_template_2_Template(rf, ctx) {
}
var _c2 = (a0, a1) => ({
  event: a0,
  view: a1
});
var _c3 = () => ({});
function CalendarEventTitleComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 2);
    ɵɵpipe(1, "calendarEventTitle");
    ɵɵpipe(2, "calendarA11y");
  }
  if (rf & 2) {
    const event_r1 = ctx.event;
    const view_r2 = ctx.view;
    ɵɵproperty("innerHTML", ɵɵpipeBind3(1, 2, event_r1.title, view_r2, event_r1), ɵɵsanitizeHtml);
    ɵɵattribute("aria-hidden", ɵɵpipeBind2(2, 6, ɵɵpureFunction0(9, _c3), "hideEventTitle"));
  }
}
function CalendarEventTitleComponent_ng_template_2_Template(rf, ctx) {
}
var _c4 = (a0, a1, a2) => ({
  contents: a0,
  placement: a1,
  event: a2
});
function CalendarTooltipWindowComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 2);
    ɵɵelement(1, "div", 3)(2, "div", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const contents_r1 = ctx.contents;
    const placement_r2 = ctx.placement;
    ɵɵproperty("ngClass", "cal-tooltip-" + placement_r2);
    ɵɵadvance(2);
    ɵɵproperty("innerHtml", contents_r1, ɵɵsanitizeHtml);
  }
}
function CalendarTooltipWindowComponent_ng_template_2_Template(rf, ctx) {
}
var _c5 = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) => ({
  day: a0,
  openDay: a1,
  locale: a2,
  tooltipPlacement: a3,
  highlightDay: a4,
  unhighlightDay: a5,
  eventClicked: a6,
  tooltipTemplate: a7,
  tooltipAppendToBody: a8,
  tooltipDelay: a9,
  trackByEventId: a10,
  validateDrag: a11
});
var _c6 = (a0, a1) => ({
  day: a0,
  locale: a1
});
var _c7 = (a0) => ({
  backgroundColor: a0
});
var _c8 = (a0, a1) => ({
  event: a0,
  draggedFrom: a1
});
var _c9 = (a0, a1) => ({
  x: a0,
  y: a1
});
var _c10 = () => ({
  delay: 300,
  delta: 30
});
function CalendarMonthCellComponent_ng_template_0_span_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 7);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const day_r1 = ɵɵnextContext().day;
    ɵɵadvance();
    ɵɵtextInterpolate(day_r1.badgeTotal);
  }
}
function CalendarMonthCellComponent_ng_template_0_div_7_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 10);
    ɵɵpipe(1, "calendarEventTitle");
    ɵɵpipe(2, "calendarA11y");
    ɵɵlistener("mouseenter", function CalendarMonthCellComponent_ng_template_0_div_7_div_1_Template_div_mouseenter_0_listener() {
      const event_r3 = ɵɵrestoreView(_r2).$implicit;
      const highlightDay_r4 = ɵɵnextContext(2).highlightDay;
      return ɵɵresetView(highlightDay_r4.emit({
        event: event_r3
      }));
    })("mouseleave", function CalendarMonthCellComponent_ng_template_0_div_7_div_1_Template_div_mouseleave_0_listener() {
      const event_r3 = ɵɵrestoreView(_r2).$implicit;
      const unhighlightDay_r5 = ɵɵnextContext(2).unhighlightDay;
      return ɵɵresetView(unhighlightDay_r5.emit({
        event: event_r3
      }));
    })("mwlClick", function CalendarMonthCellComponent_ng_template_0_div_7_div_1_Template_div_mwlClick_0_listener($event) {
      const event_r3 = ɵɵrestoreView(_r2).$implicit;
      const eventClicked_r6 = ɵɵnextContext(2).eventClicked;
      return ɵɵresetView(eventClicked_r6.emit({
        event: event_r3,
        sourceEvent: $event
      }));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const event_r3 = ctx.$implicit;
    const ctx_r6 = ɵɵnextContext(2);
    const day_r1 = ctx_r6.day;
    const tooltipPlacement_r8 = ctx_r6.tooltipPlacement;
    const tooltipTemplate_r9 = ctx_r6.tooltipTemplate;
    const tooltipAppendToBody_r10 = ctx_r6.tooltipAppendToBody;
    const tooltipDelay_r11 = ctx_r6.tooltipDelay;
    const validateDrag_r12 = ctx_r6.validateDrag;
    ɵɵclassProp("cal-draggable", event_r3.draggable);
    ɵɵproperty("ngStyle", ɵɵpureFunction1(22, _c7, event_r3.color == null ? null : event_r3.color.primary))("ngClass", event_r3 == null ? null : event_r3.cssClass)("mwlCalendarTooltip", ɵɵpipeBind3(1, 15, event_r3.title, "monthTooltip", event_r3))("tooltipPlacement", tooltipPlacement_r8)("tooltipEvent", event_r3)("tooltipTemplate", tooltipTemplate_r9)("tooltipAppendToBody", tooltipAppendToBody_r10)("tooltipDelay", tooltipDelay_r11)("dropData", ɵɵpureFunction2(24, _c8, event_r3, day_r1))("dragAxis", ɵɵpureFunction2(27, _c9, event_r3.draggable, event_r3.draggable))("validateDrag", validateDrag_r12)("touchStartLongPress", ɵɵpureFunction0(30, _c10));
    ɵɵattribute("aria-hidden", ɵɵpipeBind2(2, 19, ɵɵpureFunction0(31, _c3), "hideMonthCellEvents"));
  }
}
function CalendarMonthCellComponent_ng_template_0_div_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 8);
    ɵɵtemplate(1, CalendarMonthCellComponent_ng_template_0_div_7_div_1_Template, 3, 32, "div", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r6 = ɵɵnextContext();
    const day_r1 = ctx_r6.day;
    const trackByEventId_r13 = ctx_r6.trackByEventId;
    ɵɵadvance();
    ɵɵproperty("ngForOf", day_r1.events)("ngForTrackBy", trackByEventId_r13);
  }
}
function CalendarMonthCellComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 2);
    ɵɵpipe(1, "calendarA11y");
    ɵɵelementStart(2, "span", 3);
    ɵɵtemplate(3, CalendarMonthCellComponent_ng_template_0_span_3_Template, 2, 1, "span", 4);
    ɵɵelementStart(4, "span", 5);
    ɵɵtext(5);
    ɵɵpipe(6, "calendarDate");
    ɵɵelementEnd()()();
    ɵɵtemplate(7, CalendarMonthCellComponent_ng_template_0_div_7_Template, 2, 2, "div", 6);
  }
  if (rf & 2) {
    const day_r1 = ctx.day;
    const locale_r14 = ctx.locale;
    ɵɵattribute("aria-label", ɵɵpipeBind2(1, 4, ɵɵpureFunction2(11, _c6, day_r1, locale_r14), "monthCell"));
    ɵɵadvance(3);
    ɵɵproperty("ngIf", day_r1.badgeTotal > 0);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ɵɵpipeBind3(6, 7, day_r1.date, "monthViewDayNumber", locale_r14));
    ɵɵadvance(2);
    ɵɵproperty("ngIf", day_r1.events.length > 0);
  }
}
function CalendarMonthCellComponent_ng_template_2_Template(rf, ctx) {
}
var _c11 = (a0, a1, a2, a3, a4) => ({
  events: a0,
  eventClicked: a1,
  isOpen: a2,
  trackByEventId: a3,
  validateDrag: a4
});
var _c122 = (a0, a1) => ({
  date: a0,
  locale: a1
});
var _c13 = (a0) => ({
  event: a0
});
var _c14 = (a0, a1) => ({
  event: a0,
  locale: a1
});
function CalendarOpenDayEventsComponent_ng_template_0_div_0_div_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 7);
    ɵɵelement(1, "span", 8);
    ɵɵtext(2, " ");
    ɵɵelementStart(3, "mwl-calendar-event-title", 9);
    ɵɵpipe(4, "calendarA11y");
    ɵɵlistener("mwlClick", function CalendarOpenDayEventsComponent_ng_template_0_div_0_div_5_Template_mwl_calendar_event_title_mwlClick_3_listener($event) {
      const event_r2 = ɵɵrestoreView(_r1).$implicit;
      const eventClicked_r3 = ɵɵnextContext(2).eventClicked;
      return ɵɵresetView(eventClicked_r3.emit({
        event: event_r2,
        sourceEvent: $event
      }));
    })("mwlKeydownEnter", function CalendarOpenDayEventsComponent_ng_template_0_div_0_div_5_Template_mwl_calendar_event_title_mwlKeydownEnter_3_listener($event) {
      const event_r2 = ɵɵrestoreView(_r1).$implicit;
      const eventClicked_r3 = ɵɵnextContext(2).eventClicked;
      return ɵɵresetView(eventClicked_r3.emit({
        event: event_r2,
        sourceEvent: $event
      }));
    });
    ɵɵelementEnd();
    ɵɵtext(5, " ");
    ɵɵelement(6, "mwl-calendar-event-actions", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const event_r2 = ctx.$implicit;
    const validateDrag_r4 = ɵɵnextContext(2).validateDrag;
    const ctx_r4 = ɵɵnextContext();
    ɵɵclassProp("cal-draggable", event_r2.draggable);
    ɵɵproperty("ngClass", event_r2 == null ? null : event_r2.cssClass)("dropData", ɵɵpureFunction1(16, _c13, event_r2))("dragAxis", ɵɵpureFunction2(18, _c9, event_r2.draggable, event_r2.draggable))("validateDrag", validateDrag_r4)("touchStartLongPress", ɵɵpureFunction0(21, _c10));
    ɵɵadvance();
    ɵɵproperty("ngStyle", ɵɵpureFunction1(22, _c7, event_r2.color == null ? null : event_r2.color.primary));
    ɵɵadvance(2);
    ɵɵproperty("event", event_r2)("customTemplate", ctx_r4.eventTitleTemplate);
    ɵɵattribute("aria-label", ɵɵpipeBind2(4, 13, ɵɵpureFunction2(24, _c14, event_r2, ctx_r4.locale), "eventDescription"));
    ɵɵadvance(3);
    ɵɵproperty("event", event_r2)("customTemplate", ctx_r4.eventActionsTemplate);
  }
}
function CalendarOpenDayEventsComponent_ng_template_0_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 3);
    ɵɵelement(1, "span", 4);
    ɵɵpipe(2, "calendarA11y");
    ɵɵelement(3, "span", 5);
    ɵɵpipe(4, "calendarA11y");
    ɵɵtemplate(5, CalendarOpenDayEventsComponent_ng_template_0_div_0_div_5_Template, 7, 27, "div", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    const events_r7 = ctx_r5.events;
    const trackByEventId_r8 = ctx_r5.trackByEventId;
    const ctx_r4 = ɵɵnextContext();
    ɵɵproperty("@collapse", void 0);
    ɵɵadvance();
    ɵɵattribute("aria-label", ɵɵpipeBind2(2, 5, ɵɵpureFunction2(11, _c122, ctx_r4.date, ctx_r4.locale), "openDayEventsAlert"));
    ɵɵadvance(2);
    ɵɵattribute("aria-label", ɵɵpipeBind2(4, 8, ɵɵpureFunction2(14, _c122, ctx_r4.date, ctx_r4.locale), "openDayEventsLandmark"));
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", events_r7)("ngForTrackBy", trackByEventId_r8);
  }
}
function CalendarOpenDayEventsComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, CalendarOpenDayEventsComponent_ng_template_0_div_0_Template, 6, 17, "div", 2);
  }
  if (rf & 2) {
    const isOpen_r9 = ctx.isOpen;
    ɵɵproperty("ngIf", isOpen_r9);
  }
}
function CalendarOpenDayEventsComponent_ng_template_2_Template(rf, ctx) {
}
var _c15 = (a0, a1, a2) => ({
  days: a0,
  locale: a1,
  trackByWeekDayHeaderDate: a2
});
function CalendarMonthViewHeaderComponent_ng_template_0_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 4);
    ɵɵlistener("click", function CalendarMonthViewHeaderComponent_ng_template_0_div_1_Template_div_click_0_listener($event) {
      const day_r2 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.columnHeaderClicked.emit({
        isoDayNumber: day_r2.day,
        sourceEvent: $event
      }));
    });
    ɵɵtext(1);
    ɵɵpipe(2, "calendarDate");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const day_r2 = ctx.$implicit;
    const locale_r4 = ɵɵnextContext().locale;
    ɵɵclassProp("cal-past", day_r2.isPast)("cal-today", day_r2.isToday)("cal-future", day_r2.isFuture)("cal-weekend", day_r2.isWeekend);
    ɵɵproperty("ngClass", day_r2.cssClass);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind3(2, 10, day_r2.date, "monthViewColumnHeader", locale_r4), " ");
  }
}
function CalendarMonthViewHeaderComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 2);
    ɵɵtemplate(1, CalendarMonthViewHeaderComponent_ng_template_0_div_1_Template, 3, 14, "div", 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const days_r5 = ctx.days;
    const trackByWeekDayHeaderDate_r6 = ctx.trackByWeekDayHeaderDate;
    ɵɵadvance();
    ɵɵproperty("ngForOf", days_r5)("ngForTrackBy", trackByWeekDayHeaderDate_r6);
  }
}
function CalendarMonthViewHeaderComponent_ng_template_2_Template(rf, ctx) {
}
function CalendarMonthViewComponent_div_3_mwl_calendar_month_cell_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mwl-calendar-month-cell", 7);
    ɵɵpipe(1, "calendarA11y");
    ɵɵlistener("mwlClick", function CalendarMonthViewComponent_div_3_mwl_calendar_month_cell_2_Template_mwl_calendar_month_cell_mwlClick_0_listener($event) {
      const day_r3 = ɵɵrestoreView(_r2).$implicit;
      const ctx_r3 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r3.dayClicked.emit({
        day: day_r3,
        sourceEvent: $event
      }));
    })("mwlKeydownEnter", function CalendarMonthViewComponent_div_3_mwl_calendar_month_cell_2_Template_mwl_calendar_month_cell_mwlKeydownEnter_0_listener($event) {
      const day_r3 = ɵɵrestoreView(_r2).$implicit;
      const ctx_r3 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r3.dayClicked.emit({
        day: day_r3,
        sourceEvent: $event
      }));
    })("highlightDay", function CalendarMonthViewComponent_div_3_mwl_calendar_month_cell_2_Template_mwl_calendar_month_cell_highlightDay_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r3 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r3.toggleDayHighlight($event.event, true));
    })("unhighlightDay", function CalendarMonthViewComponent_div_3_mwl_calendar_month_cell_2_Template_mwl_calendar_month_cell_unhighlightDay_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r3 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r3.toggleDayHighlight($event.event, false));
    })("drop", function CalendarMonthViewComponent_div_3_mwl_calendar_month_cell_2_Template_mwl_calendar_month_cell_drop_0_listener($event) {
      const day_r3 = ɵɵrestoreView(_r2).$implicit;
      const ctx_r3 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r3.eventDropped(day_r3, $event.dropData.event, $event.dropData.draggedFrom));
    })("eventClicked", function CalendarMonthViewComponent_div_3_mwl_calendar_month_cell_2_Template_mwl_calendar_month_cell_eventClicked_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r3 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r3.eventClicked.emit({
        event: $event.event,
        sourceEvent: $event.sourceEvent
      }));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const day_r3 = ctx.$implicit;
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵproperty("ngClass", day_r3 == null ? null : day_r3.cssClass)("day", day_r3)("openDay", ctx_r3.openDay)("locale", ctx_r3.locale)("tooltipPlacement", ctx_r3.tooltipPlacement)("tooltipAppendToBody", ctx_r3.tooltipAppendToBody)("tooltipTemplate", ctx_r3.tooltipTemplate)("tooltipDelay", ctx_r3.tooltipDelay)("customTemplate", ctx_r3.cellTemplate)("ngStyle", ɵɵpureFunction1(15, _c7, day_r3.backgroundColor))("clickListenerDisabled", ctx_r3.dayClicked.observers.length === 0);
    ɵɵattribute("tabindex", ɵɵpipeBind2(1, 12, ɵɵpureFunction0(17, _c3), "monthCellTabIndex"));
  }
}
function CalendarMonthViewComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div")(1, "div", 4);
    ɵɵtemplate(2, CalendarMonthViewComponent_div_3_mwl_calendar_month_cell_2_Template, 2, 18, "mwl-calendar-month-cell", 5);
    ɵɵpipe(3, "slice");
    ɵɵelementEnd();
    ɵɵelementStart(4, "mwl-calendar-open-day-events", 6);
    ɵɵlistener("eventClicked", function CalendarMonthViewComponent_div_3_Template_mwl_calendar_open_day_events_eventClicked_4_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.eventClicked.emit({
        event: $event.event,
        sourceEvent: $event.sourceEvent
      }));
    })("drop", function CalendarMonthViewComponent_div_3_Template_mwl_calendar_open_day_events_drop_4_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.eventDropped(ctx_r3.openDay, $event.dropData.event, $event.dropData.draggedFrom));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const rowIndex_r5 = ctx.$implicit;
    const ctx_r3 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ɵɵpipeBind3(3, 9, ctx_r3.view.days, rowIndex_r5, rowIndex_r5 + ctx_r3.view.totalDaysVisibleInWeek))("ngForTrackBy", ctx_r3.trackByDate);
    ɵɵadvance(2);
    ɵɵproperty("locale", ctx_r3.locale)("isOpen", ctx_r3.openRowIndex === rowIndex_r5)("events", ctx_r3.openDay == null ? null : ctx_r3.openDay.events)("date", ctx_r3.openDay == null ? null : ctx_r3.openDay.date)("customTemplate", ctx_r3.openDayEventsTemplate)("eventTitleTemplate", ctx_r3.eventTitleTemplate)("eventActionsTemplate", ctx_r3.eventActionsTemplate);
  }
}
var _c16 = (a0, a1, a2, a3, a4, a5) => ({
  days: a0,
  locale: a1,
  dayHeaderClicked: a2,
  eventDropped: a3,
  dragEnter: a4,
  trackByWeekDayHeaderDate: a5
});
function CalendarWeekViewHeaderComponent_ng_template_0_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 4);
    ɵɵlistener("mwlClick", function CalendarWeekViewHeaderComponent_ng_template_0_div_1_Template_div_mwlClick_0_listener($event) {
      const day_r2 = ɵɵrestoreView(_r1).$implicit;
      const dayHeaderClicked_r3 = ɵɵnextContext().dayHeaderClicked;
      return ɵɵresetView(dayHeaderClicked_r3.emit({
        day: day_r2,
        sourceEvent: $event
      }));
    })("drop", function CalendarWeekViewHeaderComponent_ng_template_0_div_1_Template_div_drop_0_listener($event) {
      const day_r2 = ɵɵrestoreView(_r1).$implicit;
      const eventDropped_r4 = ɵɵnextContext().eventDropped;
      return ɵɵresetView(eventDropped_r4.emit({
        event: $event.dropData.event,
        newStart: day_r2.date
      }));
    })("dragEnter", function CalendarWeekViewHeaderComponent_ng_template_0_div_1_Template_div_dragEnter_0_listener() {
      const day_r2 = ɵɵrestoreView(_r1).$implicit;
      const dragEnter_r5 = ɵɵnextContext().dragEnter;
      return ɵɵresetView(dragEnter_r5.emit({
        date: day_r2.date
      }));
    });
    ɵɵelementStart(1, "b");
    ɵɵtext(2);
    ɵɵpipe(3, "calendarDate");
    ɵɵelementEnd();
    ɵɵelement(4, "br");
    ɵɵelementStart(5, "span");
    ɵɵtext(6);
    ɵɵpipe(7, "calendarDate");
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const day_r2 = ctx.$implicit;
    const locale_r6 = ɵɵnextContext().locale;
    ɵɵclassProp("cal-past", day_r2.isPast)("cal-today", day_r2.isToday)("cal-future", day_r2.isFuture)("cal-weekend", day_r2.isWeekend);
    ɵɵproperty("ngClass", day_r2.cssClass);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ɵɵpipeBind3(3, 11, day_r2.date, "weekViewColumnHeader", locale_r6));
    ɵɵadvance(4);
    ɵɵtextInterpolate(ɵɵpipeBind3(7, 15, day_r2.date, "weekViewColumnSubHeader", locale_r6));
  }
}
function CalendarWeekViewHeaderComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 2);
    ɵɵtemplate(1, CalendarWeekViewHeaderComponent_ng_template_0_div_1_Template, 8, 19, "div", 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const days_r7 = ctx.days;
    const trackByWeekDayHeaderDate_r8 = ctx.trackByWeekDayHeaderDate;
    ɵɵadvance();
    ɵɵproperty("ngForOf", days_r7)("ngForTrackBy", trackByWeekDayHeaderDate_r8);
  }
}
function CalendarWeekViewHeaderComponent_ng_template_2_Template(rf, ctx) {
}
var _c17 = (a0, a1, a2, a3, a4, a5, a6, a7, a8) => ({
  weekEvent: a0,
  tooltipPlacement: a1,
  eventClicked: a2,
  tooltipTemplate: a3,
  tooltipAppendToBody: a4,
  tooltipDisabled: a5,
  tooltipDelay: a6,
  column: a7,
  daysInWeek: a8
});
var _c18 = (a0, a1, a2) => ({
  color: a0,
  backgroundColor: a1,
  borderColor: a2
});
function CalendarWeekViewEventComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 2);
    ɵɵpipe(1, "calendarEventTitle");
    ɵɵpipe(2, "calendarA11y");
    ɵɵlistener("mwlClick", function CalendarWeekViewEventComponent_ng_template_0_Template_div_mwlClick_0_listener($event) {
      const eventClicked_r2 = ɵɵrestoreView(_r1).eventClicked;
      return ɵɵresetView(eventClicked_r2.emit({
        sourceEvent: $event
      }));
    })("mwlKeydownEnter", function CalendarWeekViewEventComponent_ng_template_0_Template_div_mwlKeydownEnter_0_listener($event) {
      const eventClicked_r2 = ɵɵrestoreView(_r1).eventClicked;
      return ɵɵresetView(eventClicked_r2.emit({
        sourceEvent: $event
      }));
    });
    ɵɵelement(3, "mwl-calendar-event-actions", 3);
    ɵɵtext(4, " ");
    ɵɵelement(5, "mwl-calendar-event-title", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const weekEvent_r3 = ctx.weekEvent;
    const tooltipPlacement_r4 = ctx.tooltipPlacement;
    const tooltipTemplate_r5 = ctx.tooltipTemplate;
    const tooltipAppendToBody_r6 = ctx.tooltipAppendToBody;
    const tooltipDisabled_r7 = ctx.tooltipDisabled;
    const tooltipDelay_r8 = ctx.tooltipDelay;
    const daysInWeek_r9 = ctx.daysInWeek;
    const ctx_r9 = ɵɵnextContext();
    ɵɵproperty("ngStyle", ɵɵpureFunction3(20, _c18, weekEvent_r3.event.color == null ? null : weekEvent_r3.event.color.secondaryText, weekEvent_r3.event.color == null ? null : weekEvent_r3.event.color.secondary, weekEvent_r3.event.color == null ? null : weekEvent_r3.event.color.primary))("mwlCalendarTooltip", !tooltipDisabled_r7 ? ɵɵpipeBind3(1, 13, weekEvent_r3.event.title, daysInWeek_r9 === 1 ? "dayTooltip" : "weekTooltip", weekEvent_r3.tempEvent || weekEvent_r3.event) : "")("tooltipPlacement", tooltipPlacement_r4)("tooltipEvent", weekEvent_r3.tempEvent || weekEvent_r3.event)("tooltipTemplate", tooltipTemplate_r5)("tooltipAppendToBody", tooltipAppendToBody_r6)("tooltipDelay", tooltipDelay_r8);
    ɵɵattribute("aria-label", ɵɵpipeBind2(2, 17, ɵɵpureFunction2(24, _c14, weekEvent_r3.tempEvent || weekEvent_r3.event, ctx_r9.locale), "eventDescription"));
    ɵɵadvance(3);
    ɵɵproperty("event", weekEvent_r3.tempEvent || weekEvent_r3.event)("customTemplate", ctx_r9.eventActionsTemplate);
    ɵɵadvance(2);
    ɵɵproperty("event", weekEvent_r3.tempEvent || weekEvent_r3.event)("customTemplate", ctx_r9.eventTitleTemplate)("view", daysInWeek_r9 === 1 ? "day" : "week");
  }
}
function CalendarWeekViewEventComponent_ng_template_2_Template(rf, ctx) {
}
var _c19 = (a0, a1, a2, a3, a4) => ({
  segment: a0,
  locale: a1,
  segmentHeight: a2,
  isTimeLabel: a3,
  daysInWeek: a4
});
function CalendarWeekViewHourSegmentComponent_ng_template_0_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 4);
    ɵɵtext(1);
    ɵɵpipe(2, "calendarDate");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    const segment_r2 = ctx_r0.segment;
    const locale_r3 = ctx_r0.locale;
    const daysInWeek_r4 = ctx_r0.daysInWeek;
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind3(2, 1, segment_r2.displayDate, daysInWeek_r4 === 1 ? "dayViewHour" : "weekViewHour", locale_r3), " ");
  }
}
function CalendarWeekViewHourSegmentComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 2);
    ɵɵpipe(1, "calendarA11y");
    ɵɵtemplate(2, CalendarWeekViewHourSegmentComponent_ng_template_0_div_2_Template, 3, 5, "div", 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const segment_r2 = ctx.segment;
    const segmentHeight_r5 = ctx.segmentHeight;
    const isTimeLabel_r6 = ctx.isTimeLabel;
    const daysInWeek_r4 = ctx.daysInWeek;
    ɵɵstyleProp("height", segmentHeight_r5, "px");
    ɵɵclassProp("cal-hour-start", segment_r2.isStart)("cal-after-hour-start", !segment_r2.isStart);
    ɵɵproperty("ngClass", segment_r2.cssClass);
    ɵɵattribute("aria-hidden", ɵɵpipeBind2(1, 9, ɵɵpureFunction0(12, _c3), daysInWeek_r4 === 1 ? "hideDayHourSegment" : "hideWeekHourSegment"));
    ɵɵadvance(2);
    ɵɵproperty("ngIf", isTimeLabel_r6);
  }
}
function CalendarWeekViewHourSegmentComponent_ng_template_2_Template(rf, ctx) {
}
var _c20 = (a0, a1, a2, a3, a4, a5, a6) => ({
  columnDate: a0,
  dayStartHour: a1,
  dayStartMinute: a2,
  dayEndHour: a3,
  dayEndMinute: a4,
  isVisible: a5,
  topPx: a6
});
function CalendarWeekViewCurrentTimeMarkerComponent_ng_template_0_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 3);
  }
  if (rf & 2) {
    const topPx_r1 = ɵɵnextContext().topPx;
    ɵɵstyleProp("top", topPx_r1, "px");
  }
}
function CalendarWeekViewCurrentTimeMarkerComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, CalendarWeekViewCurrentTimeMarkerComponent_ng_template_0_div_0_Template, 1, 2, "div", 2);
  }
  if (rf & 2) {
    const isVisible_r2 = ctx.isVisible;
    ɵɵproperty("ngIf", isVisible_r2);
  }
}
function CalendarWeekViewCurrentTimeMarkerComponent_ng_template_2_Template(rf, ctx) {
}
var _c21 = (a0, a1) => ({
  left: a0,
  right: a1
});
var _c22 = (a0, a1) => ({
  event: a0,
  calendarId: a1
});
var _c23 = (a0) => ({
  x: a0
});
var _c24 = () => ({
  left: true
});
var _c25 = () => ({
  right: true
});
var _c26 = (a0, a1, a2, a3) => ({
  left: a0,
  right: a1,
  top: a2,
  bottom: a3
});
var _c27 = () => ({
  left: true,
  top: true
});
var _c28 = () => ({
  right: true,
  bottom: true
});
function CalendarWeekViewComponent_div_2_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function CalendarWeekViewComponent_div_2_div_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 17);
    ɵɵlistener("drop", function CalendarWeekViewComponent_div_2_div_5_Template_div_drop_0_listener($event) {
      const day_r5 = ɵɵrestoreView(_r4).$implicit;
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.eventDropped($event, day_r5.date, true));
    })("dragEnter", function CalendarWeekViewComponent_div_2_div_5_Template_div_dragEnter_0_listener() {
      const day_r5 = ɵɵrestoreView(_r4).$implicit;
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.dateDragEnter(day_r5.date));
    });
    ɵɵelementEnd();
  }
}
function CalendarWeekViewComponent_div_2_div_6_div_2_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 24);
  }
  if (rf & 2) {
    ɵɵproperty("resizeEdges", ɵɵpureFunction0(1, _c24));
  }
}
function CalendarWeekViewComponent_div_2_div_6_div_2_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 25);
  }
  if (rf & 2) {
    ɵɵproperty("resizeEdges", ɵɵpureFunction0(1, _c25));
  }
}
function CalendarWeekViewComponent_div_2_div_6_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 20, 3);
    ɵɵlistener("resizeStart", function CalendarWeekViewComponent_div_2_div_6_div_2_Template_div_resizeStart_0_listener($event) {
      const allDayEvent_r7 = ɵɵrestoreView(_r6).$implicit;
      ɵɵnextContext();
      const eventRowContainer_r8 = ɵɵreference(1);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.allDayEventResizeStarted(eventRowContainer_r8, allDayEvent_r7, $event));
    })("resizing", function CalendarWeekViewComponent_div_2_div_6_div_2_Template_div_resizing_0_listener($event) {
      const allDayEvent_r7 = ɵɵrestoreView(_r6).$implicit;
      const ctx_r2 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r2.allDayEventResizing(allDayEvent_r7, $event, ctx_r2.dayColumnWidth));
    })("resizeEnd", function CalendarWeekViewComponent_div_2_div_6_div_2_Template_div_resizeEnd_0_listener() {
      const allDayEvent_r7 = ɵɵrestoreView(_r6).$implicit;
      const ctx_r2 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r2.allDayEventResizeEnded(allDayEvent_r7));
    })("dragStart", function CalendarWeekViewComponent_div_2_div_6_div_2_Template_div_dragStart_0_listener() {
      const allDayEvent_r7 = ɵɵrestoreView(_r6).$implicit;
      const event_r9 = ɵɵreference(1);
      ɵɵnextContext();
      const eventRowContainer_r8 = ɵɵreference(1);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.dragStarted(eventRowContainer_r8, event_r9, allDayEvent_r7, false));
    })("dragging", function CalendarWeekViewComponent_div_2_div_6_div_2_Template_div_dragging_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r2 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r2.allDayEventDragMove());
    })("dragEnd", function CalendarWeekViewComponent_div_2_div_6_div_2_Template_div_dragEnd_0_listener($event) {
      const allDayEvent_r7 = ɵɵrestoreView(_r6).$implicit;
      const ctx_r2 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r2.dragEnded(allDayEvent_r7, $event, ctx_r2.dayColumnWidth));
    });
    ɵɵtemplate(2, CalendarWeekViewComponent_div_2_div_6_div_2_div_2_Template, 1, 2, "div", 21);
    ɵɵelementStart(3, "mwl-calendar-week-view-event", 22);
    ɵɵlistener("eventClicked", function CalendarWeekViewComponent_div_2_div_6_div_2_Template_mwl_calendar_week_view_event_eventClicked_3_listener($event) {
      const allDayEvent_r7 = ɵɵrestoreView(_r6).$implicit;
      const ctx_r2 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r2.eventClicked.emit({
        event: allDayEvent_r7.event,
        sourceEvent: $event.sourceEvent
      }));
    });
    ɵɵelementEnd();
    ɵɵtemplate(4, CalendarWeekViewComponent_div_2_div_6_div_2_div_4_Template, 1, 2, "div", 23);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const allDayEvent_r7 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext(3);
    ɵɵstyleProp("width", 100 / ctx_r2.days.length * allDayEvent_r7.span, "%")("margin-left", ctx_r2.rtl ? null : 100 / ctx_r2.days.length * allDayEvent_r7.offset, "%")("margin-right", ctx_r2.rtl ? 100 / ctx_r2.days.length * allDayEvent_r7.offset : null, "%");
    ɵɵclassProp("cal-draggable", allDayEvent_r7.event.draggable && ctx_r2.allDayEventResizes.size === 0)("cal-starts-within-week", !allDayEvent_r7.startsBeforeWeek)("cal-ends-within-week", !allDayEvent_r7.endsAfterWeek);
    ɵɵproperty("ngClass", allDayEvent_r7.event == null ? null : allDayEvent_r7.event.cssClass)("resizeCursors", ctx_r2.resizeCursors)("resizeSnapGrid", ɵɵpureFunction2(33, _c21, ctx_r2.dayColumnWidth, ctx_r2.dayColumnWidth))("validateResize", ctx_r2.validateResize)("dropData", ɵɵpureFunction2(36, _c22, allDayEvent_r7.event, ctx_r2.calendarId))("dragAxis", ɵɵpureFunction2(39, _c9, allDayEvent_r7.event.draggable && ctx_r2.allDayEventResizes.size === 0, !ctx_r2.snapDraggedEvents && allDayEvent_r7.event.draggable && ctx_r2.allDayEventResizes.size === 0))("dragSnapGrid", ctx_r2.snapDraggedEvents ? ɵɵpureFunction1(42, _c23, ctx_r2.dayColumnWidth) : ɵɵpureFunction0(44, _c3))("validateDrag", ctx_r2.validateDrag)("touchStartLongPress", ɵɵpureFunction0(45, _c10));
    ɵɵadvance(2);
    ɵɵproperty("ngIf", (allDayEvent_r7.event == null ? null : allDayEvent_r7.event.resizable == null ? null : allDayEvent_r7.event.resizable.beforeStart) && !allDayEvent_r7.startsBeforeWeek);
    ɵɵadvance();
    ɵɵproperty("locale", ctx_r2.locale)("weekEvent", allDayEvent_r7)("tooltipPlacement", ctx_r2.tooltipPlacement)("tooltipTemplate", ctx_r2.tooltipTemplate)("tooltipAppendToBody", ctx_r2.tooltipAppendToBody)("tooltipDelay", ctx_r2.tooltipDelay)("customTemplate", ctx_r2.eventTemplate)("eventTitleTemplate", ctx_r2.eventTitleTemplate)("eventActionsTemplate", ctx_r2.eventActionsTemplate)("daysInWeek", ctx_r2.daysInWeek);
    ɵɵadvance();
    ɵɵproperty("ngIf", (allDayEvent_r7.event == null ? null : allDayEvent_r7.event.resizable == null ? null : allDayEvent_r7.event.resizable.afterEnd) && !allDayEvent_r7.endsAfterWeek);
  }
}
function CalendarWeekViewComponent_div_2_div_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 18, 2);
    ɵɵtemplate(2, CalendarWeekViewComponent_div_2_div_6_div_2_Template, 5, 46, "div", 19);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const eventRow_r10 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", eventRow_r10.row)("ngForTrackBy", ctx_r2.trackByWeekAllDayEvent);
  }
}
function CalendarWeekViewComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 12, 1);
    ɵɵlistener("dragEnter", function CalendarWeekViewComponent_div_2_Template_div_dragEnter_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.dragEnter("allDay"));
    })("dragLeave", function CalendarWeekViewComponent_div_2_Template_div_dragLeave_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.dragLeave("allDay"));
    });
    ɵɵelementStart(2, "div", 10)(3, "div", 13);
    ɵɵtemplate(4, CalendarWeekViewComponent_div_2_ng_container_4_Template, 1, 0, "ng-container", 14);
    ɵɵelementEnd();
    ɵɵtemplate(5, CalendarWeekViewComponent_div_2_div_5_Template, 1, 0, "div", 15);
    ɵɵelementEnd();
    ɵɵtemplate(6, CalendarWeekViewComponent_div_2_div_6_Template, 3, 2, "div", 16);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance(4);
    ɵɵproperty("ngTemplateOutlet", ctx_r2.allDayEventsLabelTemplate);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2.days)("ngForTrackBy", ctx_r2.trackByWeekDayHeaderDate);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2.view.allDayEventRows)("ngForTrackBy", ctx_r2.trackById);
  }
}
function CalendarWeekViewComponent_div_4_div_1_mwl_calendar_week_view_hour_segment_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "mwl-calendar-week-view-hour-segment", 29);
  }
  if (rf & 2) {
    const segment_r11 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext(3);
    ɵɵstyleProp("height", ctx_r2.hourSegmentHeight, "px");
    ɵɵproperty("segment", segment_r11)("segmentHeight", ctx_r2.hourSegmentHeight)("locale", ctx_r2.locale)("customTemplate", ctx_r2.hourSegmentTemplate)("isTimeLabel", true)("daysInWeek", ctx_r2.daysInWeek);
  }
}
function CalendarWeekViewComponent_div_4_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 27);
    ɵɵtemplate(1, CalendarWeekViewComponent_div_4_div_1_mwl_calendar_week_view_hour_segment_1_Template, 1, 8, "mwl-calendar-week-view-hour-segment", 28);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const hour_r12 = ctx.$implicit;
    const odd_r13 = ctx.odd;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵclassProp("cal-hour-odd", odd_r13);
    ɵɵadvance();
    ɵɵproperty("ngForOf", hour_r12.segments)("ngForTrackBy", ctx_r2.trackByHourSegment);
  }
}
function CalendarWeekViewComponent_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 13);
    ɵɵtemplate(1, CalendarWeekViewComponent_div_4_div_1_Template, 2, 4, "div", 26);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2.view.hourColumns[0].hours)("ngForTrackBy", ctx_r2.trackByHour);
  }
}
function CalendarWeekViewComponent_div_7_div_3_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 24);
  }
  if (rf & 2) {
    ɵɵproperty("resizeEdges", ɵɵpureFunction0(1, _c27));
  }
}
function CalendarWeekViewComponent_div_7_div_3_ng_template_3_Template(rf, ctx) {
}
function CalendarWeekViewComponent_div_7_div_3_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r18 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mwl-calendar-week-view-event", 36);
    ɵɵlistener("eventClicked", function CalendarWeekViewComponent_div_7_div_3_ng_template_4_Template_mwl_calendar_week_view_event_eventClicked_0_listener($event) {
      ɵɵrestoreView(_r18);
      const timeEvent_r15 = ɵɵnextContext().$implicit;
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.eventClicked.emit({
        event: timeEvent_r15.event,
        sourceEvent: $event.sourceEvent
      }));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const timeEvent_r15 = ɵɵnextContext().$implicit;
    const column_r19 = ɵɵnextContext().$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("locale", ctx_r2.locale)("weekEvent", timeEvent_r15)("tooltipPlacement", ctx_r2.tooltipPlacement)("tooltipTemplate", ctx_r2.tooltipTemplate)("tooltipAppendToBody", ctx_r2.tooltipAppendToBody)("tooltipDisabled", ctx_r2.dragActive || ctx_r2.timeEventResizes.size > 0)("tooltipDelay", ctx_r2.tooltipDelay)("customTemplate", ctx_r2.eventTemplate)("eventTitleTemplate", ctx_r2.eventTitleTemplate)("eventActionsTemplate", ctx_r2.eventActionsTemplate)("column", column_r19)("daysInWeek", ctx_r2.daysInWeek);
  }
}
function CalendarWeekViewComponent_div_7_div_3_div_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 25);
  }
  if (rf & 2) {
    ɵɵproperty("resizeEdges", ɵɵpureFunction0(1, _c28));
  }
}
function CalendarWeekViewComponent_div_7_div_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r14 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 34, 3);
    ɵɵlistener("resizeStart", function CalendarWeekViewComponent_div_7_div_3_Template_div_resizeStart_0_listener($event) {
      const timeEvent_r15 = ɵɵrestoreView(_r14).$implicit;
      const ctx_r2 = ɵɵnextContext(2);
      const dayColumns_r16 = ɵɵreference(6);
      return ɵɵresetView(ctx_r2.timeEventResizeStarted(dayColumns_r16, timeEvent_r15, $event));
    })("resizing", function CalendarWeekViewComponent_div_7_div_3_Template_div_resizing_0_listener($event) {
      const timeEvent_r15 = ɵɵrestoreView(_r14).$implicit;
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.timeEventResizing(timeEvent_r15, $event));
    })("resizeEnd", function CalendarWeekViewComponent_div_7_div_3_Template_div_resizeEnd_0_listener() {
      const timeEvent_r15 = ɵɵrestoreView(_r14).$implicit;
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.timeEventResizeEnded(timeEvent_r15));
    })("dragStart", function CalendarWeekViewComponent_div_7_div_3_Template_div_dragStart_0_listener() {
      const timeEvent_r15 = ɵɵrestoreView(_r14).$implicit;
      const event_r17 = ɵɵreference(1);
      const ctx_r2 = ɵɵnextContext(2);
      const dayColumns_r16 = ɵɵreference(6);
      return ɵɵresetView(ctx_r2.dragStarted(dayColumns_r16, event_r17, timeEvent_r15, true));
    })("dragging", function CalendarWeekViewComponent_div_7_div_3_Template_div_dragging_0_listener($event) {
      const timeEvent_r15 = ɵɵrestoreView(_r14).$implicit;
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.dragMove(timeEvent_r15, $event));
    })("dragEnd", function CalendarWeekViewComponent_div_7_div_3_Template_div_dragEnd_0_listener($event) {
      const timeEvent_r15 = ɵɵrestoreView(_r14).$implicit;
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.dragEnded(timeEvent_r15, $event, ctx_r2.dayColumnWidth, true));
    });
    ɵɵtemplate(2, CalendarWeekViewComponent_div_7_div_3_div_2_Template, 1, 2, "div", 21)(3, CalendarWeekViewComponent_div_7_div_3_ng_template_3_Template, 0, 0, "ng-template", 35)(4, CalendarWeekViewComponent_div_7_div_3_ng_template_4_Template, 1, 12, "ng-template", null, 4, ɵɵtemplateRefExtractor)(6, CalendarWeekViewComponent_div_7_div_3_div_6_Template, 1, 2, "div", 23);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const timeEvent_r15 = ctx.$implicit;
    const weekEventTemplate_r20 = ɵɵreference(5);
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵstyleProp("top", timeEvent_r15.top, "px")("height", timeEvent_r15.height, "px")("left", timeEvent_r15.left, "%")("width", timeEvent_r15.width, "%");
    ɵɵclassProp("cal-draggable", timeEvent_r15.event.draggable && ctx_r2.timeEventResizes.size === 0)("cal-starts-within-day", !timeEvent_r15.startsBeforeDay)("cal-ends-within-day", !timeEvent_r15.endsAfterDay);
    ɵɵproperty("ngClass", timeEvent_r15.event.cssClass)("hidden", timeEvent_r15.height === 0 && timeEvent_r15.width === 0)("resizeCursors", ctx_r2.resizeCursors)("resizeSnapGrid", ɵɵpureFunction4(30, _c26, ctx_r2.dayColumnWidth, ctx_r2.dayColumnWidth, ctx_r2.eventSnapSize || ctx_r2.hourSegmentHeight, ctx_r2.eventSnapSize || ctx_r2.hourSegmentHeight))("validateResize", ctx_r2.validateResize)("allowNegativeResizes", true)("dropData", ɵɵpureFunction2(35, _c22, timeEvent_r15.event, ctx_r2.calendarId))("dragAxis", ɵɵpureFunction2(38, _c9, timeEvent_r15.event.draggable && ctx_r2.timeEventResizes.size === 0, timeEvent_r15.event.draggable && ctx_r2.timeEventResizes.size === 0))("dragSnapGrid", ctx_r2.snapDraggedEvents ? ɵɵpureFunction2(41, _c9, ctx_r2.dayColumnWidth, ctx_r2.eventSnapSize || ctx_r2.hourSegmentHeight) : ɵɵpureFunction0(44, _c3))("touchStartLongPress", ɵɵpureFunction0(45, _c10))("ghostDragEnabled", !ctx_r2.snapDraggedEvents)("ghostElementTemplate", weekEventTemplate_r20)("validateDrag", ctx_r2.validateDrag);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", (timeEvent_r15.event == null ? null : timeEvent_r15.event.resizable == null ? null : timeEvent_r15.event.resizable.beforeStart) && !timeEvent_r15.startsBeforeDay);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", weekEventTemplate_r20);
    ɵɵadvance(3);
    ɵɵproperty("ngIf", (timeEvent_r15.event == null ? null : timeEvent_r15.event.resizable == null ? null : timeEvent_r15.event.resizable.afterEnd) && !timeEvent_r15.endsAfterDay);
  }
}
function CalendarWeekViewComponent_div_7_div_4_mwl_calendar_week_view_hour_segment_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r21 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mwl-calendar-week-view-hour-segment", 38);
    ɵɵlistener("mwlClick", function CalendarWeekViewComponent_div_7_div_4_mwl_calendar_week_view_hour_segment_1_Template_mwl_calendar_week_view_hour_segment_mwlClick_0_listener($event) {
      const segment_r22 = ɵɵrestoreView(_r21).$implicit;
      const ctx_r2 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r2.hourSegmentClicked.emit({
        date: segment_r22.date,
        sourceEvent: $event
      }));
    })("drop", function CalendarWeekViewComponent_div_7_div_4_mwl_calendar_week_view_hour_segment_1_Template_mwl_calendar_week_view_hour_segment_drop_0_listener($event) {
      const segment_r22 = ɵɵrestoreView(_r21).$implicit;
      const ctx_r2 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r2.eventDropped($event, segment_r22.date, false));
    })("dragEnter", function CalendarWeekViewComponent_div_7_div_4_mwl_calendar_week_view_hour_segment_1_Template_mwl_calendar_week_view_hour_segment_dragEnter_0_listener() {
      const segment_r22 = ɵɵrestoreView(_r21).$implicit;
      const ctx_r2 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r2.dateDragEnter(segment_r22.date));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const segment_r22 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext(3);
    ɵɵstyleProp("height", ctx_r2.hourSegmentHeight, "px");
    ɵɵproperty("segment", segment_r22)("segmentHeight", ctx_r2.hourSegmentHeight)("locale", ctx_r2.locale)("customTemplate", ctx_r2.hourSegmentTemplate)("daysInWeek", ctx_r2.daysInWeek)("clickListenerDisabled", ctx_r2.hourSegmentClicked.observers.length === 0)("dragOverClass", !ctx_r2.dragActive || !ctx_r2.snapDraggedEvents ? "cal-drag-over" : null)("isTimeLabel", ctx_r2.daysInWeek === 1);
  }
}
function CalendarWeekViewComponent_div_7_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 27);
    ɵɵtemplate(1, CalendarWeekViewComponent_div_7_div_4_mwl_calendar_week_view_hour_segment_1_Template, 1, 10, "mwl-calendar-week-view-hour-segment", 37);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const hour_r23 = ctx.$implicit;
    const odd_r24 = ctx.odd;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵclassProp("cal-hour-odd", odd_r24);
    ɵɵadvance();
    ɵɵproperty("ngForOf", hour_r23.segments)("ngForTrackBy", ctx_r2.trackByHourSegment);
  }
}
function CalendarWeekViewComponent_div_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 30);
    ɵɵelement(1, "mwl-calendar-week-view-current-time-marker", 31);
    ɵɵelementStart(2, "div", 32);
    ɵɵtemplate(3, CalendarWeekViewComponent_div_7_div_3_Template, 7, 46, "div", 33);
    ɵɵelementEnd();
    ɵɵtemplate(4, CalendarWeekViewComponent_div_7_div_4_Template, 2, 4, "div", 26);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r19 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("columnDate", column_r19.date)("dayStartHour", ctx_r2.dayStartHour)("dayStartMinute", ctx_r2.dayStartMinute)("dayEndHour", ctx_r2.dayEndHour)("dayEndMinute", ctx_r2.dayEndMinute)("hourSegments", ctx_r2.hourSegments)("hourDuration", ctx_r2.hourDuration)("hourSegmentHeight", ctx_r2.hourSegmentHeight)("customTemplate", ctx_r2.currentTimeMarkerTemplate);
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", column_r19.events)("ngForTrackBy", ctx_r2.trackByWeekTimeEvent);
    ɵɵadvance();
    ɵɵproperty("ngForOf", column_r19.hours)("ngForTrackBy", ctx_r2.trackByHour);
  }
}
var ClickDirective = class {
  constructor(renderer, elm, document2) {
    this.renderer = renderer;
    this.elm = elm;
    this.document = document2;
    this.clickListenerDisabled = false;
    this.click = new EventEmitter();
    this.destroy$ = new Subject();
  }
  ngOnInit() {
    if (!this.clickListenerDisabled) {
      this.listen().pipe(takeUntil(this.destroy$)).subscribe((event) => {
        event.stopPropagation();
        this.click.emit(event);
      });
    }
  }
  ngOnDestroy() {
    this.destroy$.next();
  }
  listen() {
    return new Observable((observer) => {
      return this.renderer.listen(this.elm.nativeElement, "click", (event) => {
        observer.next(event);
      });
    });
  }
};
ClickDirective.ɵfac = function ClickDirective_Factory(t) {
  return new (t || ClickDirective)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(DOCUMENT));
};
ClickDirective.ɵdir = ɵɵdefineDirective({
  type: ClickDirective,
  selectors: [["", "mwlClick", ""]],
  inputs: {
    clickListenerDisabled: "clickListenerDisabled"
  },
  outputs: {
    click: "mwlClick"
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClickDirective, [{
    type: Directive,
    args: [{
      selector: "[mwlClick]"
    }]
  }], function() {
    return [{
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [DOCUMENT]
      }]
    }];
  }, {
    clickListenerDisabled: [{
      type: Input
    }],
    click: [{
      type: Output,
      args: ["mwlClick"]
    }]
  });
})();
var KeydownEnterDirective = class {
  constructor(host, ngZone, renderer) {
    this.host = host;
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.keydown = new EventEmitter();
    this.keydownListener = null;
  }
  ngOnInit() {
    this.ngZone.runOutsideAngular(() => {
      this.keydownListener = this.renderer.listen(this.host.nativeElement, "keydown", (event) => {
        if (event.keyCode === 13 || event.which === 13 || event.key === "Enter") {
          event.preventDefault();
          event.stopPropagation();
          this.ngZone.run(() => {
            this.keydown.emit(event);
          });
        }
      });
    });
  }
  ngOnDestroy() {
    if (this.keydownListener !== null) {
      this.keydownListener();
      this.keydownListener = null;
    }
  }
};
KeydownEnterDirective.ɵfac = function KeydownEnterDirective_Factory(t) {
  return new (t || KeydownEnterDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2));
};
KeydownEnterDirective.ɵdir = ɵɵdefineDirective({
  type: KeydownEnterDirective,
  selectors: [["", "mwlKeydownEnter", ""]],
  outputs: {
    keydown: "mwlKeydownEnter"
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(KeydownEnterDirective, [{
    type: Directive,
    args: [{
      selector: "[mwlKeydownEnter]"
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }];
  }, {
    keydown: [{
      type: Output,
      args: ["mwlKeydownEnter"]
    }]
  });
})();
var CalendarA11y = class {
  constructor(i18nPlural) {
    this.i18nPlural = i18nPlural;
  }
  /**
   * Aria label for the badges/date of a cell
   * @example: `Saturday October 19 1 event click to expand`
   */
  monthCell({
    day,
    locale
  }) {
    if (day.badgeTotal > 0) {
      return `
        ${formatDate(day.date, "EEEE MMMM d", locale)},
        ${this.i18nPlural.transform(day.badgeTotal, {
        "=0": "No events",
        "=1": "One event",
        other: "# events"
      })},
         click to expand
      `;
    } else {
      return `${formatDate(day.date, "EEEE MMMM d", locale)}`;
    }
  }
  /**
   * Aria label for the open day events start landmark
   * @example: `Saturday October 19 expanded view`
   */
  openDayEventsLandmark({
    date,
    locale
  }) {
    return `
      Beginning of expanded view for ${formatDate(date, "EEEE MMMM dd", locale)}
    `;
  }
  /**
   * Aria label for alert that a day in the month view was expanded
   * @example: `Saturday October 19 expanded`
   */
  openDayEventsAlert({
    date,
    locale
  }) {
    return `${formatDate(date, "EEEE MMMM dd", locale)} expanded`;
  }
  /**
   * Descriptive aria label for an event
   * @example: `Saturday October 19th, Scott's Pizza Party, from 11:00am to 5:00pm`
   */
  eventDescription({
    event,
    locale
  }) {
    if (event.allDay === true) {
      return this.allDayEventDescription({
        event,
        locale
      });
    }
    const aria = `
      ${formatDate(event.start, "EEEE MMMM dd", locale)},
      ${event.title}, from ${formatDate(event.start, "hh:mm a", locale)}
    `;
    if (event.end) {
      return aria + ` to ${formatDate(event.end, "hh:mm a", locale)}`;
    }
    return aria;
  }
  /**
   * Descriptive aria label for an all day event
   * @example:
   * `Scott's Party, event spans multiple days: start time October 19 5:00pm, no stop time`
   */
  allDayEventDescription({
    event,
    locale
  }) {
    const aria = `
      ${event.title}, event spans multiple days:
      start time ${formatDate(event.start, "MMMM dd hh:mm a", locale)}
    `;
    if (event.end) {
      return aria + `, stop time ${formatDate(event.end, "MMMM d hh:mm a", locale)}`;
    }
    return aria + `, no stop time`;
  }
  /**
   * Aria label for the calendar event actions icons
   * @returns 'Edit' for fa-pencil icons, and 'Delete' for fa-times icons
   */
  actionButtonLabel({
    action
  }) {
    return action.a11yLabel;
  }
  /**
   * @returns {number} Tab index to be given to month cells
   */
  monthCellTabIndex() {
    return 0;
  }
  /**
   * @returns true if the events inside the month cell should be aria-hidden
   */
  hideMonthCellEvents() {
    return true;
  }
  /**
   * @returns true if event titles should be aria-hidden (global)
   */
  hideEventTitle() {
    return true;
  }
  /**
   * @returns true if hour segments in the week view should be aria-hidden
   */
  hideWeekHourSegment() {
    return true;
  }
  /**
   * @returns true if hour segments in the day view should be aria-hidden
   */
  hideDayHourSegment() {
    return true;
  }
};
CalendarA11y.ɵfac = function CalendarA11y_Factory(t) {
  return new (t || CalendarA11y)(ɵɵinject(I18nPluralPipe));
};
CalendarA11y.ɵprov = ɵɵdefineInjectable({
  token: CalendarA11y,
  factory: CalendarA11y.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarA11y, [{
    type: Injectable
  }], function() {
    return [{
      type: I18nPluralPipe
    }];
  }, null);
})();
var CalendarA11yPipe = class {
  constructor(calendarA11y, locale) {
    this.calendarA11y = calendarA11y;
    this.locale = locale;
  }
  transform(a11yParams, method) {
    a11yParams.locale = a11yParams.locale || this.locale;
    if (typeof this.calendarA11y[method] === "undefined") {
      const allowedMethods = Object.getOwnPropertyNames(Object.getPrototypeOf(CalendarA11y.prototype)).filter((iMethod) => iMethod !== "constructor");
      throw new Error(`${method} is not a valid a11y method. Can only be one of ${allowedMethods.join(", ")}`);
    }
    return this.calendarA11y[method](a11yParams);
  }
};
CalendarA11yPipe.ɵfac = function CalendarA11yPipe_Factory(t) {
  return new (t || CalendarA11yPipe)(ɵɵdirectiveInject(CalendarA11y, 16), ɵɵdirectiveInject(LOCALE_ID, 16));
};
CalendarA11yPipe.ɵpipe = ɵɵdefinePipe({
  name: "calendarA11y",
  type: CalendarA11yPipe,
  pure: true
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarA11yPipe, [{
    type: Pipe,
    args: [{
      name: "calendarA11y"
    }]
  }], function() {
    return [{
      type: CalendarA11y
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [LOCALE_ID]
      }]
    }];
  }, null);
})();
var CalendarEventActionsComponent = class {
  constructor() {
    this.trackByActionId = (index, action) => action.id ? action.id : action;
  }
};
CalendarEventActionsComponent.ɵfac = function CalendarEventActionsComponent_Factory(t) {
  return new (t || CalendarEventActionsComponent)();
};
CalendarEventActionsComponent.ɵcmp = ɵɵdefineComponent({
  type: CalendarEventActionsComponent,
  selectors: [["mwl-calendar-event-actions"]],
  inputs: {
    event: "event",
    customTemplate: "customTemplate"
  },
  decls: 3,
  vars: 5,
  consts: [["defaultTemplate", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["class", "cal-event-actions", 4, "ngIf"], [1, "cal-event-actions"], ["class", "cal-event-action", "href", "javascript:;", "tabindex", "0", "role", "button", 3, "ngClass", "innerHtml", "mwlClick", "mwlKeydownEnter", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["href", "javascript:;", "tabindex", "0", "role", "button", 1, "cal-event-action", 3, "mwlClick", "mwlKeydownEnter", "ngClass", "innerHtml"]],
  template: function CalendarEventActionsComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, CalendarEventActionsComponent_ng_template_0_Template, 1, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor)(2, CalendarEventActionsComponent_ng_template_2_Template, 0, 0, "ng-template", 1);
    }
    if (rf & 2) {
      const defaultTemplate_r6 = ɵɵreference(1);
      ɵɵadvance(2);
      ɵɵproperty("ngTemplateOutlet", ctx.customTemplate || defaultTemplate_r6)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c02, ctx.event, ctx.trackByActionId));
    }
  },
  dependencies: [NgClass, NgForOf, NgIf, NgTemplateOutlet, ClickDirective, KeydownEnterDirective, CalendarA11yPipe],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarEventActionsComponent, [{
    type: Component,
    args: [{
      selector: "mwl-calendar-event-actions",
      template: `
    <ng-template
      #defaultTemplate
      let-event="event"
      let-trackByActionId="trackByActionId"
    >
      <span *ngIf="event.actions" class="cal-event-actions">
        <a
          class="cal-event-action"
          href="javascript:;"
          *ngFor="let action of event.actions; trackBy: trackByActionId"
          (mwlClick)="action.onClick({ event: event, sourceEvent: $event })"
          (mwlKeydownEnter)="
            action.onClick({ event: event, sourceEvent: $event })
          "
          [ngClass]="action.cssClass"
          [innerHtml]="action.label"
          tabindex="0"
          role="button"
          [attr.aria-label]="
            { action: action } | calendarA11y : 'actionButtonLabel'
          "
        >
        </a>
      </span>
    </ng-template>
    <ng-template
      [ngTemplateOutlet]="customTemplate || defaultTemplate"
      [ngTemplateOutletContext]="{
        event: event,
        trackByActionId: trackByActionId
      }"
    >
    </ng-template>
  `
    }]
  }], null, {
    event: [{
      type: Input
    }],
    customTemplate: [{
      type: Input
    }]
  });
})();
var CalendarEventTitleFormatter = class {
  /**
   * The month view event title.
   */
  month(event, title) {
    return event.title;
  }
  /**
   * The month view event tooltip. Return a falsey value from this to disable the tooltip.
   */
  monthTooltip(event, title) {
    return event.title;
  }
  /**
   * The week view event title.
   */
  week(event, title) {
    return event.title;
  }
  /**
   * The week view event tooltip. Return a falsey value from this to disable the tooltip.
   */
  weekTooltip(event, title) {
    return event.title;
  }
  /**
   * The day view event title.
   */
  day(event, title) {
    return event.title;
  }
  /**
   * The day view event tooltip. Return a falsey value from this to disable the tooltip.
   */
  dayTooltip(event, title) {
    return event.title;
  }
};
var CalendarEventTitlePipe = class {
  constructor(calendarEventTitle) {
    this.calendarEventTitle = calendarEventTitle;
  }
  transform(title, titleType, event) {
    return this.calendarEventTitle[titleType](event, title);
  }
};
CalendarEventTitlePipe.ɵfac = function CalendarEventTitlePipe_Factory(t) {
  return new (t || CalendarEventTitlePipe)(ɵɵdirectiveInject(CalendarEventTitleFormatter, 16));
};
CalendarEventTitlePipe.ɵpipe = ɵɵdefinePipe({
  name: "calendarEventTitle",
  type: CalendarEventTitlePipe,
  pure: true
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarEventTitlePipe, [{
    type: Pipe,
    args: [{
      name: "calendarEventTitle"
    }]
  }], function() {
    return [{
      type: CalendarEventTitleFormatter
    }];
  }, null);
})();
var CalendarEventTitleComponent = class {
};
CalendarEventTitleComponent.ɵfac = function CalendarEventTitleComponent_Factory(t) {
  return new (t || CalendarEventTitleComponent)();
};
CalendarEventTitleComponent.ɵcmp = ɵɵdefineComponent({
  type: CalendarEventTitleComponent,
  selectors: [["mwl-calendar-event-title"]],
  inputs: {
    event: "event",
    customTemplate: "customTemplate",
    view: "view"
  },
  decls: 3,
  vars: 5,
  consts: [["defaultTemplate", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "cal-event-title", 3, "innerHTML"]],
  template: function CalendarEventTitleComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, CalendarEventTitleComponent_ng_template_0_Template, 3, 10, "ng-template", null, 0, ɵɵtemplateRefExtractor)(2, CalendarEventTitleComponent_ng_template_2_Template, 0, 0, "ng-template", 1);
    }
    if (rf & 2) {
      const defaultTemplate_r3 = ɵɵreference(1);
      ɵɵadvance(2);
      ɵɵproperty("ngTemplateOutlet", ctx.customTemplate || defaultTemplate_r3)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c2, ctx.event, ctx.view));
    }
  },
  dependencies: [NgTemplateOutlet, CalendarEventTitlePipe, CalendarA11yPipe],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarEventTitleComponent, [{
    type: Component,
    args: [{
      selector: "mwl-calendar-event-title",
      template: `
    <ng-template #defaultTemplate let-event="event" let-view="view">
      <span
        class="cal-event-title"
        [innerHTML]="event.title | calendarEventTitle : view : event"
        [attr.aria-hidden]="{} | calendarA11y : 'hideEventTitle'"
      >
      </span>
    </ng-template>
    <ng-template
      [ngTemplateOutlet]="customTemplate || defaultTemplate"
      [ngTemplateOutletContext]="{
        event: event,
        view: view
      }"
    >
    </ng-template>
  `
    }]
  }], null, {
    event: [{
      type: Input
    }],
    customTemplate: [{
      type: Input
    }],
    view: [{
      type: Input
    }]
  });
})();
var CalendarTooltipWindowComponent = class {
};
CalendarTooltipWindowComponent.ɵfac = function CalendarTooltipWindowComponent_Factory(t) {
  return new (t || CalendarTooltipWindowComponent)();
};
CalendarTooltipWindowComponent.ɵcmp = ɵɵdefineComponent({
  type: CalendarTooltipWindowComponent,
  selectors: [["mwl-calendar-tooltip-window"]],
  inputs: {
    contents: "contents",
    placement: "placement",
    event: "event",
    customTemplate: "customTemplate"
  },
  decls: 3,
  vars: 6,
  consts: [["defaultTemplate", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "cal-tooltip", 3, "ngClass"], [1, "cal-tooltip-arrow"], [1, "cal-tooltip-inner", 3, "innerHtml"]],
  template: function CalendarTooltipWindowComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, CalendarTooltipWindowComponent_ng_template_0_Template, 3, 2, "ng-template", null, 0, ɵɵtemplateRefExtractor)(2, CalendarTooltipWindowComponent_ng_template_2_Template, 0, 0, "ng-template", 1);
    }
    if (rf & 2) {
      const defaultTemplate_r3 = ɵɵreference(1);
      ɵɵadvance(2);
      ɵɵproperty("ngTemplateOutlet", ctx.customTemplate || defaultTemplate_r3)("ngTemplateOutletContext", ɵɵpureFunction3(2, _c4, ctx.contents, ctx.placement, ctx.event));
    }
  },
  dependencies: [NgClass, NgTemplateOutlet],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarTooltipWindowComponent, [{
    type: Component,
    args: [{
      selector: "mwl-calendar-tooltip-window",
      template: `
    <ng-template
      #defaultTemplate
      let-contents="contents"
      let-placement="placement"
      let-event="event"
    >
      <div class="cal-tooltip" [ngClass]="'cal-tooltip-' + placement">
        <div class="cal-tooltip-arrow"></div>
        <div class="cal-tooltip-inner" [innerHtml]="contents"></div>
      </div>
    </ng-template>
    <ng-template
      [ngTemplateOutlet]="customTemplate || defaultTemplate"
      [ngTemplateOutletContext]="{
        contents: contents,
        placement: placement,
        event: event
      }"
    >
    </ng-template>
  `
    }]
  }], null, {
    contents: [{
      type: Input
    }],
    placement: [{
      type: Input
    }],
    event: [{
      type: Input
    }],
    customTemplate: [{
      type: Input
    }]
  });
})();
var CalendarTooltipDirective = class {
  constructor(elementRef, injector, renderer, componentFactoryResolver, viewContainerRef, document2) {
    this.elementRef = elementRef;
    this.injector = injector;
    this.renderer = renderer;
    this.viewContainerRef = viewContainerRef;
    this.document = document2;
    this.placement = "auto";
    this.delay = null;
    this.cancelTooltipDelay$ = new Subject();
    this.tooltipFactory = componentFactoryResolver.resolveComponentFactory(CalendarTooltipWindowComponent);
  }
  ngOnChanges(changes) {
    if (this.tooltipRef && (changes.contents || changes.customTemplate || changes.event)) {
      this.tooltipRef.instance.contents = this.contents;
      this.tooltipRef.instance.customTemplate = this.customTemplate;
      this.tooltipRef.instance.event = this.event;
      this.tooltipRef.changeDetectorRef.markForCheck();
      if (!this.contents) {
        this.hide();
      }
    }
  }
  ngOnDestroy() {
    this.hide();
  }
  onMouseOver() {
    const delay$ = this.delay === null ? of("now") : timer(this.delay);
    delay$.pipe(takeUntil(this.cancelTooltipDelay$)).subscribe(() => {
      this.show();
    });
  }
  onMouseOut() {
    this.hide();
  }
  show() {
    if (!this.tooltipRef && this.contents) {
      this.tooltipRef = this.viewContainerRef.createComponent(this.tooltipFactory, 0, this.injector, []);
      this.tooltipRef.instance.contents = this.contents;
      this.tooltipRef.instance.customTemplate = this.customTemplate;
      this.tooltipRef.instance.event = this.event;
      if (this.appendToBody) {
        this.document.body.appendChild(this.tooltipRef.location.nativeElement);
      }
      requestAnimationFrame(() => {
        this.positionTooltip();
      });
    }
  }
  hide() {
    if (this.tooltipRef) {
      this.viewContainerRef.remove(this.viewContainerRef.indexOf(this.tooltipRef.hostView));
      this.tooltipRef = null;
    }
    this.cancelTooltipDelay$.next();
  }
  positionTooltip(previousPositions = []) {
    if (this.tooltipRef) {
      this.tooltipRef.changeDetectorRef.detectChanges();
      this.tooltipRef.instance.placement = positionElements(this.elementRef.nativeElement, this.tooltipRef.location.nativeElement.children[0], this.placement, this.appendToBody);
      if (previousPositions.indexOf(this.tooltipRef.instance.placement) === -1) {
        this.positionTooltip([...previousPositions, this.tooltipRef.instance.placement]);
      }
    }
  }
};
CalendarTooltipDirective.ɵfac = function CalendarTooltipDirective_Factory(t) {
  return new (t || CalendarTooltipDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ComponentFactoryResolver$1), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(DOCUMENT));
};
CalendarTooltipDirective.ɵdir = ɵɵdefineDirective({
  type: CalendarTooltipDirective,
  selectors: [["", "mwlCalendarTooltip", ""]],
  hostBindings: function CalendarTooltipDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("mouseenter", function CalendarTooltipDirective_mouseenter_HostBindingHandler() {
        return ctx.onMouseOver();
      })("mouseleave", function CalendarTooltipDirective_mouseleave_HostBindingHandler() {
        return ctx.onMouseOut();
      });
    }
  },
  inputs: {
    contents: [InputFlags.None, "mwlCalendarTooltip", "contents"],
    placement: [InputFlags.None, "tooltipPlacement", "placement"],
    customTemplate: [InputFlags.None, "tooltipTemplate", "customTemplate"],
    event: [InputFlags.None, "tooltipEvent", "event"],
    appendToBody: [InputFlags.None, "tooltipAppendToBody", "appendToBody"],
    delay: [InputFlags.None, "tooltipDelay", "delay"]
  },
  features: [ɵɵNgOnChangesFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarTooltipDirective, [{
    type: Directive,
    args: [{
      selector: "[mwlCalendarTooltip]"
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Injector
    }, {
      type: Renderer2
    }, {
      type: ComponentFactoryResolver$1
    }, {
      type: ViewContainerRef
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [DOCUMENT]
      }]
    }];
  }, {
    contents: [{
      type: Input,
      args: ["mwlCalendarTooltip"]
    }],
    placement: [{
      type: Input,
      args: ["tooltipPlacement"]
    }],
    customTemplate: [{
      type: Input,
      args: ["tooltipTemplate"]
    }],
    event: [{
      type: Input,
      args: ["tooltipEvent"]
    }],
    appendToBody: [{
      type: Input,
      args: ["tooltipAppendToBody"]
    }],
    delay: [{
      type: Input,
      args: ["tooltipDelay"]
    }],
    onMouseOver: [{
      type: HostListener,
      args: ["mouseenter"]
    }],
    onMouseOut: [{
      type: HostListener,
      args: ["mouseleave"]
    }]
  });
})();
var CalendarView;
(function(CalendarView2) {
  CalendarView2["Month"] = "month";
  CalendarView2["Week"] = "week";
  CalendarView2["Day"] = "day";
})(CalendarView || (CalendarView = {}));
var validateEvents2 = (events) => {
  const warn = (...args) => console.warn("angular-calendar", ...args);
  return validateEvents(events, warn);
};
function isInsideLeftAndRight(outer, inner) {
  return Math.floor(outer.left) <= Math.ceil(inner.left) && Math.floor(inner.left) <= Math.ceil(outer.right) && Math.floor(outer.left) <= Math.ceil(inner.right) && Math.floor(inner.right) <= Math.ceil(outer.right);
}
function isInsideTopAndBottom(outer, inner) {
  return Math.floor(outer.top) <= Math.ceil(inner.top) && Math.floor(inner.top) <= Math.ceil(outer.bottom) && Math.floor(outer.top) <= Math.ceil(inner.bottom) && Math.floor(inner.bottom) <= Math.ceil(outer.bottom);
}
function isInside(outer, inner) {
  return isInsideLeftAndRight(outer, inner) && isInsideTopAndBottom(outer, inner);
}
function roundToNearest(amount, precision) {
  return Math.round(amount / precision) * precision;
}
var trackByEventId = (index, event) => event.id ? event.id : event;
var trackByWeekDayHeaderDate = (index, day) => day.date.toISOString();
var trackByHourSegment = (index, segment) => segment.date.toISOString();
var trackByHour = (index, hour) => hour.segments[0].date.toISOString();
var trackByWeekAllDayEvent = (index, weekEvent) => weekEvent.event.id ? weekEvent.event.id : weekEvent.event;
var trackByWeekTimeEvent = (index, weekEvent) => weekEvent.event.id ? weekEvent.event.id : weekEvent.event;
var MINUTES_IN_HOUR2 = 60;
function getPixelAmountInMinutes(hourSegments, hourSegmentHeight, hourDuration) {
  return (hourDuration || MINUTES_IN_HOUR2) / (hourSegments * hourSegmentHeight);
}
function getMinutesMoved(movedY, hourSegments, hourSegmentHeight, eventSnapSize, hourDuration) {
  const draggedInPixelsSnapSize = roundToNearest(movedY, eventSnapSize || hourSegmentHeight);
  const pixelAmountInMinutes = getPixelAmountInMinutes(hourSegments, hourSegmentHeight, hourDuration);
  return draggedInPixelsSnapSize * pixelAmountInMinutes;
}
function getDefaultEventEnd(dateAdapter, event, minimumMinutes) {
  if (event.end) {
    return event.end;
  } else {
    return dateAdapter.addMinutes(event.start, minimumMinutes);
  }
}
function addDaysWithExclusions(dateAdapter, date, days, excluded) {
  let daysCounter = 0;
  let daysToAdd = 0;
  const changeDays = days < 0 ? dateAdapter.subDays : dateAdapter.addDays;
  let result = date;
  while (daysToAdd <= Math.abs(days)) {
    result = changeDays(date, daysCounter);
    const day = dateAdapter.getDay(result);
    if (excluded.indexOf(day) === -1) {
      daysToAdd++;
    }
    daysCounter++;
  }
  return result;
}
function isDraggedWithinPeriod(newStart, newEnd, period) {
  const end = newEnd || newStart;
  return period.start <= newStart && newStart <= period.end || period.start <= end && end <= period.end;
}
function shouldFireDroppedEvent(dropEvent, date, allDay, calendarId) {
  return dropEvent.dropData && dropEvent.dropData.event && (dropEvent.dropData.calendarId !== calendarId || dropEvent.dropData.event.allDay && !allDay || !dropEvent.dropData.event.allDay && allDay);
}
function getWeekViewPeriod(dateAdapter, viewDate, weekStartsOn, excluded = [], daysInWeek2) {
  let viewStart = daysInWeek2 ? dateAdapter.startOfDay(viewDate) : dateAdapter.startOfWeek(viewDate, {
    weekStartsOn
  });
  const endOfWeek2 = dateAdapter.endOfWeek(viewDate, {
    weekStartsOn
  });
  while (excluded.indexOf(dateAdapter.getDay(viewStart)) > -1 && viewStart < endOfWeek2) {
    viewStart = dateAdapter.addDays(viewStart, 1);
  }
  if (daysInWeek2) {
    const viewEnd = dateAdapter.endOfDay(addDaysWithExclusions(dateAdapter, viewStart, daysInWeek2 - 1, excluded));
    return {
      viewStart,
      viewEnd
    };
  } else {
    let viewEnd = endOfWeek2;
    while (excluded.indexOf(dateAdapter.getDay(viewEnd)) > -1 && viewEnd > viewStart) {
      viewEnd = dateAdapter.subDays(viewEnd, 1);
    }
    return {
      viewStart,
      viewEnd
    };
  }
}
function isWithinThreshold({
  x,
  y
}) {
  const DRAG_THRESHOLD = 1;
  return Math.abs(x) > DRAG_THRESHOLD || Math.abs(y) > DRAG_THRESHOLD;
}
var DateAdapter = class {
};
var CalendarPreviousViewDirective = class {
  constructor(dateAdapter) {
    this.dateAdapter = dateAdapter;
    this.excludeDays = [];
    this.viewDateChange = new EventEmitter();
  }
  /**
   * @hidden
   */
  onClick() {
    const subFn = {
      day: this.dateAdapter.subDays,
      week: this.dateAdapter.subWeeks,
      month: this.dateAdapter.subMonths
    }[this.view];
    if (this.view === CalendarView.Day) {
      this.viewDateChange.emit(addDaysWithExclusions(this.dateAdapter, this.viewDate, -1, this.excludeDays));
    } else if (this.view === CalendarView.Week && this.daysInWeek) {
      this.viewDateChange.emit(addDaysWithExclusions(this.dateAdapter, this.viewDate, -this.daysInWeek, this.excludeDays));
    } else {
      this.viewDateChange.emit(subFn(this.viewDate, 1));
    }
  }
};
CalendarPreviousViewDirective.ɵfac = function CalendarPreviousViewDirective_Factory(t) {
  return new (t || CalendarPreviousViewDirective)(ɵɵdirectiveInject(DateAdapter));
};
CalendarPreviousViewDirective.ɵdir = ɵɵdefineDirective({
  type: CalendarPreviousViewDirective,
  selectors: [["", "mwlCalendarPreviousView", ""]],
  hostBindings: function CalendarPreviousViewDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function CalendarPreviousViewDirective_click_HostBindingHandler() {
        return ctx.onClick();
      });
    }
  },
  inputs: {
    view: "view",
    viewDate: "viewDate",
    excludeDays: "excludeDays",
    daysInWeek: "daysInWeek"
  },
  outputs: {
    viewDateChange: "viewDateChange"
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarPreviousViewDirective, [{
    type: Directive,
    args: [{
      selector: "[mwlCalendarPreviousView]"
    }]
  }], function() {
    return [{
      type: DateAdapter
    }];
  }, {
    view: [{
      type: Input
    }],
    viewDate: [{
      type: Input
    }],
    excludeDays: [{
      type: Input
    }],
    daysInWeek: [{
      type: Input
    }],
    viewDateChange: [{
      type: Output
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var CalendarNextViewDirective = class {
  constructor(dateAdapter) {
    this.dateAdapter = dateAdapter;
    this.excludeDays = [];
    this.viewDateChange = new EventEmitter();
  }
  /**
   * @hidden
   */
  onClick() {
    const addFn = {
      day: this.dateAdapter.addDays,
      week: this.dateAdapter.addWeeks,
      month: this.dateAdapter.addMonths
    }[this.view];
    if (this.view === CalendarView.Day) {
      this.viewDateChange.emit(addDaysWithExclusions(this.dateAdapter, this.viewDate, 1, this.excludeDays));
    } else if (this.view === CalendarView.Week && this.daysInWeek) {
      this.viewDateChange.emit(addDaysWithExclusions(this.dateAdapter, this.viewDate, this.daysInWeek, this.excludeDays));
    } else {
      this.viewDateChange.emit(addFn(this.viewDate, 1));
    }
  }
};
CalendarNextViewDirective.ɵfac = function CalendarNextViewDirective_Factory(t) {
  return new (t || CalendarNextViewDirective)(ɵɵdirectiveInject(DateAdapter));
};
CalendarNextViewDirective.ɵdir = ɵɵdefineDirective({
  type: CalendarNextViewDirective,
  selectors: [["", "mwlCalendarNextView", ""]],
  hostBindings: function CalendarNextViewDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function CalendarNextViewDirective_click_HostBindingHandler() {
        return ctx.onClick();
      });
    }
  },
  inputs: {
    view: "view",
    viewDate: "viewDate",
    excludeDays: "excludeDays",
    daysInWeek: "daysInWeek"
  },
  outputs: {
    viewDateChange: "viewDateChange"
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarNextViewDirective, [{
    type: Directive,
    args: [{
      selector: "[mwlCalendarNextView]"
    }]
  }], function() {
    return [{
      type: DateAdapter
    }];
  }, {
    view: [{
      type: Input
    }],
    viewDate: [{
      type: Input
    }],
    excludeDays: [{
      type: Input
    }],
    daysInWeek: [{
      type: Input
    }],
    viewDateChange: [{
      type: Output
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var CalendarTodayDirective = class {
  constructor(dateAdapter) {
    this.dateAdapter = dateAdapter;
    this.viewDateChange = new EventEmitter();
  }
  /**
   * @hidden
   */
  onClick() {
    this.viewDateChange.emit(this.dateAdapter.startOfDay(/* @__PURE__ */ new Date()));
  }
};
CalendarTodayDirective.ɵfac = function CalendarTodayDirective_Factory(t) {
  return new (t || CalendarTodayDirective)(ɵɵdirectiveInject(DateAdapter));
};
CalendarTodayDirective.ɵdir = ɵɵdefineDirective({
  type: CalendarTodayDirective,
  selectors: [["", "mwlCalendarToday", ""]],
  hostBindings: function CalendarTodayDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function CalendarTodayDirective_click_HostBindingHandler() {
        return ctx.onClick();
      });
    }
  },
  inputs: {
    viewDate: "viewDate"
  },
  outputs: {
    viewDateChange: "viewDateChange"
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarTodayDirective, [{
    type: Directive,
    args: [{
      selector: "[mwlCalendarToday]"
    }]
  }], function() {
    return [{
      type: DateAdapter
    }];
  }, {
    viewDate: [{
      type: Input
    }],
    viewDateChange: [{
      type: Output
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var CalendarAngularDateFormatter = class {
  constructor(dateAdapter) {
    this.dateAdapter = dateAdapter;
  }
  /**
   * The month view header week day labels
   */
  monthViewColumnHeader({
    date,
    locale
  }) {
    return formatDate(date, "EEEE", locale);
  }
  /**
   * The month view cell day number
   */
  monthViewDayNumber({
    date,
    locale
  }) {
    return formatDate(date, "d", locale);
  }
  /**
   * The month view title
   */
  monthViewTitle({
    date,
    locale
  }) {
    return formatDate(date, "LLLL y", locale);
  }
  /**
   * The week view header week day labels
   */
  weekViewColumnHeader({
    date,
    locale
  }) {
    return formatDate(date, "EEEE", locale);
  }
  /**
   * The week view sub header day and month labels
   */
  weekViewColumnSubHeader({
    date,
    locale
  }) {
    return formatDate(date, "MMM d", locale);
  }
  /**
   * The week view title
   */
  weekViewTitle({
    date,
    locale,
    weekStartsOn,
    excludeDays,
    daysInWeek: daysInWeek2
  }) {
    const {
      viewStart,
      viewEnd
    } = getWeekViewPeriod(this.dateAdapter, date, weekStartsOn, excludeDays, daysInWeek2);
    const format2 = (dateToFormat, showYear) => formatDate(dateToFormat, "MMM d" + (showYear ? ", yyyy" : ""), locale);
    return `${format2(viewStart, viewStart.getUTCFullYear() !== viewEnd.getUTCFullYear())} - ${format2(viewEnd, true)}`;
  }
  /**
   * The time formatting down the left hand side of the week view
   */
  weekViewHour({
    date,
    locale
  }) {
    return formatDate(date, "h a", locale);
  }
  /**
   * The time formatting down the left hand side of the day view
   */
  dayViewHour({
    date,
    locale
  }) {
    return formatDate(date, "h a", locale);
  }
  /**
   * The day view title
   */
  dayViewTitle({
    date,
    locale
  }) {
    return formatDate(date, "EEEE, MMMM d, y", locale);
  }
};
CalendarAngularDateFormatter.ɵfac = function CalendarAngularDateFormatter_Factory(t) {
  return new (t || CalendarAngularDateFormatter)(ɵɵinject(DateAdapter));
};
CalendarAngularDateFormatter.ɵprov = ɵɵdefineInjectable({
  token: CalendarAngularDateFormatter,
  factory: CalendarAngularDateFormatter.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarAngularDateFormatter, [{
    type: Injectable
  }], function() {
    return [{
      type: DateAdapter
    }];
  }, null);
})();
var CalendarDateFormatter = class extends CalendarAngularDateFormatter {
};
CalendarDateFormatter.ɵfac = /* @__PURE__ */ (() => {
  let ɵCalendarDateFormatter_BaseFactory;
  return function CalendarDateFormatter_Factory(t) {
    return (ɵCalendarDateFormatter_BaseFactory || (ɵCalendarDateFormatter_BaseFactory = ɵɵgetInheritedFactory(CalendarDateFormatter)))(t || CalendarDateFormatter);
  };
})();
CalendarDateFormatter.ɵprov = ɵɵdefineInjectable({
  token: CalendarDateFormatter,
  factory: CalendarDateFormatter.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarDateFormatter, [{
    type: Injectable
  }], null, null);
})();
var CalendarDatePipe = class {
  constructor(dateFormatter, locale) {
    this.dateFormatter = dateFormatter;
    this.locale = locale;
  }
  transform(date, method, locale = this.locale, weekStartsOn = 0, excludeDays = [], daysInWeek2) {
    if (typeof this.dateFormatter[method] === "undefined") {
      const allowedMethods = Object.getOwnPropertyNames(Object.getPrototypeOf(CalendarDateFormatter.prototype)).filter((iMethod) => iMethod !== "constructor");
      throw new Error(`${method} is not a valid date formatter. Can only be one of ${allowedMethods.join(", ")}`);
    }
    return this.dateFormatter[method]({
      date,
      locale,
      weekStartsOn,
      excludeDays,
      daysInWeek: daysInWeek2
    });
  }
};
CalendarDatePipe.ɵfac = function CalendarDatePipe_Factory(t) {
  return new (t || CalendarDatePipe)(ɵɵdirectiveInject(CalendarDateFormatter, 16), ɵɵdirectiveInject(LOCALE_ID, 16));
};
CalendarDatePipe.ɵpipe = ɵɵdefinePipe({
  name: "calendarDate",
  type: CalendarDatePipe,
  pure: true
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarDatePipe, [{
    type: Pipe,
    args: [{
      name: "calendarDate"
    }]
  }], function() {
    return [{
      type: CalendarDateFormatter
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [LOCALE_ID]
      }]
    }];
  }, null);
})();
var CalendarUtils = class {
  constructor(dateAdapter) {
    this.dateAdapter = dateAdapter;
  }
  getMonthView(args) {
    return getMonthView(this.dateAdapter, args);
  }
  getWeekViewHeader(args) {
    return getWeekViewHeader(this.dateAdapter, args);
  }
  getWeekView(args) {
    return getWeekView(this.dateAdapter, args);
  }
};
CalendarUtils.ɵfac = function CalendarUtils_Factory(t) {
  return new (t || CalendarUtils)(ɵɵinject(DateAdapter));
};
CalendarUtils.ɵprov = ɵɵdefineInjectable({
  token: CalendarUtils,
  factory: CalendarUtils.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarUtils, [{
    type: Injectable
  }], function() {
    return [{
      type: DateAdapter
    }];
  }, null);
})();
var MOMENT = new InjectionToken("Moment");
var CalendarMomentDateFormatter = class {
  /**
   * @hidden
   */
  constructor(moment, dateAdapter) {
    this.moment = moment;
    this.dateAdapter = dateAdapter;
  }
  /**
   * The month view header week day labels
   */
  monthViewColumnHeader({
    date,
    locale
  }) {
    return this.moment(date).locale(locale).format("dddd");
  }
  /**
   * The month view cell day number
   */
  monthViewDayNumber({
    date,
    locale
  }) {
    return this.moment(date).locale(locale).format("D");
  }
  /**
   * The month view title
   */
  monthViewTitle({
    date,
    locale
  }) {
    return this.moment(date).locale(locale).format("MMMM YYYY");
  }
  /**
   * The week view header week day labels
   */
  weekViewColumnHeader({
    date,
    locale
  }) {
    return this.moment(date).locale(locale).format("dddd");
  }
  /**
   * The week view sub header day and month labels
   */
  weekViewColumnSubHeader({
    date,
    locale
  }) {
    return this.moment(date).locale(locale).format("MMM D");
  }
  /**
   * The week view title
   */
  weekViewTitle({
    date,
    locale,
    weekStartsOn,
    excludeDays,
    daysInWeek: daysInWeek2
  }) {
    const {
      viewStart,
      viewEnd
    } = getWeekViewPeriod(this.dateAdapter, date, weekStartsOn, excludeDays, daysInWeek2);
    const format2 = (dateToFormat, showYear) => this.moment(dateToFormat).locale(locale).format("MMM D" + (showYear ? ", YYYY" : ""));
    return `${format2(viewStart, viewStart.getUTCFullYear() !== viewEnd.getUTCFullYear())} - ${format2(viewEnd, true)}`;
  }
  /**
   * The time formatting down the left hand side of the week view
   */
  weekViewHour({
    date,
    locale
  }) {
    return this.moment(date).locale(locale).format("ha");
  }
  /**
   * The time formatting down the left hand side of the day view
   */
  dayViewHour({
    date,
    locale
  }) {
    return this.moment(date).locale(locale).format("ha");
  }
  /**
   * The day view title
   */
  dayViewTitle({
    date,
    locale
  }) {
    return this.moment(date).locale(locale).format("dddd, LL");
  }
  // LL = locale-dependent Month Day, Year
};
CalendarMomentDateFormatter.ɵfac = function CalendarMomentDateFormatter_Factory(t) {
  return new (t || CalendarMomentDateFormatter)(ɵɵinject(MOMENT), ɵɵinject(DateAdapter));
};
CalendarMomentDateFormatter.ɵprov = ɵɵdefineInjectable({
  token: CalendarMomentDateFormatter,
  factory: CalendarMomentDateFormatter.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarMomentDateFormatter, [{
    type: Injectable
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: [MOMENT]
      }]
    }, {
      type: DateAdapter
    }];
  }, null);
})();
var CalendarNativeDateFormatter = class {
  constructor(dateAdapter) {
    this.dateAdapter = dateAdapter;
  }
  /**
   * The month view header week day labels
   */
  monthViewColumnHeader({
    date,
    locale
  }) {
    return new Intl.DateTimeFormat(locale, {
      weekday: "long"
    }).format(date);
  }
  /**
   * The month view cell day number
   */
  monthViewDayNumber({
    date,
    locale
  }) {
    return new Intl.DateTimeFormat(locale, {
      day: "numeric"
    }).format(date);
  }
  /**
   * The month view title
   */
  monthViewTitle({
    date,
    locale
  }) {
    return new Intl.DateTimeFormat(locale, {
      year: "numeric",
      month: "long"
    }).format(date);
  }
  /**
   * The week view header week day labels
   */
  weekViewColumnHeader({
    date,
    locale
  }) {
    return new Intl.DateTimeFormat(locale, {
      weekday: "long"
    }).format(date);
  }
  /**
   * The week view sub header day and month labels
   */
  weekViewColumnSubHeader({
    date,
    locale
  }) {
    return new Intl.DateTimeFormat(locale, {
      day: "numeric",
      month: "short"
    }).format(date);
  }
  /**
   * The week view title
   */
  weekViewTitle({
    date,
    locale,
    weekStartsOn,
    excludeDays,
    daysInWeek: daysInWeek2
  }) {
    const {
      viewStart,
      viewEnd
    } = getWeekViewPeriod(this.dateAdapter, date, weekStartsOn, excludeDays, daysInWeek2);
    const format2 = (dateToFormat, showYear) => new Intl.DateTimeFormat(locale, {
      day: "numeric",
      month: "short",
      year: showYear ? "numeric" : void 0
    }).format(dateToFormat);
    return `${format2(viewStart, viewStart.getUTCFullYear() !== viewEnd.getUTCFullYear())} - ${format2(viewEnd, true)}`;
  }
  /**
   * The time formatting down the left hand side of the week view
   */
  weekViewHour({
    date,
    locale
  }) {
    return new Intl.DateTimeFormat(locale, {
      hour: "numeric"
    }).format(date);
  }
  /**
   * The time formatting down the left hand side of the day view
   */
  dayViewHour({
    date,
    locale
  }) {
    return new Intl.DateTimeFormat(locale, {
      hour: "numeric"
    }).format(date);
  }
  /**
   * The day view title
   */
  dayViewTitle({
    date,
    locale
  }) {
    return new Intl.DateTimeFormat(locale, {
      day: "numeric",
      month: "long",
      year: "numeric",
      weekday: "long"
    }).format(date);
  }
};
CalendarNativeDateFormatter.ɵfac = function CalendarNativeDateFormatter_Factory(t) {
  return new (t || CalendarNativeDateFormatter)(ɵɵinject(DateAdapter));
};
CalendarNativeDateFormatter.ɵprov = ɵɵdefineInjectable({
  token: CalendarNativeDateFormatter,
  factory: CalendarNativeDateFormatter.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarNativeDateFormatter, [{
    type: Injectable
  }], function() {
    return [{
      type: DateAdapter
    }];
  }, null);
})();
var CalendarEventTimesChangedEventType;
(function(CalendarEventTimesChangedEventType2) {
  CalendarEventTimesChangedEventType2["Drag"] = "drag";
  CalendarEventTimesChangedEventType2["Drop"] = "drop";
  CalendarEventTimesChangedEventType2["Resize"] = "resize";
})(CalendarEventTimesChangedEventType || (CalendarEventTimesChangedEventType = {}));
var CalendarCommonModule = class _CalendarCommonModule {
  static forRoot(dateAdapter, config = {}) {
    return {
      ngModule: _CalendarCommonModule,
      providers: [dateAdapter, config.eventTitleFormatter || CalendarEventTitleFormatter, config.dateFormatter || CalendarDateFormatter, config.utils || CalendarUtils, config.a11y || CalendarA11y]
    };
  }
};
CalendarCommonModule.ɵfac = function CalendarCommonModule_Factory(t) {
  return new (t || CalendarCommonModule)();
};
CalendarCommonModule.ɵmod = ɵɵdefineNgModule({
  type: CalendarCommonModule,
  declarations: [CalendarEventActionsComponent, CalendarEventTitleComponent, CalendarTooltipWindowComponent, CalendarTooltipDirective, CalendarPreviousViewDirective, CalendarNextViewDirective, CalendarTodayDirective, CalendarDatePipe, CalendarEventTitlePipe, CalendarA11yPipe, ClickDirective, KeydownEnterDirective],
  imports: [CommonModule],
  exports: [CalendarEventActionsComponent, CalendarEventTitleComponent, CalendarTooltipWindowComponent, CalendarTooltipDirective, CalendarPreviousViewDirective, CalendarNextViewDirective, CalendarTodayDirective, CalendarDatePipe, CalendarEventTitlePipe, CalendarA11yPipe, ClickDirective, KeydownEnterDirective]
});
CalendarCommonModule.ɵinj = ɵɵdefineInjector({
  providers: [I18nPluralPipe],
  imports: [CommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarCommonModule, [{
    type: NgModule,
    args: [{
      declarations: [CalendarEventActionsComponent, CalendarEventTitleComponent, CalendarTooltipWindowComponent, CalendarTooltipDirective, CalendarPreviousViewDirective, CalendarNextViewDirective, CalendarTodayDirective, CalendarDatePipe, CalendarEventTitlePipe, CalendarA11yPipe, ClickDirective, KeydownEnterDirective],
      imports: [CommonModule],
      exports: [CalendarEventActionsComponent, CalendarEventTitleComponent, CalendarTooltipWindowComponent, CalendarTooltipDirective, CalendarPreviousViewDirective, CalendarNextViewDirective, CalendarTodayDirective, CalendarDatePipe, CalendarEventTitlePipe, CalendarA11yPipe, ClickDirective, KeydownEnterDirective],
      providers: [I18nPluralPipe]
    }]
  }], null, null);
})();
var CalendarMonthCellComponent = class {
  constructor() {
    this.highlightDay = new EventEmitter();
    this.unhighlightDay = new EventEmitter();
    this.eventClicked = new EventEmitter();
    this.trackByEventId = trackByEventId;
    this.validateDrag = isWithinThreshold;
  }
};
CalendarMonthCellComponent.ɵfac = function CalendarMonthCellComponent_Factory(t) {
  return new (t || CalendarMonthCellComponent)();
};
CalendarMonthCellComponent.ɵcmp = ɵɵdefineComponent({
  type: CalendarMonthCellComponent,
  selectors: [["mwl-calendar-month-cell"]],
  hostAttrs: [1, "cal-cell", "cal-day-cell"],
  hostVars: 18,
  hostBindings: function CalendarMonthCellComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cal-past", ctx.day.isPast)("cal-today", ctx.day.isToday)("cal-future", ctx.day.isFuture)("cal-weekend", ctx.day.isWeekend)("cal-in-month", ctx.day.inMonth)("cal-out-month", !ctx.day.inMonth)("cal-has-events", ctx.day.events.length > 0)("cal-open", ctx.day === ctx.openDay)("cal-event-highlight", !!ctx.day.backgroundColor);
    }
  },
  inputs: {
    day: "day",
    openDay: "openDay",
    locale: "locale",
    tooltipPlacement: "tooltipPlacement",
    tooltipAppendToBody: "tooltipAppendToBody",
    customTemplate: "customTemplate",
    tooltipTemplate: "tooltipTemplate",
    tooltipDelay: "tooltipDelay"
  },
  outputs: {
    highlightDay: "highlightDay",
    unhighlightDay: "unhighlightDay",
    eventClicked: "eventClicked"
  },
  decls: 3,
  vars: 15,
  consts: [["defaultTemplate", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "cal-cell-top"], ["aria-hidden", "true"], ["class", "cal-day-badge", 4, "ngIf"], [1, "cal-day-number"], ["class", "cal-events", 4, "ngIf"], [1, "cal-day-badge"], [1, "cal-events"], ["class", "cal-event", "mwlDraggable", "", "dragActiveClass", "cal-drag-active", 3, "ngStyle", "ngClass", "mwlCalendarTooltip", "tooltipPlacement", "tooltipEvent", "tooltipTemplate", "tooltipAppendToBody", "tooltipDelay", "cal-draggable", "dropData", "dragAxis", "validateDrag", "touchStartLongPress", "mouseenter", "mouseleave", "mwlClick", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["mwlDraggable", "", "dragActiveClass", "cal-drag-active", 1, "cal-event", 3, "mouseenter", "mouseleave", "mwlClick", "ngStyle", "ngClass", "mwlCalendarTooltip", "tooltipPlacement", "tooltipEvent", "tooltipTemplate", "tooltipAppendToBody", "tooltipDelay", "dropData", "dragAxis", "validateDrag", "touchStartLongPress"]],
  template: function CalendarMonthCellComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, CalendarMonthCellComponent_ng_template_0_Template, 8, 14, "ng-template", null, 0, ɵɵtemplateRefExtractor)(2, CalendarMonthCellComponent_ng_template_2_Template, 0, 0, "ng-template", 1);
    }
    if (rf & 2) {
      const defaultTemplate_r15 = ɵɵreference(1);
      ɵɵadvance(2);
      ɵɵproperty("ngTemplateOutlet", ctx.customTemplate || defaultTemplate_r15)("ngTemplateOutletContext", ɵɵpureFunctionV(2, _c5, [ctx.day, ctx.openDay, ctx.locale, ctx.tooltipPlacement, ctx.highlightDay, ctx.unhighlightDay, ctx.eventClicked, ctx.tooltipTemplate, ctx.tooltipAppendToBody, ctx.tooltipDelay, ctx.trackByEventId, ctx.validateDrag]));
    }
  },
  dependencies: [NgClass, NgForOf, NgIf, NgTemplateOutlet, NgStyle, DraggableDirective, CalendarTooltipDirective, ClickDirective, CalendarDatePipe, CalendarEventTitlePipe, CalendarA11yPipe],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarMonthCellComponent, [{
    type: Component,
    args: [{
      selector: "mwl-calendar-month-cell",
      template: `
    <ng-template
      #defaultTemplate
      let-day="day"
      let-openDay="openDay"
      let-locale="locale"
      let-tooltipPlacement="tooltipPlacement"
      let-highlightDay="highlightDay"
      let-unhighlightDay="unhighlightDay"
      let-eventClicked="eventClicked"
      let-tooltipTemplate="tooltipTemplate"
      let-tooltipAppendToBody="tooltipAppendToBody"
      let-tooltipDelay="tooltipDelay"
      let-trackByEventId="trackByEventId"
      let-validateDrag="validateDrag"
    >
      <div
        class="cal-cell-top"
        [attr.aria-label]="
          { day: day, locale: locale } | calendarA11y : 'monthCell'
        "
      >
        <span aria-hidden="true">
          <span class="cal-day-badge" *ngIf="day.badgeTotal > 0">{{
            day.badgeTotal
          }}</span>
          <span class="cal-day-number">{{
            day.date | calendarDate : 'monthViewDayNumber' : locale
          }}</span>
        </span>
      </div>
      <div class="cal-events" *ngIf="day.events.length > 0">
        <div
          class="cal-event"
          *ngFor="let event of day.events; trackBy: trackByEventId"
          [ngStyle]="{ backgroundColor: event.color?.primary }"
          [ngClass]="event?.cssClass"
          (mouseenter)="highlightDay.emit({ event: event })"
          (mouseleave)="unhighlightDay.emit({ event: event })"
          [mwlCalendarTooltip]="
            event.title | calendarEventTitle : 'monthTooltip' : event
          "
          [tooltipPlacement]="tooltipPlacement"
          [tooltipEvent]="event"
          [tooltipTemplate]="tooltipTemplate"
          [tooltipAppendToBody]="tooltipAppendToBody"
          [tooltipDelay]="tooltipDelay"
          mwlDraggable
          [class.cal-draggable]="event.draggable"
          dragActiveClass="cal-drag-active"
          [dropData]="{ event: event, draggedFrom: day }"
          [dragAxis]="{ x: event.draggable, y: event.draggable }"
          [validateDrag]="validateDrag"
          [touchStartLongPress]="{ delay: 300, delta: 30 }"
          (mwlClick)="eventClicked.emit({ event: event, sourceEvent: $event })"
          [attr.aria-hidden]="{} | calendarA11y : 'hideMonthCellEvents'"
        ></div>
      </div>
    </ng-template>
    <ng-template
      [ngTemplateOutlet]="customTemplate || defaultTemplate"
      [ngTemplateOutletContext]="{
        day: day,
        openDay: openDay,
        locale: locale,
        tooltipPlacement: tooltipPlacement,
        highlightDay: highlightDay,
        unhighlightDay: unhighlightDay,
        eventClicked: eventClicked,
        tooltipTemplate: tooltipTemplate,
        tooltipAppendToBody: tooltipAppendToBody,
        tooltipDelay: tooltipDelay,
        trackByEventId: trackByEventId,
        validateDrag: validateDrag
      }"
    >
    </ng-template>
  `,
      // eslint-disable-next-line @angular-eslint/no-host-metadata-property
      host: {
        class: "cal-cell cal-day-cell",
        "[class.cal-past]": "day.isPast",
        "[class.cal-today]": "day.isToday",
        "[class.cal-future]": "day.isFuture",
        "[class.cal-weekend]": "day.isWeekend",
        "[class.cal-in-month]": "day.inMonth",
        "[class.cal-out-month]": "!day.inMonth",
        "[class.cal-has-events]": "day.events.length > 0",
        "[class.cal-open]": "day === openDay",
        "[class.cal-event-highlight]": "!!day.backgroundColor"
      }
    }]
  }], null, {
    day: [{
      type: Input
    }],
    openDay: [{
      type: Input
    }],
    locale: [{
      type: Input
    }],
    tooltipPlacement: [{
      type: Input
    }],
    tooltipAppendToBody: [{
      type: Input
    }],
    customTemplate: [{
      type: Input
    }],
    tooltipTemplate: [{
      type: Input
    }],
    tooltipDelay: [{
      type: Input
    }],
    highlightDay: [{
      type: Output
    }],
    unhighlightDay: [{
      type: Output
    }],
    eventClicked: [{
      type: Output
    }]
  });
})();
var collapseAnimation = trigger("collapse", [state("void", style({
  height: 0,
  overflow: "hidden",
  "padding-top": 0,
  "padding-bottom": 0
})), state("*", style({
  height: "*",
  overflow: "hidden",
  "padding-top": "*",
  "padding-bottom": "*"
})), transition("* => void", animate("150ms ease-out")), transition("void => *", animate("150ms ease-in"))]);
var CalendarOpenDayEventsComponent = class {
  constructor() {
    this.isOpen = false;
    this.eventClicked = new EventEmitter();
    this.trackByEventId = trackByEventId;
    this.validateDrag = isWithinThreshold;
  }
};
CalendarOpenDayEventsComponent.ɵfac = function CalendarOpenDayEventsComponent_Factory(t) {
  return new (t || CalendarOpenDayEventsComponent)();
};
CalendarOpenDayEventsComponent.ɵcmp = ɵɵdefineComponent({
  type: CalendarOpenDayEventsComponent,
  selectors: [["mwl-calendar-open-day-events"]],
  inputs: {
    locale: "locale",
    isOpen: "isOpen",
    events: "events",
    customTemplate: "customTemplate",
    eventTitleTemplate: "eventTitleTemplate",
    eventActionsTemplate: "eventActionsTemplate",
    date: "date"
  },
  outputs: {
    eventClicked: "eventClicked"
  },
  decls: 3,
  vars: 8,
  consts: [["defaultTemplate", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["class", "cal-open-day-events", "role", "application", 4, "ngIf"], ["role", "application", 1, "cal-open-day-events"], ["tabindex", "-1", "role", "alert"], ["tabindex", "0", "role", "landmark"], ["mwlDraggable", "", "dragActiveClass", "cal-drag-active", 3, "ngClass", "cal-draggable", "dropData", "dragAxis", "validateDrag", "touchStartLongPress", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["mwlDraggable", "", "dragActiveClass", "cal-drag-active", 3, "ngClass", "dropData", "dragAxis", "validateDrag", "touchStartLongPress"], [1, "cal-event", 3, "ngStyle"], ["view", "month", "tabindex", "0", 3, "mwlClick", "mwlKeydownEnter", "event", "customTemplate"], [3, "event", "customTemplate"]],
  template: function CalendarOpenDayEventsComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, CalendarOpenDayEventsComponent_ng_template_0_Template, 1, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor)(2, CalendarOpenDayEventsComponent_ng_template_2_Template, 0, 0, "ng-template", 1);
    }
    if (rf & 2) {
      const defaultTemplate_r10 = ɵɵreference(1);
      ɵɵadvance(2);
      ɵɵproperty("ngTemplateOutlet", ctx.customTemplate || defaultTemplate_r10)("ngTemplateOutletContext", ɵɵpureFunction5(2, _c11, ctx.events, ctx.eventClicked, ctx.isOpen, ctx.trackByEventId, ctx.validateDrag));
    }
  },
  dependencies: [NgClass, NgForOf, NgIf, NgTemplateOutlet, NgStyle, DraggableDirective, CalendarEventActionsComponent, CalendarEventTitleComponent, ClickDirective, KeydownEnterDirective, CalendarA11yPipe],
  encapsulation: 2,
  data: {
    animation: [collapseAnimation]
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarOpenDayEventsComponent, [{
    type: Component,
    args: [{
      selector: "mwl-calendar-open-day-events",
      template: `
    <ng-template
      #defaultTemplate
      let-events="events"
      let-eventClicked="eventClicked"
      let-isOpen="isOpen"
      let-trackByEventId="trackByEventId"
      let-validateDrag="validateDrag"
    >
      <div
        class="cal-open-day-events"
        [@collapse]
        *ngIf="isOpen"
        role="application"
      >
        <span
          tabindex="-1"
          role="alert"
          [attr.aria-label]="
            { date: date, locale: locale } | calendarA11y : 'openDayEventsAlert'
          "
        ></span>
        <span
          tabindex="0"
          role="landmark"
          [attr.aria-label]="
            { date: date, locale: locale }
              | calendarA11y : 'openDayEventsLandmark'
          "
        ></span>
        <div
          *ngFor="let event of events; trackBy: trackByEventId"
          [ngClass]="event?.cssClass"
          mwlDraggable
          [class.cal-draggable]="event.draggable"
          dragActiveClass="cal-drag-active"
          [dropData]="{ event: event }"
          [dragAxis]="{ x: event.draggable, y: event.draggable }"
          [validateDrag]="validateDrag"
          [touchStartLongPress]="{ delay: 300, delta: 30 }"
        >
          <span
            class="cal-event"
            [ngStyle]="{ backgroundColor: event.color?.primary }"
          >
          </span>
          &ngsp;
          <mwl-calendar-event-title
            [event]="event"
            [customTemplate]="eventTitleTemplate"
            view="month"
            (mwlClick)="
              eventClicked.emit({ event: event, sourceEvent: $event })
            "
            (mwlKeydownEnter)="
              eventClicked.emit({ event: event, sourceEvent: $event })
            "
            tabindex="0"
            [attr.aria-label]="
              { event: event, locale: locale }
                | calendarA11y : 'eventDescription'
            "
          >
          </mwl-calendar-event-title>
          &ngsp;
          <mwl-calendar-event-actions
            [event]="event"
            [customTemplate]="eventActionsTemplate"
          >
          </mwl-calendar-event-actions>
        </div>
      </div>
    </ng-template>
    <ng-template
      [ngTemplateOutlet]="customTemplate || defaultTemplate"
      [ngTemplateOutletContext]="{
        events: events,
        eventClicked: eventClicked,
        isOpen: isOpen,
        trackByEventId: trackByEventId,
        validateDrag: validateDrag
      }"
    >
    </ng-template>
  `,
      animations: [collapseAnimation]
    }]
  }], null, {
    locale: [{
      type: Input
    }],
    isOpen: [{
      type: Input
    }],
    events: [{
      type: Input
    }],
    customTemplate: [{
      type: Input
    }],
    eventTitleTemplate: [{
      type: Input
    }],
    eventActionsTemplate: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    eventClicked: [{
      type: Output
    }]
  });
})();
var CalendarMonthViewHeaderComponent = class {
  constructor() {
    this.columnHeaderClicked = new EventEmitter();
    this.trackByWeekDayHeaderDate = trackByWeekDayHeaderDate;
  }
};
CalendarMonthViewHeaderComponent.ɵfac = function CalendarMonthViewHeaderComponent_Factory(t) {
  return new (t || CalendarMonthViewHeaderComponent)();
};
CalendarMonthViewHeaderComponent.ɵcmp = ɵɵdefineComponent({
  type: CalendarMonthViewHeaderComponent,
  selectors: [["mwl-calendar-month-view-header"]],
  inputs: {
    days: "days",
    locale: "locale",
    customTemplate: "customTemplate"
  },
  outputs: {
    columnHeaderClicked: "columnHeaderClicked"
  },
  decls: 3,
  vars: 6,
  consts: [["defaultTemplate", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["role", "row", 1, "cal-cell-row", "cal-header"], ["class", "cal-cell", "tabindex", "0", "role", "columnheader", 3, "cal-past", "cal-today", "cal-future", "cal-weekend", "ngClass", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["tabindex", "0", "role", "columnheader", 1, "cal-cell", 3, "click", "ngClass"]],
  template: function CalendarMonthViewHeaderComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, CalendarMonthViewHeaderComponent_ng_template_0_Template, 2, 2, "ng-template", null, 0, ɵɵtemplateRefExtractor)(2, CalendarMonthViewHeaderComponent_ng_template_2_Template, 0, 0, "ng-template", 1);
    }
    if (rf & 2) {
      const defaultTemplate_r7 = ɵɵreference(1);
      ɵɵadvance(2);
      ɵɵproperty("ngTemplateOutlet", ctx.customTemplate || defaultTemplate_r7)("ngTemplateOutletContext", ɵɵpureFunction3(2, _c15, ctx.days, ctx.locale, ctx.trackByWeekDayHeaderDate));
    }
  },
  dependencies: [NgClass, NgForOf, NgTemplateOutlet, CalendarDatePipe],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarMonthViewHeaderComponent, [{
    type: Component,
    args: [{
      selector: "mwl-calendar-month-view-header",
      template: `
    <ng-template
      #defaultTemplate
      let-days="days"
      let-locale="locale"
      let-trackByWeekDayHeaderDate="trackByWeekDayHeaderDate"
    >
      <div class="cal-cell-row cal-header" role="row">
        <div
          class="cal-cell"
          *ngFor="let day of days; trackBy: trackByWeekDayHeaderDate"
          [class.cal-past]="day.isPast"
          [class.cal-today]="day.isToday"
          [class.cal-future]="day.isFuture"
          [class.cal-weekend]="day.isWeekend"
          (click)="
            columnHeaderClicked.emit({
              isoDayNumber: day.day,
              sourceEvent: $event
            })
          "
          [ngClass]="day.cssClass"
          tabindex="0"
          role="columnheader"
        >
          {{ day.date | calendarDate : 'monthViewColumnHeader' : locale }}
        </div>
      </div>
    </ng-template>
    <ng-template
      [ngTemplateOutlet]="customTemplate || defaultTemplate"
      [ngTemplateOutletContext]="{
        days: days,
        locale: locale,
        trackByWeekDayHeaderDate: trackByWeekDayHeaderDate
      }"
    >
    </ng-template>
  `
    }]
  }], null, {
    days: [{
      type: Input
    }],
    locale: [{
      type: Input
    }],
    customTemplate: [{
      type: Input
    }],
    columnHeaderClicked: [{
      type: Output
    }]
  });
})();
var CalendarMonthViewComponent = class {
  /**
   * @hidden
   */
  constructor(cdr, utils, locale, dateAdapter) {
    this.cdr = cdr;
    this.utils = utils;
    this.dateAdapter = dateAdapter;
    this.events = [];
    this.excludeDays = [];
    this.activeDayIsOpen = false;
    this.tooltipPlacement = "auto";
    this.tooltipAppendToBody = true;
    this.tooltipDelay = null;
    this.beforeViewRender = new EventEmitter();
    this.dayClicked = new EventEmitter();
    this.eventClicked = new EventEmitter();
    this.columnHeaderClicked = new EventEmitter();
    this.eventTimesChanged = new EventEmitter();
    this.trackByRowOffset = (index, offset) => this.view.days.slice(offset, this.view.totalDaysVisibleInWeek).map((day) => day.date.toISOString()).join("-");
    this.trackByDate = (index, day) => day.date.toISOString();
    this.locale = locale;
  }
  /**
   * @hidden
   */
  ngOnInit() {
    if (this.refresh) {
      this.refreshSubscription = this.refresh.subscribe(() => {
        this.refreshAll();
        this.cdr.markForCheck();
      });
    }
  }
  /**
   * @hidden
   */
  ngOnChanges(changes) {
    const refreshHeader = changes.viewDate || changes.excludeDays || changes.weekendDays;
    const refreshBody = changes.viewDate || changes.events || changes.excludeDays || changes.weekendDays;
    if (refreshHeader) {
      this.refreshHeader();
    }
    if (changes.events) {
      validateEvents2(this.events);
    }
    if (refreshBody) {
      this.refreshBody();
    }
    if (refreshHeader || refreshBody) {
      this.emitBeforeViewRender();
    }
    if (changes.activeDayIsOpen || changes.viewDate || changes.events || changes.excludeDays || changes.activeDay) {
      this.checkActiveDayIsOpen();
    }
  }
  /**
   * @hidden
   */
  ngOnDestroy() {
    if (this.refreshSubscription) {
      this.refreshSubscription.unsubscribe();
    }
  }
  /**
   * @hidden
   */
  toggleDayHighlight(event, isHighlighted) {
    this.view.days.forEach((day) => {
      if (isHighlighted && day.events.indexOf(event) > -1) {
        day.backgroundColor = event.color && event.color.secondary || "#D1E8FF";
      } else {
        delete day.backgroundColor;
      }
    });
  }
  /**
   * @hidden
   */
  eventDropped(droppedOn, event, draggedFrom) {
    if (droppedOn !== draggedFrom) {
      const year = this.dateAdapter.getYear(droppedOn.date);
      const month = this.dateAdapter.getMonth(droppedOn.date);
      const date = this.dateAdapter.getDate(droppedOn.date);
      const newStart = this.dateAdapter.setDate(this.dateAdapter.setMonth(this.dateAdapter.setYear(event.start, year), month), date);
      let newEnd;
      if (event.end) {
        const secondsDiff = this.dateAdapter.differenceInSeconds(newStart, event.start);
        newEnd = this.dateAdapter.addSeconds(event.end, secondsDiff);
      }
      this.eventTimesChanged.emit({
        event,
        newStart,
        newEnd,
        day: droppedOn,
        type: CalendarEventTimesChangedEventType.Drop
      });
    }
  }
  refreshHeader() {
    this.columnHeaders = this.utils.getWeekViewHeader({
      viewDate: this.viewDate,
      weekStartsOn: this.weekStartsOn,
      excluded: this.excludeDays,
      weekendDays: this.weekendDays
    });
  }
  refreshBody() {
    this.view = this.utils.getMonthView({
      events: this.events,
      viewDate: this.viewDate,
      weekStartsOn: this.weekStartsOn,
      excluded: this.excludeDays,
      weekendDays: this.weekendDays
    });
  }
  checkActiveDayIsOpen() {
    if (this.activeDayIsOpen === true) {
      const activeDay = this.activeDay || this.viewDate;
      this.openDay = this.view.days.find((day) => this.dateAdapter.isSameDay(day.date, activeDay));
      const index = this.view.days.indexOf(this.openDay);
      this.openRowIndex = Math.floor(index / this.view.totalDaysVisibleInWeek) * this.view.totalDaysVisibleInWeek;
    } else {
      this.openRowIndex = null;
      this.openDay = null;
    }
  }
  refreshAll() {
    this.refreshHeader();
    this.refreshBody();
    this.emitBeforeViewRender();
    this.checkActiveDayIsOpen();
  }
  emitBeforeViewRender() {
    if (this.columnHeaders && this.view) {
      this.beforeViewRender.emit({
        header: this.columnHeaders,
        body: this.view.days,
        period: this.view.period
      });
    }
  }
};
CalendarMonthViewComponent.ɵfac = function CalendarMonthViewComponent_Factory(t) {
  return new (t || CalendarMonthViewComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(CalendarUtils), ɵɵdirectiveInject(LOCALE_ID), ɵɵdirectiveInject(DateAdapter));
};
CalendarMonthViewComponent.ɵcmp = ɵɵdefineComponent({
  type: CalendarMonthViewComponent,
  selectors: [["mwl-calendar-month-view"]],
  inputs: {
    viewDate: "viewDate",
    events: "events",
    excludeDays: "excludeDays",
    activeDayIsOpen: "activeDayIsOpen",
    activeDay: "activeDay",
    refresh: "refresh",
    locale: "locale",
    tooltipPlacement: "tooltipPlacement",
    tooltipTemplate: "tooltipTemplate",
    tooltipAppendToBody: "tooltipAppendToBody",
    tooltipDelay: "tooltipDelay",
    weekStartsOn: "weekStartsOn",
    headerTemplate: "headerTemplate",
    cellTemplate: "cellTemplate",
    openDayEventsTemplate: "openDayEventsTemplate",
    eventTitleTemplate: "eventTitleTemplate",
    eventActionsTemplate: "eventActionsTemplate",
    weekendDays: "weekendDays"
  },
  outputs: {
    beforeViewRender: "beforeViewRender",
    dayClicked: "dayClicked",
    eventClicked: "eventClicked",
    columnHeaderClicked: "columnHeaderClicked",
    eventTimesChanged: "eventTimesChanged"
  },
  features: [ɵɵNgOnChangesFeature],
  decls: 4,
  vars: 5,
  consts: [["role", "grid", 1, "cal-month-view"], [3, "columnHeaderClicked", "days", "locale", "customTemplate"], [1, "cal-days"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["role", "row", 1, "cal-cell-row"], ["role", "gridcell", "mwlDroppable", "", "dragOverClass", "cal-drag-over", 3, "ngClass", "day", "openDay", "locale", "tooltipPlacement", "tooltipAppendToBody", "tooltipTemplate", "tooltipDelay", "customTemplate", "ngStyle", "clickListenerDisabled", "mwlClick", "mwlKeydownEnter", "highlightDay", "unhighlightDay", "drop", "eventClicked", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["mwlDroppable", "", "dragOverClass", "cal-drag-over", 3, "eventClicked", "drop", "locale", "isOpen", "events", "date", "customTemplate", "eventTitleTemplate", "eventActionsTemplate"], ["role", "gridcell", "mwlDroppable", "", "dragOverClass", "cal-drag-over", 3, "mwlClick", "mwlKeydownEnter", "highlightDay", "unhighlightDay", "drop", "eventClicked", "ngClass", "day", "openDay", "locale", "tooltipPlacement", "tooltipAppendToBody", "tooltipTemplate", "tooltipDelay", "customTemplate", "ngStyle", "clickListenerDisabled"]],
  template: function CalendarMonthViewComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0)(1, "mwl-calendar-month-view-header", 1);
      ɵɵlistener("columnHeaderClicked", function CalendarMonthViewComponent_Template_mwl_calendar_month_view_header_columnHeaderClicked_1_listener($event) {
        return ctx.columnHeaderClicked.emit($event);
      });
      ɵɵelementEnd();
      ɵɵelementStart(2, "div", 2);
      ɵɵtemplate(3, CalendarMonthViewComponent_div_3_Template, 5, 13, "div", 3);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("days", ctx.columnHeaders)("locale", ctx.locale)("customTemplate", ctx.headerTemplate);
      ɵɵadvance(2);
      ɵɵproperty("ngForOf", ctx.view.rowOffsets)("ngForTrackBy", ctx.trackByRowOffset);
    }
  },
  dependencies: [NgClass, NgForOf, NgStyle, DroppableDirective, ClickDirective, KeydownEnterDirective, CalendarMonthCellComponent, CalendarOpenDayEventsComponent, CalendarMonthViewHeaderComponent, SlicePipe, CalendarA11yPipe],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarMonthViewComponent, [{
    type: Component,
    args: [{
      selector: "mwl-calendar-month-view",
      template: `
    <div class="cal-month-view" role="grid">
      <mwl-calendar-month-view-header
        [days]="columnHeaders"
        [locale]="locale"
        (columnHeaderClicked)="columnHeaderClicked.emit($event)"
        [customTemplate]="headerTemplate"
      >
      </mwl-calendar-month-view-header>
      <div class="cal-days">
        <div
          *ngFor="let rowIndex of view.rowOffsets; trackBy: trackByRowOffset"
        >
          <div role="row" class="cal-cell-row">
            <mwl-calendar-month-cell
              role="gridcell"
              *ngFor="
                let day of view.days
                  | slice : rowIndex : rowIndex + view.totalDaysVisibleInWeek;
                trackBy: trackByDate
              "
              [ngClass]="day?.cssClass"
              [day]="day"
              [openDay]="openDay"
              [locale]="locale"
              [tooltipPlacement]="tooltipPlacement"
              [tooltipAppendToBody]="tooltipAppendToBody"
              [tooltipTemplate]="tooltipTemplate"
              [tooltipDelay]="tooltipDelay"
              [customTemplate]="cellTemplate"
              [ngStyle]="{ backgroundColor: day.backgroundColor }"
              (mwlClick)="dayClicked.emit({ day: day, sourceEvent: $event })"
              [clickListenerDisabled]="dayClicked.observers.length === 0"
              (mwlKeydownEnter)="
                dayClicked.emit({ day: day, sourceEvent: $event })
              "
              (highlightDay)="toggleDayHighlight($event.event, true)"
              (unhighlightDay)="toggleDayHighlight($event.event, false)"
              mwlDroppable
              dragOverClass="cal-drag-over"
              (drop)="
                eventDropped(
                  day,
                  $event.dropData.event,
                  $event.dropData.draggedFrom
                )
              "
              (eventClicked)="
                eventClicked.emit({
                  event: $event.event,
                  sourceEvent: $event.sourceEvent
                })
              "
              [attr.tabindex]="{} | calendarA11y : 'monthCellTabIndex'"
            >
            </mwl-calendar-month-cell>
          </div>
          <mwl-calendar-open-day-events
            [locale]="locale"
            [isOpen]="openRowIndex === rowIndex"
            [events]="openDay?.events"
            [date]="openDay?.date"
            [customTemplate]="openDayEventsTemplate"
            [eventTitleTemplate]="eventTitleTemplate"
            [eventActionsTemplate]="eventActionsTemplate"
            (eventClicked)="
              eventClicked.emit({
                event: $event.event,
                sourceEvent: $event.sourceEvent
              })
            "
            mwlDroppable
            dragOverClass="cal-drag-over"
            (drop)="
              eventDropped(
                openDay,
                $event.dropData.event,
                $event.dropData.draggedFrom
              )
            "
          >
          </mwl-calendar-open-day-events>
        </div>
      </div>
    </div>
  `
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: CalendarUtils
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [LOCALE_ID]
      }]
    }, {
      type: DateAdapter
    }];
  }, {
    viewDate: [{
      type: Input
    }],
    events: [{
      type: Input
    }],
    excludeDays: [{
      type: Input
    }],
    activeDayIsOpen: [{
      type: Input
    }],
    activeDay: [{
      type: Input
    }],
    refresh: [{
      type: Input
    }],
    locale: [{
      type: Input
    }],
    tooltipPlacement: [{
      type: Input
    }],
    tooltipTemplate: [{
      type: Input
    }],
    tooltipAppendToBody: [{
      type: Input
    }],
    tooltipDelay: [{
      type: Input
    }],
    weekStartsOn: [{
      type: Input
    }],
    headerTemplate: [{
      type: Input
    }],
    cellTemplate: [{
      type: Input
    }],
    openDayEventsTemplate: [{
      type: Input
    }],
    eventTitleTemplate: [{
      type: Input
    }],
    eventActionsTemplate: [{
      type: Input
    }],
    weekendDays: [{
      type: Input
    }],
    beforeViewRender: [{
      type: Output
    }],
    dayClicked: [{
      type: Output
    }],
    eventClicked: [{
      type: Output
    }],
    columnHeaderClicked: [{
      type: Output
    }],
    eventTimesChanged: [{
      type: Output
    }]
  });
})();
var CalendarMonthModule = class {
};
CalendarMonthModule.ɵfac = function CalendarMonthModule_Factory(t) {
  return new (t || CalendarMonthModule)();
};
CalendarMonthModule.ɵmod = ɵɵdefineNgModule({
  type: CalendarMonthModule,
  declarations: [CalendarMonthViewComponent, CalendarMonthCellComponent, CalendarOpenDayEventsComponent, CalendarMonthViewHeaderComponent],
  imports: [CommonModule, DragAndDropModule, CalendarCommonModule],
  exports: [DragAndDropModule, CalendarMonthViewComponent, CalendarMonthCellComponent, CalendarOpenDayEventsComponent, CalendarMonthViewHeaderComponent]
});
CalendarMonthModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, DragAndDropModule, CalendarCommonModule, DragAndDropModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarMonthModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, DragAndDropModule, CalendarCommonModule],
      declarations: [CalendarMonthViewComponent, CalendarMonthCellComponent, CalendarOpenDayEventsComponent, CalendarMonthViewHeaderComponent],
      exports: [DragAndDropModule, CalendarMonthViewComponent, CalendarMonthCellComponent, CalendarOpenDayEventsComponent, CalendarMonthViewHeaderComponent]
    }]
  }], null, null);
})();
var CalendarDragHelper = class {
  constructor(dragContainerElement, draggableElement) {
    this.dragContainerElement = dragContainerElement;
    this.startPosition = draggableElement.getBoundingClientRect();
  }
  validateDrag({
    x,
    y,
    snapDraggedEvents,
    dragAlreadyMoved,
    transform
  }) {
    const isDraggedWithinThreshold = isWithinThreshold({
      x,
      y
    }) || dragAlreadyMoved;
    if (snapDraggedEvents) {
      const inner = Object.assign({}, this.startPosition, {
        left: this.startPosition.left + transform.x,
        right: this.startPosition.right + transform.x,
        top: this.startPosition.top + transform.y,
        bottom: this.startPosition.bottom + transform.y
      });
      if (isDraggedWithinThreshold) {
        const outer = this.dragContainerElement.getBoundingClientRect();
        const isTopInside = outer.top < inner.top && inner.top < outer.bottom;
        const isBottomInside = outer.top < inner.bottom && inner.bottom < outer.bottom;
        return isInsideLeftAndRight(outer, inner) && (isTopInside || isBottomInside);
      }
      return false;
    } else {
      return isDraggedWithinThreshold;
    }
  }
};
var CalendarResizeHelper = class {
  constructor(resizeContainerElement, minWidth, rtl) {
    this.resizeContainerElement = resizeContainerElement;
    this.minWidth = minWidth;
    this.rtl = rtl;
  }
  validateResize({
    rectangle,
    edges
  }) {
    if (this.rtl) {
      if (typeof edges.left !== "undefined") {
        rectangle.left -= edges.left;
        rectangle.right += edges.left;
      } else if (typeof edges.right !== "undefined") {
        rectangle.left += edges.right;
        rectangle.right -= edges.right;
      }
      rectangle.width = rectangle.right - rectangle.left;
    }
    if (this.minWidth && Math.ceil(rectangle.width) < Math.ceil(this.minWidth)) {
      return false;
    }
    return isInside(this.resizeContainerElement.getBoundingClientRect(), rectangle);
  }
};
var CalendarWeekViewHeaderComponent = class {
  constructor() {
    this.dayHeaderClicked = new EventEmitter();
    this.eventDropped = new EventEmitter();
    this.dragEnter = new EventEmitter();
    this.trackByWeekDayHeaderDate = trackByWeekDayHeaderDate;
  }
};
CalendarWeekViewHeaderComponent.ɵfac = function CalendarWeekViewHeaderComponent_Factory(t) {
  return new (t || CalendarWeekViewHeaderComponent)();
};
CalendarWeekViewHeaderComponent.ɵcmp = ɵɵdefineComponent({
  type: CalendarWeekViewHeaderComponent,
  selectors: [["mwl-calendar-week-view-header"]],
  inputs: {
    days: "days",
    locale: "locale",
    customTemplate: "customTemplate"
  },
  outputs: {
    dayHeaderClicked: "dayHeaderClicked",
    eventDropped: "eventDropped",
    dragEnter: "dragEnter"
  },
  decls: 3,
  vars: 9,
  consts: [["defaultTemplate", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["role", "row", 1, "cal-day-headers"], ["class", "cal-header", "mwlDroppable", "", "dragOverClass", "cal-drag-over", "tabindex", "0", "role", "columnheader", 3, "cal-past", "cal-today", "cal-future", "cal-weekend", "ngClass", "mwlClick", "drop", "dragEnter", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["mwlDroppable", "", "dragOverClass", "cal-drag-over", "tabindex", "0", "role", "columnheader", 1, "cal-header", 3, "mwlClick", "drop", "dragEnter", "ngClass"]],
  template: function CalendarWeekViewHeaderComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, CalendarWeekViewHeaderComponent_ng_template_0_Template, 2, 2, "ng-template", null, 0, ɵɵtemplateRefExtractor)(2, CalendarWeekViewHeaderComponent_ng_template_2_Template, 0, 0, "ng-template", 1);
    }
    if (rf & 2) {
      const defaultTemplate_r9 = ɵɵreference(1);
      ɵɵadvance(2);
      ɵɵproperty("ngTemplateOutlet", ctx.customTemplate || defaultTemplate_r9)("ngTemplateOutletContext", ɵɵpureFunction6(2, _c16, ctx.days, ctx.locale, ctx.dayHeaderClicked, ctx.eventDropped, ctx.dragEnter, ctx.trackByWeekDayHeaderDate));
    }
  },
  dependencies: [NgClass, NgForOf, NgTemplateOutlet, DroppableDirective, ClickDirective, CalendarDatePipe],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarWeekViewHeaderComponent, [{
    type: Component,
    args: [{
      selector: "mwl-calendar-week-view-header",
      template: `
    <ng-template
      #defaultTemplate
      let-days="days"
      let-locale="locale"
      let-dayHeaderClicked="dayHeaderClicked"
      let-eventDropped="eventDropped"
      let-trackByWeekDayHeaderDate="trackByWeekDayHeaderDate"
      let-dragEnter="dragEnter"
    >
      <div class="cal-day-headers" role="row">
        <div
          class="cal-header"
          *ngFor="let day of days; trackBy: trackByWeekDayHeaderDate"
          [class.cal-past]="day.isPast"
          [class.cal-today]="day.isToday"
          [class.cal-future]="day.isFuture"
          [class.cal-weekend]="day.isWeekend"
          [ngClass]="day.cssClass"
          (mwlClick)="dayHeaderClicked.emit({ day: day, sourceEvent: $event })"
          mwlDroppable
          dragOverClass="cal-drag-over"
          (drop)="
            eventDropped.emit({
              event: $event.dropData.event,
              newStart: day.date
            })
          "
          (dragEnter)="dragEnter.emit({ date: day.date })"
          tabindex="0"
          role="columnheader"
        >
          <b>{{ day.date | calendarDate : 'weekViewColumnHeader' : locale }}</b
          ><br />
          <span>{{
            day.date | calendarDate : 'weekViewColumnSubHeader' : locale
          }}</span>
        </div>
      </div>
    </ng-template>
    <ng-template
      [ngTemplateOutlet]="customTemplate || defaultTemplate"
      [ngTemplateOutletContext]="{
        days: days,
        locale: locale,
        dayHeaderClicked: dayHeaderClicked,
        eventDropped: eventDropped,
        dragEnter: dragEnter,
        trackByWeekDayHeaderDate: trackByWeekDayHeaderDate
      }"
    >
    </ng-template>
  `
    }]
  }], null, {
    days: [{
      type: Input
    }],
    locale: [{
      type: Input
    }],
    customTemplate: [{
      type: Input
    }],
    dayHeaderClicked: [{
      type: Output
    }],
    eventDropped: [{
      type: Output
    }],
    dragEnter: [{
      type: Output
    }]
  });
})();
var CalendarWeekViewEventComponent = class {
  constructor() {
    this.eventClicked = new EventEmitter();
  }
};
CalendarWeekViewEventComponent.ɵfac = function CalendarWeekViewEventComponent_Factory(t) {
  return new (t || CalendarWeekViewEventComponent)();
};
CalendarWeekViewEventComponent.ɵcmp = ɵɵdefineComponent({
  type: CalendarWeekViewEventComponent,
  selectors: [["mwl-calendar-week-view-event"]],
  inputs: {
    locale: "locale",
    weekEvent: "weekEvent",
    tooltipPlacement: "tooltipPlacement",
    tooltipAppendToBody: "tooltipAppendToBody",
    tooltipDisabled: "tooltipDisabled",
    tooltipDelay: "tooltipDelay",
    customTemplate: "customTemplate",
    eventTitleTemplate: "eventTitleTemplate",
    eventActionsTemplate: "eventActionsTemplate",
    tooltipTemplate: "tooltipTemplate",
    column: "column",
    daysInWeek: "daysInWeek"
  },
  outputs: {
    eventClicked: "eventClicked"
  },
  decls: 3,
  vars: 12,
  consts: [["defaultTemplate", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["tabindex", "0", "role", "application", 1, "cal-event", 3, "mwlClick", "mwlKeydownEnter", "ngStyle", "mwlCalendarTooltip", "tooltipPlacement", "tooltipEvent", "tooltipTemplate", "tooltipAppendToBody", "tooltipDelay"], [3, "event", "customTemplate"], [3, "event", "customTemplate", "view"]],
  template: function CalendarWeekViewEventComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, CalendarWeekViewEventComponent_ng_template_0_Template, 6, 27, "ng-template", null, 0, ɵɵtemplateRefExtractor)(2, CalendarWeekViewEventComponent_ng_template_2_Template, 0, 0, "ng-template", 1);
    }
    if (rf & 2) {
      const defaultTemplate_r11 = ɵɵreference(1);
      ɵɵadvance(2);
      ɵɵproperty("ngTemplateOutlet", ctx.customTemplate || defaultTemplate_r11)("ngTemplateOutletContext", ɵɵpureFunctionV(2, _c17, [ctx.weekEvent, ctx.tooltipPlacement, ctx.eventClicked, ctx.tooltipTemplate, ctx.tooltipAppendToBody, ctx.tooltipDisabled, ctx.tooltipDelay, ctx.column, ctx.daysInWeek]));
    }
  },
  dependencies: [NgTemplateOutlet, NgStyle, CalendarEventActionsComponent, CalendarEventTitleComponent, CalendarTooltipDirective, ClickDirective, KeydownEnterDirective, CalendarEventTitlePipe, CalendarA11yPipe],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarWeekViewEventComponent, [{
    type: Component,
    args: [{
      selector: "mwl-calendar-week-view-event",
      template: `
    <ng-template
      #defaultTemplate
      let-weekEvent="weekEvent"
      let-tooltipPlacement="tooltipPlacement"
      let-eventClicked="eventClicked"
      let-tooltipTemplate="tooltipTemplate"
      let-tooltipAppendToBody="tooltipAppendToBody"
      let-tooltipDisabled="tooltipDisabled"
      let-tooltipDelay="tooltipDelay"
      let-column="column"
      let-daysInWeek="daysInWeek"
    >
      <div
        class="cal-event"
        [ngStyle]="{
          color: weekEvent.event.color?.secondaryText,
          backgroundColor: weekEvent.event.color?.secondary,
          borderColor: weekEvent.event.color?.primary
        }"
        [mwlCalendarTooltip]="
          !tooltipDisabled
            ? (weekEvent.event.title
              | calendarEventTitle
                : (daysInWeek === 1 ? 'dayTooltip' : 'weekTooltip')
                : weekEvent.tempEvent || weekEvent.event)
            : ''
        "
        [tooltipPlacement]="tooltipPlacement"
        [tooltipEvent]="weekEvent.tempEvent || weekEvent.event"
        [tooltipTemplate]="tooltipTemplate"
        [tooltipAppendToBody]="tooltipAppendToBody"
        [tooltipDelay]="tooltipDelay"
        (mwlClick)="eventClicked.emit({ sourceEvent: $event })"
        (mwlKeydownEnter)="eventClicked.emit({ sourceEvent: $event })"
        tabindex="0"
        role="application"
        [attr.aria-label]="
          { event: weekEvent.tempEvent || weekEvent.event, locale: locale }
            | calendarA11y : 'eventDescription'
        "
      >
        <mwl-calendar-event-actions
          [event]="weekEvent.tempEvent || weekEvent.event"
          [customTemplate]="eventActionsTemplate"
        >
        </mwl-calendar-event-actions>
        &ngsp;
        <mwl-calendar-event-title
          [event]="weekEvent.tempEvent || weekEvent.event"
          [customTemplate]="eventTitleTemplate"
          [view]="daysInWeek === 1 ? 'day' : 'week'"
        >
        </mwl-calendar-event-title>
      </div>
    </ng-template>
    <ng-template
      [ngTemplateOutlet]="customTemplate || defaultTemplate"
      [ngTemplateOutletContext]="{
        weekEvent: weekEvent,
        tooltipPlacement: tooltipPlacement,
        eventClicked: eventClicked,
        tooltipTemplate: tooltipTemplate,
        tooltipAppendToBody: tooltipAppendToBody,
        tooltipDisabled: tooltipDisabled,
        tooltipDelay: tooltipDelay,
        column: column,
        daysInWeek: daysInWeek
      }"
    >
    </ng-template>
  `
    }]
  }], null, {
    locale: [{
      type: Input
    }],
    weekEvent: [{
      type: Input
    }],
    tooltipPlacement: [{
      type: Input
    }],
    tooltipAppendToBody: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    tooltipDelay: [{
      type: Input
    }],
    customTemplate: [{
      type: Input
    }],
    eventTitleTemplate: [{
      type: Input
    }],
    eventActionsTemplate: [{
      type: Input
    }],
    tooltipTemplate: [{
      type: Input
    }],
    column: [{
      type: Input
    }],
    daysInWeek: [{
      type: Input
    }],
    eventClicked: [{
      type: Output
    }]
  });
})();
var CalendarWeekViewHourSegmentComponent = class {
};
CalendarWeekViewHourSegmentComponent.ɵfac = function CalendarWeekViewHourSegmentComponent_Factory(t) {
  return new (t || CalendarWeekViewHourSegmentComponent)();
};
CalendarWeekViewHourSegmentComponent.ɵcmp = ɵɵdefineComponent({
  type: CalendarWeekViewHourSegmentComponent,
  selectors: [["mwl-calendar-week-view-hour-segment"]],
  inputs: {
    segment: "segment",
    segmentHeight: "segmentHeight",
    locale: "locale",
    isTimeLabel: "isTimeLabel",
    daysInWeek: "daysInWeek",
    customTemplate: "customTemplate"
  },
  decls: 3,
  vars: 8,
  consts: [["defaultTemplate", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "cal-hour-segment", 3, "ngClass"], ["class", "cal-time", 4, "ngIf"], [1, "cal-time"]],
  template: function CalendarWeekViewHourSegmentComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, CalendarWeekViewHourSegmentComponent_ng_template_0_Template, 3, 13, "ng-template", null, 0, ɵɵtemplateRefExtractor)(2, CalendarWeekViewHourSegmentComponent_ng_template_2_Template, 0, 0, "ng-template", 1);
    }
    if (rf & 2) {
      const defaultTemplate_r7 = ɵɵreference(1);
      ɵɵadvance(2);
      ɵɵproperty("ngTemplateOutlet", ctx.customTemplate || defaultTemplate_r7)("ngTemplateOutletContext", ɵɵpureFunction5(2, _c19, ctx.segment, ctx.locale, ctx.segmentHeight, ctx.isTimeLabel, ctx.daysInWeek));
    }
  },
  dependencies: [NgClass, NgIf, NgTemplateOutlet, CalendarDatePipe, CalendarA11yPipe],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarWeekViewHourSegmentComponent, [{
    type: Component,
    args: [{
      selector: "mwl-calendar-week-view-hour-segment",
      template: `
    <ng-template
      #defaultTemplate
      let-segment="segment"
      let-locale="locale"
      let-segmentHeight="segmentHeight"
      let-isTimeLabel="isTimeLabel"
      let-daysInWeek="daysInWeek"
    >
      <div
        [attr.aria-hidden]="
          {}
            | calendarA11y
              : (daysInWeek === 1
                  ? 'hideDayHourSegment'
                  : 'hideWeekHourSegment')
        "
        class="cal-hour-segment"
        [style.height.px]="segmentHeight"
        [class.cal-hour-start]="segment.isStart"
        [class.cal-after-hour-start]="!segment.isStart"
        [ngClass]="segment.cssClass"
      >
        <div class="cal-time" *ngIf="isTimeLabel">
          {{
            segment.displayDate
              | calendarDate
                : (daysInWeek === 1 ? 'dayViewHour' : 'weekViewHour')
                : locale
          }}
        </div>
      </div>
    </ng-template>
    <ng-template
      [ngTemplateOutlet]="customTemplate || defaultTemplate"
      [ngTemplateOutletContext]="{
        segment: segment,
        locale: locale,
        segmentHeight: segmentHeight,
        isTimeLabel: isTimeLabel,
        daysInWeek: daysInWeek
      }"
    >
    </ng-template>
  `
    }]
  }], null, {
    segment: [{
      type: Input
    }],
    segmentHeight: [{
      type: Input
    }],
    locale: [{
      type: Input
    }],
    isTimeLabel: [{
      type: Input
    }],
    daysInWeek: [{
      type: Input
    }],
    customTemplate: [{
      type: Input
    }]
  });
})();
var CalendarWeekViewCurrentTimeMarkerComponent = class {
  constructor(dateAdapter, zone) {
    this.dateAdapter = dateAdapter;
    this.zone = zone;
    this.columnDate$ = new BehaviorSubject(void 0);
    this.marker$ = this.zone.onStable.pipe(switchMap(() => interval(60 * 1e3)), startWith(0), switchMapTo(this.columnDate$), map((columnDate) => {
      const startOfDay2 = this.dateAdapter.setMinutes(this.dateAdapter.setHours(columnDate, this.dayStartHour), this.dayStartMinute);
      const endOfDay2 = this.dateAdapter.setMinutes(this.dateAdapter.setHours(columnDate, this.dayEndHour), this.dayEndMinute);
      const hourHeightModifier = this.hourSegments * this.hourSegmentHeight / (this.hourDuration || 60);
      const now = /* @__PURE__ */ new Date();
      return {
        isVisible: this.dateAdapter.isSameDay(columnDate, now) && now >= startOfDay2 && now <= endOfDay2,
        top: this.dateAdapter.differenceInMinutes(now, startOfDay2) * hourHeightModifier
      };
    }));
  }
  ngOnChanges(changes) {
    if (changes.columnDate) {
      this.columnDate$.next(changes.columnDate.currentValue);
    }
  }
};
CalendarWeekViewCurrentTimeMarkerComponent.ɵfac = function CalendarWeekViewCurrentTimeMarkerComponent_Factory(t) {
  return new (t || CalendarWeekViewCurrentTimeMarkerComponent)(ɵɵdirectiveInject(DateAdapter), ɵɵdirectiveInject(NgZone));
};
CalendarWeekViewCurrentTimeMarkerComponent.ɵcmp = ɵɵdefineComponent({
  type: CalendarWeekViewCurrentTimeMarkerComponent,
  selectors: [["mwl-calendar-week-view-current-time-marker"]],
  inputs: {
    columnDate: "columnDate",
    dayStartHour: "dayStartHour",
    dayStartMinute: "dayStartMinute",
    dayEndHour: "dayEndHour",
    dayEndMinute: "dayEndMinute",
    hourSegments: "hourSegments",
    hourDuration: "hourDuration",
    hourSegmentHeight: "hourSegmentHeight",
    customTemplate: "customTemplate"
  },
  features: [ɵɵNgOnChangesFeature],
  decls: 5,
  vars: 14,
  consts: [["defaultTemplate", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["class", "cal-current-time-marker", 3, "top", 4, "ngIf"], [1, "cal-current-time-marker"]],
  template: function CalendarWeekViewCurrentTimeMarkerComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, CalendarWeekViewCurrentTimeMarkerComponent_ng_template_0_Template, 1, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor)(2, CalendarWeekViewCurrentTimeMarkerComponent_ng_template_2_Template, 0, 0, "ng-template", 1);
      ɵɵpipe(3, "async");
      ɵɵpipe(4, "async");
    }
    if (rf & 2) {
      let tmp_2_0;
      const defaultTemplate_r3 = ɵɵreference(1);
      ɵɵadvance(2);
      ɵɵproperty("ngTemplateOutlet", ctx.customTemplate || defaultTemplate_r3)("ngTemplateOutletContext", ɵɵpureFunction7(6, _c20, ctx.columnDate, ctx.dayStartHour, ctx.dayStartMinute, ctx.dayEndHour, ctx.dayEndMinute, (tmp_2_0 = ɵɵpipeBind1(3, 2, ctx.marker$)) == null ? null : tmp_2_0.isVisible, (tmp_2_0 = ɵɵpipeBind1(4, 4, ctx.marker$)) == null ? null : tmp_2_0.top));
    }
  },
  dependencies: [NgIf, NgTemplateOutlet, AsyncPipe],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarWeekViewCurrentTimeMarkerComponent, [{
    type: Component,
    args: [{
      selector: "mwl-calendar-week-view-current-time-marker",
      template: `
    <ng-template
      #defaultTemplate
      let-columnDate="columnDate"
      let-dayStartHour="dayStartHour"
      let-dayStartMinute="dayStartMinute"
      let-dayEndHour="dayEndHour"
      let-dayEndMinute="dayEndMinute"
      let-isVisible="isVisible"
      let-topPx="topPx"
    >
      <div
        class="cal-current-time-marker"
        *ngIf="isVisible"
        [style.top.px]="topPx"
      ></div>
    </ng-template>
    <ng-template
      [ngTemplateOutlet]="customTemplate || defaultTemplate"
      [ngTemplateOutletContext]="{
        columnDate: columnDate,
        dayStartHour: dayStartHour,
        dayStartMinute: dayStartMinute,
        dayEndHour: dayEndHour,
        dayEndMinute: dayEndMinute,
        isVisible: (marker$ | async)?.isVisible,
        topPx: (marker$ | async)?.top
      }"
    >
    </ng-template>
  `
    }]
  }], function() {
    return [{
      type: DateAdapter
    }, {
      type: NgZone
    }];
  }, {
    columnDate: [{
      type: Input
    }],
    dayStartHour: [{
      type: Input
    }],
    dayStartMinute: [{
      type: Input
    }],
    dayEndHour: [{
      type: Input
    }],
    dayEndMinute: [{
      type: Input
    }],
    hourSegments: [{
      type: Input
    }],
    hourDuration: [{
      type: Input
    }],
    hourSegmentHeight: [{
      type: Input
    }],
    customTemplate: [{
      type: Input
    }]
  });
})();
var CalendarWeekViewComponent = class {
  /**
   * @hidden
   */
  constructor(cdr, utils, locale, dateAdapter, element) {
    this.cdr = cdr;
    this.utils = utils;
    this.dateAdapter = dateAdapter;
    this.element = element;
    this.events = [];
    this.excludeDays = [];
    this.tooltipPlacement = "auto";
    this.tooltipAppendToBody = true;
    this.tooltipDelay = null;
    this.precision = "days";
    this.snapDraggedEvents = true;
    this.hourSegments = 2;
    this.hourSegmentHeight = 30;
    this.minimumEventHeight = 30;
    this.dayStartHour = 0;
    this.dayStartMinute = 0;
    this.dayEndHour = 23;
    this.dayEndMinute = 59;
    this.dayHeaderClicked = new EventEmitter();
    this.eventClicked = new EventEmitter();
    this.eventTimesChanged = new EventEmitter();
    this.beforeViewRender = new EventEmitter();
    this.hourSegmentClicked = new EventEmitter();
    this.allDayEventResizes = /* @__PURE__ */ new Map();
    this.timeEventResizes = /* @__PURE__ */ new Map();
    this.eventDragEnterByType = {
      allDay: 0,
      time: 0
    };
    this.dragActive = false;
    this.dragAlreadyMoved = false;
    this.calendarId = Symbol("angular calendar week view id");
    this.rtl = false;
    this.trackByWeekDayHeaderDate = trackByWeekDayHeaderDate;
    this.trackByHourSegment = trackByHourSegment;
    this.trackByHour = trackByHour;
    this.trackByWeekAllDayEvent = trackByWeekAllDayEvent;
    this.trackByWeekTimeEvent = trackByWeekTimeEvent;
    this.trackByHourColumn = (index, column) => column.hours[0] ? column.hours[0].segments[0].date.toISOString() : column;
    this.trackById = (index, row) => row.id;
    this.locale = locale;
  }
  /**
   * @hidden
   */
  ngOnInit() {
    if (this.refresh) {
      this.refreshSubscription = this.refresh.subscribe(() => {
        this.refreshAll();
        this.cdr.markForCheck();
      });
    }
  }
  /**
   * @hidden
   */
  ngOnChanges(changes) {
    const refreshHeader = changes.viewDate || changes.excludeDays || changes.weekendDays || changes.daysInWeek || changes.weekStartsOn;
    const refreshBody = changes.viewDate || changes.dayStartHour || changes.dayStartMinute || changes.dayEndHour || changes.dayEndMinute || changes.hourSegments || changes.hourDuration || changes.weekStartsOn || changes.weekendDays || changes.excludeDays || changes.hourSegmentHeight || changes.events || changes.daysInWeek || changes.minimumEventHeight;
    if (refreshHeader) {
      this.refreshHeader();
    }
    if (changes.events) {
      validateEvents2(this.events);
    }
    if (refreshBody) {
      this.refreshBody();
    }
    if (refreshHeader || refreshBody) {
      this.emitBeforeViewRender();
    }
  }
  /**
   * @hidden
   */
  ngOnDestroy() {
    if (this.refreshSubscription) {
      this.refreshSubscription.unsubscribe();
    }
  }
  /**
   * @hidden
   */
  ngAfterViewInit() {
    this.rtl = typeof window !== "undefined" && getComputedStyle(this.element.nativeElement).direction === "rtl";
    this.cdr.detectChanges();
  }
  /**
   * @hidden
   */
  timeEventResizeStarted(eventsContainer, timeEvent, resizeEvent) {
    this.timeEventResizes.set(timeEvent.event, resizeEvent);
    this.resizeStarted(eventsContainer, timeEvent);
  }
  /**
   * @hidden
   */
  timeEventResizing(timeEvent, resizeEvent) {
    this.timeEventResizes.set(timeEvent.event, resizeEvent);
    const adjustedEvents = /* @__PURE__ */ new Map();
    const tempEvents = [...this.events];
    this.timeEventResizes.forEach((lastResizeEvent, event) => {
      const newEventDates = this.getTimeEventResizedDates(event, lastResizeEvent);
      const adjustedEvent = __spreadValues(__spreadValues({}, event), newEventDates);
      adjustedEvents.set(adjustedEvent, event);
      const eventIndex = tempEvents.indexOf(event);
      tempEvents[eventIndex] = adjustedEvent;
    });
    this.restoreOriginalEvents(tempEvents, adjustedEvents, true);
  }
  /**
   * @hidden
   */
  timeEventResizeEnded(timeEvent) {
    this.view = this.getWeekView(this.events);
    const lastResizeEvent = this.timeEventResizes.get(timeEvent.event);
    if (lastResizeEvent) {
      this.timeEventResizes.delete(timeEvent.event);
      const newEventDates = this.getTimeEventResizedDates(timeEvent.event, lastResizeEvent);
      this.eventTimesChanged.emit({
        newStart: newEventDates.start,
        newEnd: newEventDates.end,
        event: timeEvent.event,
        type: CalendarEventTimesChangedEventType.Resize
      });
    }
  }
  /**
   * @hidden
   */
  allDayEventResizeStarted(allDayEventsContainer, allDayEvent, resizeEvent) {
    this.allDayEventResizes.set(allDayEvent, {
      originalOffset: allDayEvent.offset,
      originalSpan: allDayEvent.span,
      edge: typeof resizeEvent.edges.left !== "undefined" ? "left" : "right"
    });
    this.resizeStarted(allDayEventsContainer, allDayEvent, this.getDayColumnWidth(allDayEventsContainer));
  }
  /**
   * @hidden
   */
  allDayEventResizing(allDayEvent, resizeEvent, dayWidth) {
    const currentResize = this.allDayEventResizes.get(allDayEvent);
    const modifier = this.rtl ? -1 : 1;
    if (typeof resizeEvent.edges.left !== "undefined") {
      const diff = Math.round(+resizeEvent.edges.left / dayWidth) * modifier;
      allDayEvent.offset = currentResize.originalOffset + diff;
      allDayEvent.span = currentResize.originalSpan - diff;
    } else if (typeof resizeEvent.edges.right !== "undefined") {
      const diff = Math.round(+resizeEvent.edges.right / dayWidth) * modifier;
      allDayEvent.span = currentResize.originalSpan + diff;
    }
  }
  /**
   * @hidden
   */
  allDayEventResizeEnded(allDayEvent) {
    const currentResize = this.allDayEventResizes.get(allDayEvent);
    if (currentResize) {
      const allDayEventResizingBeforeStart = currentResize.edge === "left";
      let daysDiff;
      if (allDayEventResizingBeforeStart) {
        daysDiff = allDayEvent.offset - currentResize.originalOffset;
      } else {
        daysDiff = allDayEvent.span - currentResize.originalSpan;
      }
      allDayEvent.offset = currentResize.originalOffset;
      allDayEvent.span = currentResize.originalSpan;
      const newDates = this.getAllDayEventResizedDates(allDayEvent.event, daysDiff, allDayEventResizingBeforeStart);
      this.eventTimesChanged.emit({
        newStart: newDates.start,
        newEnd: newDates.end,
        event: allDayEvent.event,
        type: CalendarEventTimesChangedEventType.Resize
      });
      this.allDayEventResizes.delete(allDayEvent);
    }
  }
  /**
   * @hidden
   */
  getDayColumnWidth(eventRowContainer) {
    return Math.floor(eventRowContainer.offsetWidth / this.days.length);
  }
  /**
   * @hidden
   */
  dateDragEnter(date) {
    this.lastDragEnterDate = date;
  }
  /**
   * @hidden
   */
  eventDropped(dropEvent, date, allDay) {
    if (shouldFireDroppedEvent(dropEvent, date, allDay, this.calendarId) && this.lastDragEnterDate.getTime() === date.getTime() && (!this.snapDraggedEvents || dropEvent.dropData.event !== this.lastDraggedEvent)) {
      this.eventTimesChanged.emit({
        type: CalendarEventTimesChangedEventType.Drop,
        event: dropEvent.dropData.event,
        newStart: date,
        allDay
      });
    }
    this.lastDraggedEvent = null;
  }
  /**
   * @hidden
   */
  dragEnter(type) {
    this.eventDragEnterByType[type]++;
  }
  /**
   * @hidden
   */
  dragLeave(type) {
    this.eventDragEnterByType[type]--;
  }
  /**
   * @hidden
   */
  dragStarted(eventsContainerElement, eventElement, event, useY) {
    this.dayColumnWidth = this.getDayColumnWidth(eventsContainerElement);
    const dragHelper = new CalendarDragHelper(eventsContainerElement, eventElement);
    this.validateDrag = ({
      x,
      y,
      transform
    }) => {
      const isAllowed = this.allDayEventResizes.size === 0 && this.timeEventResizes.size === 0 && dragHelper.validateDrag({
        x,
        y,
        snapDraggedEvents: this.snapDraggedEvents,
        dragAlreadyMoved: this.dragAlreadyMoved,
        transform
      });
      if (isAllowed && this.validateEventTimesChanged) {
        const newEventTimes = this.getDragMovedEventTimes(event, {
          x,
          y
        }, this.dayColumnWidth, useY);
        return this.validateEventTimesChanged({
          type: CalendarEventTimesChangedEventType.Drag,
          event: event.event,
          newStart: newEventTimes.start,
          newEnd: newEventTimes.end
        });
      }
      return isAllowed;
    };
    this.dragActive = true;
    this.dragAlreadyMoved = false;
    this.lastDraggedEvent = null;
    this.eventDragEnterByType = {
      allDay: 0,
      time: 0
    };
    if (!this.snapDraggedEvents && useY) {
      this.view.hourColumns.forEach((column) => {
        const linkedEvent = column.events.find((columnEvent) => columnEvent.event === event.event && columnEvent !== event);
        if (linkedEvent) {
          linkedEvent.width = 0;
          linkedEvent.height = 0;
        }
      });
    }
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  dragMove(dayEvent, dragEvent) {
    const newEventTimes = this.getDragMovedEventTimes(dayEvent, dragEvent, this.dayColumnWidth, true);
    const originalEvent = dayEvent.event;
    const adjustedEvent = __spreadValues(__spreadValues({}, originalEvent), newEventTimes);
    const tempEvents = this.events.map((event) => {
      if (event === originalEvent) {
        return adjustedEvent;
      }
      return event;
    });
    this.restoreOriginalEvents(tempEvents, /* @__PURE__ */ new Map([[adjustedEvent, originalEvent]]), this.snapDraggedEvents);
    this.dragAlreadyMoved = true;
  }
  /**
   * @hidden
   */
  allDayEventDragMove() {
    this.dragAlreadyMoved = true;
  }
  /**
   * @hidden
   */
  dragEnded(weekEvent, dragEndEvent, dayWidth, useY = false) {
    this.view = this.getWeekView(this.events);
    this.dragActive = false;
    this.validateDrag = null;
    const {
      start,
      end
    } = this.getDragMovedEventTimes(weekEvent, dragEndEvent, dayWidth, useY);
    if ((this.snapDraggedEvents || this.eventDragEnterByType[useY ? "time" : "allDay"] > 0) && isDraggedWithinPeriod(start, end, this.view.period)) {
      this.lastDraggedEvent = weekEvent.event;
      this.eventTimesChanged.emit({
        newStart: start,
        newEnd: end,
        event: weekEvent.event,
        type: CalendarEventTimesChangedEventType.Drag,
        allDay: !useY
      });
    }
  }
  refreshHeader() {
    this.days = this.utils.getWeekViewHeader(__spreadValues({
      viewDate: this.viewDate,
      weekStartsOn: this.weekStartsOn,
      excluded: this.excludeDays,
      weekendDays: this.weekendDays
    }, getWeekViewPeriod(this.dateAdapter, this.viewDate, this.weekStartsOn, this.excludeDays, this.daysInWeek)));
  }
  refreshBody() {
    this.view = this.getWeekView(this.events);
  }
  refreshAll() {
    this.refreshHeader();
    this.refreshBody();
    this.emitBeforeViewRender();
  }
  emitBeforeViewRender() {
    if (this.days && this.view) {
      this.beforeViewRender.emit(__spreadValues({
        header: this.days
      }, this.view));
    }
  }
  getWeekView(events) {
    return this.utils.getWeekView(__spreadValues({
      events,
      viewDate: this.viewDate,
      weekStartsOn: this.weekStartsOn,
      excluded: this.excludeDays,
      precision: this.precision,
      absolutePositionedEvents: true,
      hourSegments: this.hourSegments,
      hourDuration: this.hourDuration,
      dayStart: {
        hour: this.dayStartHour,
        minute: this.dayStartMinute
      },
      dayEnd: {
        hour: this.dayEndHour,
        minute: this.dayEndMinute
      },
      segmentHeight: this.hourSegmentHeight,
      weekendDays: this.weekendDays,
      minimumEventHeight: this.minimumEventHeight
    }, getWeekViewPeriod(this.dateAdapter, this.viewDate, this.weekStartsOn, this.excludeDays, this.daysInWeek)));
  }
  getDragMovedEventTimes(weekEvent, dragEndEvent, dayWidth, useY) {
    const daysDragged = roundToNearest(dragEndEvent.x, dayWidth) / dayWidth * (this.rtl ? -1 : 1);
    const minutesMoved = useY ? getMinutesMoved(dragEndEvent.y, this.hourSegments, this.hourSegmentHeight, this.eventSnapSize, this.hourDuration) : 0;
    const start = this.dateAdapter.addMinutes(addDaysWithExclusions(this.dateAdapter, weekEvent.event.start, daysDragged, this.excludeDays), minutesMoved);
    let end;
    if (weekEvent.event.end) {
      end = this.dateAdapter.addMinutes(addDaysWithExclusions(this.dateAdapter, weekEvent.event.end, daysDragged, this.excludeDays), minutesMoved);
    }
    return {
      start,
      end
    };
  }
  restoreOriginalEvents(tempEvents, adjustedEvents, snapDraggedEvents = true) {
    const previousView = this.view;
    if (snapDraggedEvents) {
      this.view = this.getWeekView(tempEvents);
    }
    const adjustedEventsArray = tempEvents.filter((event) => adjustedEvents.has(event));
    this.view.hourColumns.forEach((column, columnIndex) => {
      previousView.hourColumns[columnIndex].hours.forEach((hour, hourIndex) => {
        hour.segments.forEach((segment, segmentIndex) => {
          column.hours[hourIndex].segments[segmentIndex].cssClass = segment.cssClass;
        });
      });
      adjustedEventsArray.forEach((adjustedEvent) => {
        const originalEvent = adjustedEvents.get(adjustedEvent);
        const existingColumnEvent = column.events.find((columnEvent) => columnEvent.event === (snapDraggedEvents ? adjustedEvent : originalEvent));
        if (existingColumnEvent) {
          existingColumnEvent.event = originalEvent;
          existingColumnEvent["tempEvent"] = adjustedEvent;
          if (!snapDraggedEvents) {
            existingColumnEvent.height = 0;
            existingColumnEvent.width = 0;
          }
        } else {
          const event = {
            event: originalEvent,
            left: 0,
            top: 0,
            height: 0,
            width: 0,
            startsBeforeDay: false,
            endsAfterDay: false,
            tempEvent: adjustedEvent
          };
          column.events.push(event);
        }
      });
    });
    adjustedEvents.clear();
  }
  getTimeEventResizedDates(calendarEvent, resizeEvent) {
    const newEventDates = {
      start: calendarEvent.start,
      end: getDefaultEventEnd(this.dateAdapter, calendarEvent, this.minimumEventHeight)
    };
    const _a = calendarEvent, {
      end
    } = _a, eventWithoutEnd = __objRest(_a, [
      "end"
    ]);
    const smallestResizes = {
      start: this.dateAdapter.addMinutes(newEventDates.end, this.minimumEventHeight * -1),
      end: getDefaultEventEnd(this.dateAdapter, eventWithoutEnd, this.minimumEventHeight)
    };
    const modifier = this.rtl ? -1 : 1;
    if (typeof resizeEvent.edges.left !== "undefined") {
      const daysDiff = Math.round(+resizeEvent.edges.left / this.dayColumnWidth) * modifier;
      const newStart = addDaysWithExclusions(this.dateAdapter, newEventDates.start, daysDiff, this.excludeDays);
      if (newStart < smallestResizes.start) {
        newEventDates.start = newStart;
      } else {
        newEventDates.start = smallestResizes.start;
      }
    } else if (typeof resizeEvent.edges.right !== "undefined") {
      const daysDiff = Math.round(+resizeEvent.edges.right / this.dayColumnWidth) * modifier;
      const newEnd = addDaysWithExclusions(this.dateAdapter, newEventDates.end, daysDiff, this.excludeDays);
      if (newEnd > smallestResizes.end) {
        newEventDates.end = newEnd;
      } else {
        newEventDates.end = smallestResizes.end;
      }
    }
    if (typeof resizeEvent.edges.top !== "undefined") {
      const minutesMoved = getMinutesMoved(resizeEvent.edges.top, this.hourSegments, this.hourSegmentHeight, this.eventSnapSize, this.hourDuration);
      const newStart = this.dateAdapter.addMinutes(newEventDates.start, minutesMoved);
      if (newStart < smallestResizes.start) {
        newEventDates.start = newStart;
      } else {
        newEventDates.start = smallestResizes.start;
      }
    } else if (typeof resizeEvent.edges.bottom !== "undefined") {
      const minutesMoved = getMinutesMoved(resizeEvent.edges.bottom, this.hourSegments, this.hourSegmentHeight, this.eventSnapSize, this.hourDuration);
      const newEnd = this.dateAdapter.addMinutes(newEventDates.end, minutesMoved);
      if (newEnd > smallestResizes.end) {
        newEventDates.end = newEnd;
      } else {
        newEventDates.end = smallestResizes.end;
      }
    }
    return newEventDates;
  }
  resizeStarted(eventsContainer, event, dayWidth) {
    this.dayColumnWidth = this.getDayColumnWidth(eventsContainer);
    const resizeHelper = new CalendarResizeHelper(eventsContainer, dayWidth, this.rtl);
    this.validateResize = ({
      rectangle,
      edges
    }) => {
      const isWithinBoundary = resizeHelper.validateResize({
        rectangle: __spreadValues({}, rectangle),
        edges
      });
      if (isWithinBoundary && this.validateEventTimesChanged) {
        let newEventDates;
        if (!dayWidth) {
          newEventDates = this.getTimeEventResizedDates(event.event, {
            rectangle,
            edges
          });
        } else {
          const modifier = this.rtl ? -1 : 1;
          if (typeof edges.left !== "undefined") {
            const diff = Math.round(+edges.left / dayWidth) * modifier;
            newEventDates = this.getAllDayEventResizedDates(event.event, diff, !this.rtl);
          } else {
            const diff = Math.round(+edges.right / dayWidth) * modifier;
            newEventDates = this.getAllDayEventResizedDates(event.event, diff, this.rtl);
          }
        }
        return this.validateEventTimesChanged({
          type: CalendarEventTimesChangedEventType.Resize,
          event: event.event,
          newStart: newEventDates.start,
          newEnd: newEventDates.end
        });
      }
      return isWithinBoundary;
    };
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  getAllDayEventResizedDates(event, daysDiff, beforeStart) {
    let start = event.start;
    let end = event.end || event.start;
    if (beforeStart) {
      start = addDaysWithExclusions(this.dateAdapter, start, daysDiff, this.excludeDays);
    } else {
      end = addDaysWithExclusions(this.dateAdapter, end, daysDiff, this.excludeDays);
    }
    return {
      start,
      end
    };
  }
};
CalendarWeekViewComponent.ɵfac = function CalendarWeekViewComponent_Factory(t) {
  return new (t || CalendarWeekViewComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(CalendarUtils), ɵɵdirectiveInject(LOCALE_ID), ɵɵdirectiveInject(DateAdapter), ɵɵdirectiveInject(ElementRef));
};
CalendarWeekViewComponent.ɵcmp = ɵɵdefineComponent({
  type: CalendarWeekViewComponent,
  selectors: [["mwl-calendar-week-view"]],
  inputs: {
    viewDate: "viewDate",
    events: "events",
    excludeDays: "excludeDays",
    refresh: "refresh",
    locale: "locale",
    tooltipPlacement: "tooltipPlacement",
    tooltipTemplate: "tooltipTemplate",
    tooltipAppendToBody: "tooltipAppendToBody",
    tooltipDelay: "tooltipDelay",
    weekStartsOn: "weekStartsOn",
    headerTemplate: "headerTemplate",
    eventTemplate: "eventTemplate",
    eventTitleTemplate: "eventTitleTemplate",
    eventActionsTemplate: "eventActionsTemplate",
    precision: "precision",
    weekendDays: "weekendDays",
    snapDraggedEvents: "snapDraggedEvents",
    hourSegments: "hourSegments",
    hourDuration: "hourDuration",
    hourSegmentHeight: "hourSegmentHeight",
    minimumEventHeight: "minimumEventHeight",
    dayStartHour: "dayStartHour",
    dayStartMinute: "dayStartMinute",
    dayEndHour: "dayEndHour",
    dayEndMinute: "dayEndMinute",
    hourSegmentTemplate: "hourSegmentTemplate",
    eventSnapSize: "eventSnapSize",
    allDayEventsLabelTemplate: "allDayEventsLabelTemplate",
    daysInWeek: "daysInWeek",
    currentTimeMarkerTemplate: "currentTimeMarkerTemplate",
    validateEventTimesChanged: "validateEventTimesChanged",
    resizeCursors: "resizeCursors"
  },
  outputs: {
    dayHeaderClicked: "dayHeaderClicked",
    eventClicked: "eventClicked",
    eventTimesChanged: "eventTimesChanged",
    beforeViewRender: "beforeViewRender",
    hourSegmentClicked: "hourSegmentClicked"
  },
  features: [ɵɵNgOnChangesFeature],
  decls: 8,
  vars: 9,
  consts: [["dayColumns", ""], ["allDayEventsContainer", ""], ["eventRowContainer", ""], ["event", ""], ["weekEventTemplate", ""], ["role", "grid", 1, "cal-week-view"], [3, "dayHeaderClicked", "eventDropped", "dragEnter", "days", "locale", "customTemplate"], ["class", "cal-all-day-events", "mwlDroppable", "", 3, "dragEnter", "dragLeave", 4, "ngIf"], ["mwlDroppable", "", 1, "cal-time-events", 3, "dragEnter", "dragLeave"], ["class", "cal-time-label-column", 4, "ngIf"], [1, "cal-day-columns"], ["class", "cal-day-column", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["mwlDroppable", "", 1, "cal-all-day-events", 3, "dragEnter", "dragLeave"], [1, "cal-time-label-column"], [4, "ngTemplateOutlet"], ["class", "cal-day-column", "mwlDroppable", "", "dragOverClass", "cal-drag-over", 3, "drop", "dragEnter", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "cal-events-row", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["mwlDroppable", "", "dragOverClass", "cal-drag-over", 1, "cal-day-column", 3, "drop", "dragEnter"], [1, "cal-events-row"], ["class", "cal-event-container", "mwlResizable", "", "mwlDraggable", "", "dragActiveClass", "cal-drag-active", 3, "cal-draggable", "cal-starts-within-week", "cal-ends-within-week", "ngClass", "width", "marginLeft", "marginRight", "resizeCursors", "resizeSnapGrid", "validateResize", "dropData", "dragAxis", "dragSnapGrid", "validateDrag", "touchStartLongPress", "resizeStart", "resizing", "resizeEnd", "dragStart", "dragging", "dragEnd", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["mwlResizable", "", "mwlDraggable", "", "dragActiveClass", "cal-drag-active", 1, "cal-event-container", 3, "resizeStart", "resizing", "resizeEnd", "dragStart", "dragging", "dragEnd", "ngClass", "resizeCursors", "resizeSnapGrid", "validateResize", "dropData", "dragAxis", "dragSnapGrid", "validateDrag", "touchStartLongPress"], ["class", "cal-resize-handle cal-resize-handle-before-start", "mwlResizeHandle", "", 3, "resizeEdges", 4, "ngIf"], [3, "eventClicked", "locale", "weekEvent", "tooltipPlacement", "tooltipTemplate", "tooltipAppendToBody", "tooltipDelay", "customTemplate", "eventTitleTemplate", "eventActionsTemplate", "daysInWeek"], ["class", "cal-resize-handle cal-resize-handle-after-end", "mwlResizeHandle", "", 3, "resizeEdges", 4, "ngIf"], ["mwlResizeHandle", "", 1, "cal-resize-handle", "cal-resize-handle-before-start", 3, "resizeEdges"], ["mwlResizeHandle", "", 1, "cal-resize-handle", "cal-resize-handle-after-end", 3, "resizeEdges"], ["class", "cal-hour", 3, "cal-hour-odd", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "cal-hour"], [3, "height", "segment", "segmentHeight", "locale", "customTemplate", "isTimeLabel", "daysInWeek", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "segment", "segmentHeight", "locale", "customTemplate", "isTimeLabel", "daysInWeek"], [1, "cal-day-column"], [3, "columnDate", "dayStartHour", "dayStartMinute", "dayEndHour", "dayEndMinute", "hourSegments", "hourDuration", "hourSegmentHeight", "customTemplate"], [1, "cal-events-container"], ["class", "cal-event-container", "mwlResizable", "", "mwlDraggable", "", "dragActiveClass", "cal-drag-active", 3, "cal-draggable", "cal-starts-within-day", "cal-ends-within-day", "ngClass", "hidden", "top", "height", "left", "width", "resizeCursors", "resizeSnapGrid", "validateResize", "allowNegativeResizes", "dropData", "dragAxis", "dragSnapGrid", "touchStartLongPress", "ghostDragEnabled", "ghostElementTemplate", "validateDrag", "resizeStart", "resizing", "resizeEnd", "dragStart", "dragging", "dragEnd", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["mwlResizable", "", "mwlDraggable", "", "dragActiveClass", "cal-drag-active", 1, "cal-event-container", 3, "resizeStart", "resizing", "resizeEnd", "dragStart", "dragging", "dragEnd", "ngClass", "hidden", "resizeCursors", "resizeSnapGrid", "validateResize", "allowNegativeResizes", "dropData", "dragAxis", "dragSnapGrid", "touchStartLongPress", "ghostDragEnabled", "ghostElementTemplate", "validateDrag"], [3, "ngTemplateOutlet"], [3, "eventClicked", "locale", "weekEvent", "tooltipPlacement", "tooltipTemplate", "tooltipAppendToBody", "tooltipDisabled", "tooltipDelay", "customTemplate", "eventTitleTemplate", "eventActionsTemplate", "column", "daysInWeek"], ["mwlDroppable", "", "dragActiveClass", "cal-drag-active", 3, "height", "segment", "segmentHeight", "locale", "customTemplate", "daysInWeek", "clickListenerDisabled", "dragOverClass", "isTimeLabel", "mwlClick", "drop", "dragEnter", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["mwlDroppable", "", "dragActiveClass", "cal-drag-active", 3, "mwlClick", "drop", "dragEnter", "segment", "segmentHeight", "locale", "customTemplate", "daysInWeek", "clickListenerDisabled", "dragOverClass", "isTimeLabel"]],
  template: function CalendarWeekViewComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "div", 5)(1, "mwl-calendar-week-view-header", 6);
      ɵɵlistener("dayHeaderClicked", function CalendarWeekViewComponent_Template_mwl_calendar_week_view_header_dayHeaderClicked_1_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.dayHeaderClicked.emit($event));
      })("eventDropped", function CalendarWeekViewComponent_Template_mwl_calendar_week_view_header_eventDropped_1_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.eventDropped({
          dropData: $event
        }, $event.newStart, true));
      })("dragEnter", function CalendarWeekViewComponent_Template_mwl_calendar_week_view_header_dragEnter_1_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.dateDragEnter($event.date));
      });
      ɵɵelementEnd();
      ɵɵtemplate(2, CalendarWeekViewComponent_div_2_Template, 7, 5, "div", 7);
      ɵɵelementStart(3, "div", 8);
      ɵɵlistener("dragEnter", function CalendarWeekViewComponent_Template_div_dragEnter_3_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.dragEnter("time"));
      })("dragLeave", function CalendarWeekViewComponent_Template_div_dragLeave_3_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.dragLeave("time"));
      });
      ɵɵtemplate(4, CalendarWeekViewComponent_div_4_Template, 2, 2, "div", 9);
      ɵɵelementStart(5, "div", 10, 0);
      ɵɵtemplate(7, CalendarWeekViewComponent_div_7_Template, 5, 13, "div", 11);
      ɵɵelementEnd()()();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("days", ctx.days)("locale", ctx.locale)("customTemplate", ctx.headerTemplate);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.view.allDayEventRows.length > 0);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.view.hourColumns.length > 0 && ctx.daysInWeek !== 1);
      ɵɵadvance();
      ɵɵclassProp("cal-resize-active", ctx.timeEventResizes.size > 0);
      ɵɵadvance(2);
      ɵɵproperty("ngForOf", ctx.view.hourColumns)("ngForTrackBy", ctx.trackByHourColumn);
    }
  },
  dependencies: [NgClass, NgForOf, NgIf, NgTemplateOutlet, ResizableDirective, ResizeHandleDirective, DraggableDirective, DroppableDirective, ClickDirective, CalendarWeekViewHeaderComponent, CalendarWeekViewEventComponent, CalendarWeekViewHourSegmentComponent, CalendarWeekViewCurrentTimeMarkerComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarWeekViewComponent, [{
    type: Component,
    args: [{
      selector: "mwl-calendar-week-view",
      template: `
    <div class="cal-week-view" role="grid">
      <mwl-calendar-week-view-header
        [days]="days"
        [locale]="locale"
        [customTemplate]="headerTemplate"
        (dayHeaderClicked)="dayHeaderClicked.emit($event)"
        (eventDropped)="
          eventDropped({ dropData: $event }, $event.newStart, true)
        "
        (dragEnter)="dateDragEnter($event.date)"
      >
      </mwl-calendar-week-view-header>
      <div
        class="cal-all-day-events"
        #allDayEventsContainer
        *ngIf="view.allDayEventRows.length > 0"
        mwlDroppable
        (dragEnter)="dragEnter('allDay')"
        (dragLeave)="dragLeave('allDay')"
      >
        <div class="cal-day-columns">
          <div class="cal-time-label-column">
            <ng-container
              *ngTemplateOutlet="allDayEventsLabelTemplate"
            ></ng-container>
          </div>
          <div
            class="cal-day-column"
            *ngFor="let day of days; trackBy: trackByWeekDayHeaderDate"
            mwlDroppable
            dragOverClass="cal-drag-over"
            (drop)="eventDropped($event, day.date, true)"
            (dragEnter)="dateDragEnter(day.date)"
          ></div>
        </div>
        <div
          *ngFor="let eventRow of view.allDayEventRows; trackBy: trackById"
          #eventRowContainer
          class="cal-events-row"
        >
          <div
            *ngFor="
              let allDayEvent of eventRow.row;
              trackBy: trackByWeekAllDayEvent
            "
            #event
            class="cal-event-container"
            [class.cal-draggable]="
              allDayEvent.event.draggable && allDayEventResizes.size === 0
            "
            [class.cal-starts-within-week]="!allDayEvent.startsBeforeWeek"
            [class.cal-ends-within-week]="!allDayEvent.endsAfterWeek"
            [ngClass]="allDayEvent.event?.cssClass"
            [style.width.%]="(100 / days.length) * allDayEvent.span"
            [style.marginLeft.%]="
              rtl ? null : (100 / days.length) * allDayEvent.offset
            "
            [style.marginRight.%]="
              rtl ? (100 / days.length) * allDayEvent.offset : null
            "
            mwlResizable
            [resizeCursors]="resizeCursors"
            [resizeSnapGrid]="{ left: dayColumnWidth, right: dayColumnWidth }"
            [validateResize]="validateResize"
            (resizeStart)="
              allDayEventResizeStarted(eventRowContainer, allDayEvent, $event)
            "
            (resizing)="
              allDayEventResizing(allDayEvent, $event, dayColumnWidth)
            "
            (resizeEnd)="allDayEventResizeEnded(allDayEvent)"
            mwlDraggable
            dragActiveClass="cal-drag-active"
            [dropData]="{ event: allDayEvent.event, calendarId: calendarId }"
            [dragAxis]="{
              x: allDayEvent.event.draggable && allDayEventResizes.size === 0,
              y:
                !snapDraggedEvents &&
                allDayEvent.event.draggable &&
                allDayEventResizes.size === 0
            }"
            [dragSnapGrid]="snapDraggedEvents ? { x: dayColumnWidth } : {}"
            [validateDrag]="validateDrag"
            [touchStartLongPress]="{ delay: 300, delta: 30 }"
            (dragStart)="
              dragStarted(eventRowContainer, event, allDayEvent, false)
            "
            (dragging)="allDayEventDragMove()"
            (dragEnd)="dragEnded(allDayEvent, $event, dayColumnWidth)"
          >
            <div
              class="cal-resize-handle cal-resize-handle-before-start"
              *ngIf="
                allDayEvent.event?.resizable?.beforeStart &&
                !allDayEvent.startsBeforeWeek
              "
              mwlResizeHandle
              [resizeEdges]="{ left: true }"
            ></div>
            <mwl-calendar-week-view-event
              [locale]="locale"
              [weekEvent]="allDayEvent"
              [tooltipPlacement]="tooltipPlacement"
              [tooltipTemplate]="tooltipTemplate"
              [tooltipAppendToBody]="tooltipAppendToBody"
              [tooltipDelay]="tooltipDelay"
              [customTemplate]="eventTemplate"
              [eventTitleTemplate]="eventTitleTemplate"
              [eventActionsTemplate]="eventActionsTemplate"
              [daysInWeek]="daysInWeek"
              (eventClicked)="
                eventClicked.emit({
                  event: allDayEvent.event,
                  sourceEvent: $event.sourceEvent
                })
              "
            >
            </mwl-calendar-week-view-event>
            <div
              class="cal-resize-handle cal-resize-handle-after-end"
              *ngIf="
                allDayEvent.event?.resizable?.afterEnd &&
                !allDayEvent.endsAfterWeek
              "
              mwlResizeHandle
              [resizeEdges]="{ right: true }"
            ></div>
          </div>
        </div>
      </div>
      <div
        class="cal-time-events"
        mwlDroppable
        (dragEnter)="dragEnter('time')"
        (dragLeave)="dragLeave('time')"
      >
        <div
          class="cal-time-label-column"
          *ngIf="view.hourColumns.length > 0 && daysInWeek !== 1"
        >
          <div
            *ngFor="
              let hour of view.hourColumns[0].hours;
              trackBy: trackByHour;
              let odd = odd
            "
            class="cal-hour"
            [class.cal-hour-odd]="odd"
          >
            <mwl-calendar-week-view-hour-segment
              *ngFor="let segment of hour.segments; trackBy: trackByHourSegment"
              [style.height.px]="hourSegmentHeight"
              [segment]="segment"
              [segmentHeight]="hourSegmentHeight"
              [locale]="locale"
              [customTemplate]="hourSegmentTemplate"
              [isTimeLabel]="true"
              [daysInWeek]="daysInWeek"
            >
            </mwl-calendar-week-view-hour-segment>
          </div>
        </div>
        <div
          class="cal-day-columns"
          [class.cal-resize-active]="timeEventResizes.size > 0"
          #dayColumns
        >
          <div
            class="cal-day-column"
            *ngFor="let column of view.hourColumns; trackBy: trackByHourColumn"
          >
            <mwl-calendar-week-view-current-time-marker
              [columnDate]="column.date"
              [dayStartHour]="dayStartHour"
              [dayStartMinute]="dayStartMinute"
              [dayEndHour]="dayEndHour"
              [dayEndMinute]="dayEndMinute"
              [hourSegments]="hourSegments"
              [hourDuration]="hourDuration"
              [hourSegmentHeight]="hourSegmentHeight"
              [customTemplate]="currentTimeMarkerTemplate"
            ></mwl-calendar-week-view-current-time-marker>
            <div class="cal-events-container">
              <div
                *ngFor="
                  let timeEvent of column.events;
                  trackBy: trackByWeekTimeEvent
                "
                #event
                class="cal-event-container"
                [class.cal-draggable]="
                  timeEvent.event.draggable && timeEventResizes.size === 0
                "
                [class.cal-starts-within-day]="!timeEvent.startsBeforeDay"
                [class.cal-ends-within-day]="!timeEvent.endsAfterDay"
                [ngClass]="timeEvent.event.cssClass"
                [hidden]="timeEvent.height === 0 && timeEvent.width === 0"
                [style.top.px]="timeEvent.top"
                [style.height.px]="timeEvent.height"
                [style.left.%]="timeEvent.left"
                [style.width.%]="timeEvent.width"
                mwlResizable
                [resizeCursors]="resizeCursors"
                [resizeSnapGrid]="{
                  left: dayColumnWidth,
                  right: dayColumnWidth,
                  top: eventSnapSize || hourSegmentHeight,
                  bottom: eventSnapSize || hourSegmentHeight
                }"
                [validateResize]="validateResize"
                [allowNegativeResizes]="true"
                (resizeStart)="
                  timeEventResizeStarted(dayColumns, timeEvent, $event)
                "
                (resizing)="timeEventResizing(timeEvent, $event)"
                (resizeEnd)="timeEventResizeEnded(timeEvent)"
                mwlDraggable
                dragActiveClass="cal-drag-active"
                [dropData]="{ event: timeEvent.event, calendarId: calendarId }"
                [dragAxis]="{
                  x: timeEvent.event.draggable && timeEventResizes.size === 0,
                  y: timeEvent.event.draggable && timeEventResizes.size === 0
                }"
                [dragSnapGrid]="
                  snapDraggedEvents
                    ? {
                        x: dayColumnWidth,
                        y: eventSnapSize || hourSegmentHeight
                      }
                    : {}
                "
                [touchStartLongPress]="{ delay: 300, delta: 30 }"
                [ghostDragEnabled]="!snapDraggedEvents"
                [ghostElementTemplate]="weekEventTemplate"
                [validateDrag]="validateDrag"
                (dragStart)="dragStarted(dayColumns, event, timeEvent, true)"
                (dragging)="dragMove(timeEvent, $event)"
                (dragEnd)="dragEnded(timeEvent, $event, dayColumnWidth, true)"
              >
                <div
                  class="cal-resize-handle cal-resize-handle-before-start"
                  *ngIf="
                    timeEvent.event?.resizable?.beforeStart &&
                    !timeEvent.startsBeforeDay
                  "
                  mwlResizeHandle
                  [resizeEdges]="{
                    left: true,
                    top: true
                  }"
                ></div>
                <ng-template
                  [ngTemplateOutlet]="weekEventTemplate"
                ></ng-template>
                <ng-template #weekEventTemplate>
                  <mwl-calendar-week-view-event
                    [locale]="locale"
                    [weekEvent]="timeEvent"
                    [tooltipPlacement]="tooltipPlacement"
                    [tooltipTemplate]="tooltipTemplate"
                    [tooltipAppendToBody]="tooltipAppendToBody"
                    [tooltipDisabled]="dragActive || timeEventResizes.size > 0"
                    [tooltipDelay]="tooltipDelay"
                    [customTemplate]="eventTemplate"
                    [eventTitleTemplate]="eventTitleTemplate"
                    [eventActionsTemplate]="eventActionsTemplate"
                    [column]="column"
                    [daysInWeek]="daysInWeek"
                    (eventClicked)="
                      eventClicked.emit({
                        event: timeEvent.event,
                        sourceEvent: $event.sourceEvent
                      })
                    "
                  >
                  </mwl-calendar-week-view-event>
                </ng-template>
                <div
                  class="cal-resize-handle cal-resize-handle-after-end"
                  *ngIf="
                    timeEvent.event?.resizable?.afterEnd &&
                    !timeEvent.endsAfterDay
                  "
                  mwlResizeHandle
                  [resizeEdges]="{
                    right: true,
                    bottom: true
                  }"
                ></div>
              </div>
            </div>

            <div
              *ngFor="
                let hour of column.hours;
                trackBy: trackByHour;
                let odd = odd
              "
              class="cal-hour"
              [class.cal-hour-odd]="odd"
            >
              <mwl-calendar-week-view-hour-segment
                *ngFor="
                  let segment of hour.segments;
                  trackBy: trackByHourSegment
                "
                [style.height.px]="hourSegmentHeight"
                [segment]="segment"
                [segmentHeight]="hourSegmentHeight"
                [locale]="locale"
                [customTemplate]="hourSegmentTemplate"
                [daysInWeek]="daysInWeek"
                (mwlClick)="
                  hourSegmentClicked.emit({
                    date: segment.date,
                    sourceEvent: $event
                  })
                "
                [clickListenerDisabled]="
                  hourSegmentClicked.observers.length === 0
                "
                mwlDroppable
                [dragOverClass]="
                  !dragActive || !snapDraggedEvents ? 'cal-drag-over' : null
                "
                dragActiveClass="cal-drag-active"
                (drop)="eventDropped($event, segment.date, false)"
                (dragEnter)="dateDragEnter(segment.date)"
                [isTimeLabel]="daysInWeek === 1"
              >
              </mwl-calendar-week-view-hour-segment>
            </div>
          </div>
        </div>
      </div>
    </div>
  `
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: CalendarUtils
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [LOCALE_ID]
      }]
    }, {
      type: DateAdapter
    }, {
      type: ElementRef
    }];
  }, {
    viewDate: [{
      type: Input
    }],
    events: [{
      type: Input
    }],
    excludeDays: [{
      type: Input
    }],
    refresh: [{
      type: Input
    }],
    locale: [{
      type: Input
    }],
    tooltipPlacement: [{
      type: Input
    }],
    tooltipTemplate: [{
      type: Input
    }],
    tooltipAppendToBody: [{
      type: Input
    }],
    tooltipDelay: [{
      type: Input
    }],
    weekStartsOn: [{
      type: Input
    }],
    headerTemplate: [{
      type: Input
    }],
    eventTemplate: [{
      type: Input
    }],
    eventTitleTemplate: [{
      type: Input
    }],
    eventActionsTemplate: [{
      type: Input
    }],
    precision: [{
      type: Input
    }],
    weekendDays: [{
      type: Input
    }],
    snapDraggedEvents: [{
      type: Input
    }],
    hourSegments: [{
      type: Input
    }],
    hourDuration: [{
      type: Input
    }],
    hourSegmentHeight: [{
      type: Input
    }],
    minimumEventHeight: [{
      type: Input
    }],
    dayStartHour: [{
      type: Input
    }],
    dayStartMinute: [{
      type: Input
    }],
    dayEndHour: [{
      type: Input
    }],
    dayEndMinute: [{
      type: Input
    }],
    hourSegmentTemplate: [{
      type: Input
    }],
    eventSnapSize: [{
      type: Input
    }],
    allDayEventsLabelTemplate: [{
      type: Input
    }],
    daysInWeek: [{
      type: Input
    }],
    currentTimeMarkerTemplate: [{
      type: Input
    }],
    validateEventTimesChanged: [{
      type: Input
    }],
    resizeCursors: [{
      type: Input
    }],
    dayHeaderClicked: [{
      type: Output
    }],
    eventClicked: [{
      type: Output
    }],
    eventTimesChanged: [{
      type: Output
    }],
    beforeViewRender: [{
      type: Output
    }],
    hourSegmentClicked: [{
      type: Output
    }]
  });
})();
var CalendarWeekModule = class {
};
CalendarWeekModule.ɵfac = function CalendarWeekModule_Factory(t) {
  return new (t || CalendarWeekModule)();
};
CalendarWeekModule.ɵmod = ɵɵdefineNgModule({
  type: CalendarWeekModule,
  declarations: [CalendarWeekViewComponent, CalendarWeekViewHeaderComponent, CalendarWeekViewEventComponent, CalendarWeekViewHourSegmentComponent, CalendarWeekViewCurrentTimeMarkerComponent],
  imports: [CommonModule, ResizableModule, DragAndDropModule, CalendarCommonModule],
  exports: [ResizableModule, DragAndDropModule, CalendarWeekViewComponent, CalendarWeekViewHeaderComponent, CalendarWeekViewEventComponent, CalendarWeekViewHourSegmentComponent, CalendarWeekViewCurrentTimeMarkerComponent]
});
CalendarWeekModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ResizableModule, DragAndDropModule, CalendarCommonModule, ResizableModule, DragAndDropModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarWeekModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ResizableModule, DragAndDropModule, CalendarCommonModule],
      declarations: [CalendarWeekViewComponent, CalendarWeekViewHeaderComponent, CalendarWeekViewEventComponent, CalendarWeekViewHourSegmentComponent, CalendarWeekViewCurrentTimeMarkerComponent],
      exports: [ResizableModule, DragAndDropModule, CalendarWeekViewComponent, CalendarWeekViewHeaderComponent, CalendarWeekViewEventComponent, CalendarWeekViewHourSegmentComponent, CalendarWeekViewCurrentTimeMarkerComponent]
    }]
  }], null, null);
})();
var CalendarDayViewComponent = class {
  constructor() {
    this.events = [];
    this.hourSegments = 2;
    this.hourSegmentHeight = 30;
    this.minimumEventHeight = 30;
    this.dayStartHour = 0;
    this.dayStartMinute = 0;
    this.dayEndHour = 23;
    this.dayEndMinute = 59;
    this.tooltipPlacement = "auto";
    this.tooltipAppendToBody = true;
    this.tooltipDelay = null;
    this.snapDraggedEvents = true;
    this.eventClicked = new EventEmitter();
    this.hourSegmentClicked = new EventEmitter();
    this.eventTimesChanged = new EventEmitter();
    this.beforeViewRender = new EventEmitter();
  }
};
CalendarDayViewComponent.ɵfac = function CalendarDayViewComponent_Factory(t) {
  return new (t || CalendarDayViewComponent)();
};
CalendarDayViewComponent.ɵcmp = ɵɵdefineComponent({
  type: CalendarDayViewComponent,
  selectors: [["mwl-calendar-day-view"]],
  inputs: {
    viewDate: "viewDate",
    events: "events",
    hourSegments: "hourSegments",
    hourSegmentHeight: "hourSegmentHeight",
    hourDuration: "hourDuration",
    minimumEventHeight: "minimumEventHeight",
    dayStartHour: "dayStartHour",
    dayStartMinute: "dayStartMinute",
    dayEndHour: "dayEndHour",
    dayEndMinute: "dayEndMinute",
    refresh: "refresh",
    locale: "locale",
    eventSnapSize: "eventSnapSize",
    tooltipPlacement: "tooltipPlacement",
    tooltipTemplate: "tooltipTemplate",
    tooltipAppendToBody: "tooltipAppendToBody",
    tooltipDelay: "tooltipDelay",
    hourSegmentTemplate: "hourSegmentTemplate",
    eventTemplate: "eventTemplate",
    eventTitleTemplate: "eventTitleTemplate",
    eventActionsTemplate: "eventActionsTemplate",
    snapDraggedEvents: "snapDraggedEvents",
    allDayEventsLabelTemplate: "allDayEventsLabelTemplate",
    currentTimeMarkerTemplate: "currentTimeMarkerTemplate",
    validateEventTimesChanged: "validateEventTimesChanged",
    resizeCursors: "resizeCursors"
  },
  outputs: {
    eventClicked: "eventClicked",
    hourSegmentClicked: "hourSegmentClicked",
    eventTimesChanged: "eventTimesChanged",
    beforeViewRender: "beforeViewRender"
  },
  decls: 1,
  vars: 27,
  consts: [[1, "cal-day-view", 3, "eventClicked", "hourSegmentClicked", "eventTimesChanged", "beforeViewRender", "daysInWeek", "viewDate", "events", "hourSegments", "hourDuration", "hourSegmentHeight", "minimumEventHeight", "dayStartHour", "dayStartMinute", "dayEndHour", "dayEndMinute", "refresh", "locale", "eventSnapSize", "tooltipPlacement", "tooltipTemplate", "tooltipAppendToBody", "tooltipDelay", "resizeCursors", "hourSegmentTemplate", "eventTemplate", "eventTitleTemplate", "eventActionsTemplate", "snapDraggedEvents", "allDayEventsLabelTemplate", "currentTimeMarkerTemplate", "validateEventTimesChanged"]],
  template: function CalendarDayViewComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "mwl-calendar-week-view", 0);
      ɵɵlistener("eventClicked", function CalendarDayViewComponent_Template_mwl_calendar_week_view_eventClicked_0_listener($event) {
        return ctx.eventClicked.emit($event);
      })("hourSegmentClicked", function CalendarDayViewComponent_Template_mwl_calendar_week_view_hourSegmentClicked_0_listener($event) {
        return ctx.hourSegmentClicked.emit($event);
      })("eventTimesChanged", function CalendarDayViewComponent_Template_mwl_calendar_week_view_eventTimesChanged_0_listener($event) {
        return ctx.eventTimesChanged.emit($event);
      })("beforeViewRender", function CalendarDayViewComponent_Template_mwl_calendar_week_view_beforeViewRender_0_listener($event) {
        return ctx.beforeViewRender.emit($event);
      });
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("daysInWeek", 1)("viewDate", ctx.viewDate)("events", ctx.events)("hourSegments", ctx.hourSegments)("hourDuration", ctx.hourDuration)("hourSegmentHeight", ctx.hourSegmentHeight)("minimumEventHeight", ctx.minimumEventHeight)("dayStartHour", ctx.dayStartHour)("dayStartMinute", ctx.dayStartMinute)("dayEndHour", ctx.dayEndHour)("dayEndMinute", ctx.dayEndMinute)("refresh", ctx.refresh)("locale", ctx.locale)("eventSnapSize", ctx.eventSnapSize)("tooltipPlacement", ctx.tooltipPlacement)("tooltipTemplate", ctx.tooltipTemplate)("tooltipAppendToBody", ctx.tooltipAppendToBody)("tooltipDelay", ctx.tooltipDelay)("resizeCursors", ctx.resizeCursors)("hourSegmentTemplate", ctx.hourSegmentTemplate)("eventTemplate", ctx.eventTemplate)("eventTitleTemplate", ctx.eventTitleTemplate)("eventActionsTemplate", ctx.eventActionsTemplate)("snapDraggedEvents", ctx.snapDraggedEvents)("allDayEventsLabelTemplate", ctx.allDayEventsLabelTemplate)("currentTimeMarkerTemplate", ctx.currentTimeMarkerTemplate)("validateEventTimesChanged", ctx.validateEventTimesChanged);
    }
  },
  dependencies: [CalendarWeekViewComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarDayViewComponent, [{
    type: Component,
    args: [{
      selector: "mwl-calendar-day-view",
      template: `
    <mwl-calendar-week-view
      class="cal-day-view"
      [daysInWeek]="1"
      [viewDate]="viewDate"
      [events]="events"
      [hourSegments]="hourSegments"
      [hourDuration]="hourDuration"
      [hourSegmentHeight]="hourSegmentHeight"
      [minimumEventHeight]="minimumEventHeight"
      [dayStartHour]="dayStartHour"
      [dayStartMinute]="dayStartMinute"
      [dayEndHour]="dayEndHour"
      [dayEndMinute]="dayEndMinute"
      [refresh]="refresh"
      [locale]="locale"
      [eventSnapSize]="eventSnapSize"
      [tooltipPlacement]="tooltipPlacement"
      [tooltipTemplate]="tooltipTemplate"
      [tooltipAppendToBody]="tooltipAppendToBody"
      [tooltipDelay]="tooltipDelay"
      [resizeCursors]="resizeCursors"
      [hourSegmentTemplate]="hourSegmentTemplate"
      [eventTemplate]="eventTemplate"
      [eventTitleTemplate]="eventTitleTemplate"
      [eventActionsTemplate]="eventActionsTemplate"
      [snapDraggedEvents]="snapDraggedEvents"
      [allDayEventsLabelTemplate]="allDayEventsLabelTemplate"
      [currentTimeMarkerTemplate]="currentTimeMarkerTemplate"
      [validateEventTimesChanged]="validateEventTimesChanged"
      (eventClicked)="eventClicked.emit($event)"
      (hourSegmentClicked)="hourSegmentClicked.emit($event)"
      (eventTimesChanged)="eventTimesChanged.emit($event)"
      (beforeViewRender)="beforeViewRender.emit($event)"
    ></mwl-calendar-week-view>
  `
    }]
  }], null, {
    viewDate: [{
      type: Input
    }],
    events: [{
      type: Input
    }],
    hourSegments: [{
      type: Input
    }],
    hourSegmentHeight: [{
      type: Input
    }],
    hourDuration: [{
      type: Input
    }],
    minimumEventHeight: [{
      type: Input
    }],
    dayStartHour: [{
      type: Input
    }],
    dayStartMinute: [{
      type: Input
    }],
    dayEndHour: [{
      type: Input
    }],
    dayEndMinute: [{
      type: Input
    }],
    refresh: [{
      type: Input
    }],
    locale: [{
      type: Input
    }],
    eventSnapSize: [{
      type: Input
    }],
    tooltipPlacement: [{
      type: Input
    }],
    tooltipTemplate: [{
      type: Input
    }],
    tooltipAppendToBody: [{
      type: Input
    }],
    tooltipDelay: [{
      type: Input
    }],
    hourSegmentTemplate: [{
      type: Input
    }],
    eventTemplate: [{
      type: Input
    }],
    eventTitleTemplate: [{
      type: Input
    }],
    eventActionsTemplate: [{
      type: Input
    }],
    snapDraggedEvents: [{
      type: Input
    }],
    allDayEventsLabelTemplate: [{
      type: Input
    }],
    currentTimeMarkerTemplate: [{
      type: Input
    }],
    validateEventTimesChanged: [{
      type: Input
    }],
    resizeCursors: [{
      type: Input
    }],
    eventClicked: [{
      type: Output
    }],
    hourSegmentClicked: [{
      type: Output
    }],
    eventTimesChanged: [{
      type: Output
    }],
    beforeViewRender: [{
      type: Output
    }]
  });
})();
var CalendarDayModule = class {
};
CalendarDayModule.ɵfac = function CalendarDayModule_Factory(t) {
  return new (t || CalendarDayModule)();
};
CalendarDayModule.ɵmod = ɵɵdefineNgModule({
  type: CalendarDayModule,
  declarations: [CalendarDayViewComponent],
  imports: [CommonModule, CalendarCommonModule, CalendarWeekModule],
  exports: [CalendarDayViewComponent]
});
CalendarDayModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, CalendarCommonModule, CalendarWeekModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarDayModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, CalendarCommonModule, CalendarWeekModule],
      declarations: [CalendarDayViewComponent],
      exports: [CalendarDayViewComponent]
    }]
  }], null, null);
})();
var CalendarModule = class _CalendarModule {
  static forRoot(dateAdapter, config = {}) {
    return {
      ngModule: _CalendarModule,
      providers: [dateAdapter, config.eventTitleFormatter || CalendarEventTitleFormatter, config.dateFormatter || CalendarDateFormatter, config.utils || CalendarUtils, config.a11y || CalendarA11y]
    };
  }
};
CalendarModule.ɵfac = function CalendarModule_Factory(t) {
  return new (t || CalendarModule)();
};
CalendarModule.ɵmod = ɵɵdefineNgModule({
  type: CalendarModule,
  imports: [CalendarCommonModule, CalendarMonthModule, CalendarWeekModule, CalendarDayModule],
  exports: [CalendarCommonModule, CalendarMonthModule, CalendarWeekModule, CalendarDayModule]
});
CalendarModule.ɵinj = ɵɵdefineInjector({
  imports: [CalendarCommonModule, CalendarMonthModule, CalendarWeekModule, CalendarDayModule, CalendarCommonModule, CalendarMonthModule, CalendarWeekModule, CalendarDayModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarModule, [{
    type: NgModule,
    args: [{
      imports: [CalendarCommonModule, CalendarMonthModule, CalendarWeekModule, CalendarDayModule],
      exports: [CalendarCommonModule, CalendarMonthModule, CalendarWeekModule, CalendarDayModule]
    }]
  }], null, null);
})();

// node_modules/date-fns/constants.js
var daysInYear = 365.2425;
var maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1e3;
var minTime = -maxTime;
var millisecondsInWeek = 6048e5;
var millisecondsInDay = 864e5;
var millisecondsInMinute = 6e4;
var millisecondsInHour = 36e5;
var millisecondsInSecond = 1e3;
var secondsInHour = 3600;
var secondsInDay = secondsInHour * 24;
var secondsInWeek = secondsInDay * 7;
var secondsInYear = secondsInDay * daysInYear;
var secondsInMonth = secondsInYear / 12;
var secondsInQuarter = secondsInMonth * 3;
var constructFromSymbol = Symbol.for("constructDateFrom");

// node_modules/date-fns/constructFrom.js
function constructFrom(date, value) {
  if (typeof date === "function") return date(value);
  if (date && typeof date === "object" && constructFromSymbol in date)
    return date[constructFromSymbol](value);
  if (date instanceof Date) return new date.constructor(value);
  return new Date(value);
}

// node_modules/date-fns/toDate.js
function toDate(argument, context) {
  return constructFrom(context || argument, argument);
}

// node_modules/date-fns/addDays.js
function addDays(date, amount, options) {
  const _date = toDate(date, options?.in);
  if (isNaN(amount)) return constructFrom(options?.in || date, NaN);
  if (!amount) return _date;
  _date.setDate(_date.getDate() + amount);
  return _date;
}

// node_modules/date-fns/_lib/defaultOptions.js
var defaultOptions = {};
function getDefaultOptions() {
  return defaultOptions;
}

// node_modules/date-fns/startOfWeek.js
function startOfWeek(date, options) {
  const defaultOptions2 = getDefaultOptions();
  const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions2.weekStartsOn ?? defaultOptions2.locale?.options?.weekStartsOn ?? 0;
  const _date = toDate(date, options?.in);
  const day = _date.getDay();
  const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  _date.setDate(_date.getDate() - diff);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

// node_modules/date-fns/startOfISOWeek.js
function startOfISOWeek(date, options) {
  return startOfWeek(date, __spreadProps(__spreadValues({}, options), { weekStartsOn: 1 }));
}

// node_modules/date-fns/getISOWeekYear.js
function getISOWeekYear(date, options) {
  const _date = toDate(date, options?.in);
  const year = _date.getFullYear();
  const fourthOfJanuaryOfNextYear = constructFrom(_date, 0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
  const fourthOfJanuaryOfThisYear = constructFrom(_date, 0);
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds.js
function getTimezoneOffsetInMilliseconds(date) {
  const _date = toDate(date);
  const utcDate = new Date(
    Date.UTC(
      _date.getFullYear(),
      _date.getMonth(),
      _date.getDate(),
      _date.getHours(),
      _date.getMinutes(),
      _date.getSeconds(),
      _date.getMilliseconds()
    )
  );
  utcDate.setUTCFullYear(_date.getFullYear());
  return +date - +utcDate;
}

// node_modules/date-fns/_lib/normalizeDates.js
function normalizeDates(context, ...dates) {
  const normalize = constructFrom.bind(
    null,
    context || dates.find((date) => typeof date === "object")
  );
  return dates.map(normalize);
}

// node_modules/date-fns/startOfDay.js
function startOfDay(date, options) {
  const _date = toDate(date, options?.in);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

// node_modules/date-fns/differenceInCalendarDays.js
function differenceInCalendarDays(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options?.in,
    laterDate,
    earlierDate
  );
  const laterStartOfDay = startOfDay(laterDate_);
  const earlierStartOfDay = startOfDay(earlierDate_);
  const laterTimestamp = +laterStartOfDay - getTimezoneOffsetInMilliseconds(laterStartOfDay);
  const earlierTimestamp = +earlierStartOfDay - getTimezoneOffsetInMilliseconds(earlierStartOfDay);
  return Math.round((laterTimestamp - earlierTimestamp) / millisecondsInDay);
}

// node_modules/date-fns/startOfISOWeekYear.js
function startOfISOWeekYear(date, options) {
  const year = getISOWeekYear(date, options);
  const fourthOfJanuary = constructFrom(options?.in || date, 0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  return startOfISOWeek(fourthOfJanuary);
}

// node_modules/date-fns/isDate.js
function isDate(value) {
  return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
}

// node_modules/date-fns/isValid.js
function isValid(date) {
  return !(!isDate(date) && typeof date !== "number" || isNaN(+toDate(date)));
}

// node_modules/date-fns/startOfYear.js
function startOfYear(date, options) {
  const date_ = toDate(date, options?.in);
  date_.setFullYear(date_.getFullYear(), 0, 1);
  date_.setHours(0, 0, 0, 0);
  return date_;
}

// node_modules/date-fns/locale/en-US/_lib/formatDistance.js
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
var formatDistance = (token, count2, options) => {
  let result;
  const tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count2 === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count2.toString());
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};

// node_modules/date-fns/locale/_lib/buildFormatLongFn.js
function buildFormatLongFn(args) {
  return (options = {}) => {
    const width = options.width ? String(options.width) : args.defaultWidth;
    const format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}

// node_modules/date-fns/locale/en-US/_lib/formatLong.js
var dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};

// node_modules/date-fns/locale/en-US/_lib/formatRelative.js
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
var formatRelative = (token, _date, _baseDate, _options) => formatRelativeLocale[token];

// node_modules/date-fns/locale/_lib/buildLocalizeFn.js
function buildLocalizeFn(args) {
  return (value, options) => {
    const context = options?.context ? String(options.context) : "standalone";
    let valuesArray;
    if (context === "formatting" && args.formattingValues) {
      const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      const width = options?.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      const defaultWidth = args.defaultWidth;
      const width = options?.width ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[width] || args.values[defaultWidth];
    }
    const index = args.argumentCallback ? args.argumentCallback(value) : value;
    return valuesArray[index];
  };
}

// node_modules/date-fns/locale/en-US/_lib/localize.js
var eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
var monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ]
};
var dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ]
};
var dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
var ordinalNumber = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  const rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
};
var localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};

// node_modules/date-fns/locale/_lib/buildMatchFn.js
function buildMatchFn(args) {
  return (string, options = {}) => {
    const width = options.width;
    const matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    const matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    const matchedString = matchResult[0];
    const parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    const key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString)) : (
      // [TODO] -- I challenge you to fix the type
      findKey(parsePatterns, (pattern) => pattern.test(matchedString))
    );
    let value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? (
      // [TODO] -- I challenge you to fix the type
      options.valueCallback(value)
    ) : value;
    const rest = string.slice(matchedString.length);
    return { value, rest };
  };
}
function findKey(object, predicate) {
  for (const key in object) {
    if (Object.prototype.hasOwnProperty.call(object, key) && predicate(object[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex(array, predicate) {
  for (let key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return void 0;
}

// node_modules/date-fns/locale/_lib/buildMatchPatternFn.js
function buildMatchPatternFn(args) {
  return (string, options = {}) => {
    const matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    const matchedString = matchResult[0];
    const parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    let value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    const rest = string.slice(matchedString.length);
    return { value, rest };
  };
}

// node_modules/date-fns/locale/en-US/_lib/match.js
var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};

// node_modules/date-fns/locale/en-US.js
var enUS = {
  code: "en-US",
  formatDistance,
  formatLong,
  formatRelative,
  localize,
  match,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};

// node_modules/date-fns/getDayOfYear.js
function getDayOfYear(date, options) {
  const _date = toDate(date, options?.in);
  const diff = differenceInCalendarDays(_date, startOfYear(_date));
  const dayOfYear = diff + 1;
  return dayOfYear;
}

// node_modules/date-fns/getISOWeek.js
function getISOWeek(date, options) {
  const _date = toDate(date, options?.in);
  const diff = +startOfISOWeek(_date) - +startOfISOWeekYear(_date);
  return Math.round(diff / millisecondsInWeek) + 1;
}

// node_modules/date-fns/getWeekYear.js
function getWeekYear(date, options) {
  const _date = toDate(date, options?.in);
  const year = _date.getFullYear();
  const defaultOptions2 = getDefaultOptions();
  const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
  const firstWeekOfNextYear = constructFrom(options?.in || date, 0);
  firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfWeek(firstWeekOfNextYear, options);
  const firstWeekOfThisYear = constructFrom(options?.in || date, 0);
  firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfWeek(firstWeekOfThisYear, options);
  if (+_date >= +startOfNextYear) {
    return year + 1;
  } else if (+_date >= +startOfThisYear) {
    return year;
  } else {
    return year - 1;
  }
}

// node_modules/date-fns/startOfWeekYear.js
function startOfWeekYear(date, options) {
  const defaultOptions2 = getDefaultOptions();
  const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
  const year = getWeekYear(date, options);
  const firstWeek = constructFrom(options?.in || date, 0);
  firstWeek.setFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  const _date = startOfWeek(firstWeek, options);
  return _date;
}

// node_modules/date-fns/getWeek.js
function getWeek(date, options) {
  const _date = toDate(date, options?.in);
  const diff = +startOfWeek(_date, options) - +startOfWeekYear(_date, options);
  return Math.round(diff / millisecondsInWeek) + 1;
}

// node_modules/date-fns/_lib/addLeadingZeros.js
function addLeadingZeros(number, targetLength) {
  const sign = number < 0 ? "-" : "";
  const output = Math.abs(number).toString().padStart(targetLength, "0");
  return sign + output;
}

// node_modules/date-fns/_lib/format/lightFormatters.js
var lightFormatters = {
  // Year
  y(date, token) {
    const signedYear = date.getFullYear();
    const year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
  },
  // Month
  M(date, token) {
    const month = date.getMonth();
    return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  // Day of the month
  d(date, token) {
    return addLeadingZeros(date.getDate(), token.length);
  },
  // AM or PM
  a(date, token) {
    const dayPeriodEnumValue = date.getHours() / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h(date, token) {
    return addLeadingZeros(date.getHours() % 12 || 12, token.length);
  },
  // Hour [0-23]
  H(date, token) {
    return addLeadingZeros(date.getHours(), token.length);
  },
  // Minute
  m(date, token) {
    return addLeadingZeros(date.getMinutes(), token.length);
  },
  // Second
  s(date, token) {
    return addLeadingZeros(date.getSeconds(), token.length);
  },
  // Fraction of second
  S(date, token) {
    const numberOfDigits = token.length;
    const milliseconds = date.getMilliseconds();
    const fractionalSeconds = Math.trunc(
      milliseconds * Math.pow(10, numberOfDigits - 3)
    );
    return addLeadingZeros(fractionalSeconds, token.length);
  }
};

// node_modules/date-fns/_lib/format/formatters.js
var dayPeriodEnum = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
var formatters = {
  // Era
  G: function(date, token, localize2) {
    const era = date.getFullYear() > 0 ? 1 : 0;
    switch (token) {
      case "G":
      case "GG":
      case "GGG":
        return localize2.era(era, { width: "abbreviated" });
      case "GGGGG":
        return localize2.era(era, { width: "narrow" });
      case "GGGG":
      default:
        return localize2.era(era, { width: "wide" });
    }
  },
  // Year
  y: function(date, token, localize2) {
    if (token === "yo") {
      const signedYear = date.getFullYear();
      const year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize2.ordinalNumber(year, { unit: "year" });
    }
    return lightFormatters.y(date, token);
  },
  // Local week-numbering year
  Y: function(date, token, localize2, options) {
    const signedWeekYear = getWeekYear(date, options);
    const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token === "YY") {
      const twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }
    if (token === "Yo") {
      return localize2.ordinalNumber(weekYear, { unit: "year" });
    }
    return addLeadingZeros(weekYear, token.length);
  },
  // ISO week-numbering year
  R: function(date, token) {
    const isoWeekYear = getISOWeekYear(date);
    return addLeadingZeros(isoWeekYear, token.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function(date, token) {
    const year = date.getFullYear();
    return addLeadingZeros(year, token.length);
  },
  // Quarter
  Q: function(date, token, localize2) {
    const quarter = Math.ceil((date.getMonth() + 1) / 3);
    switch (token) {
      case "Q":
        return String(quarter);
      case "QQ":
        return addLeadingZeros(quarter, 2);
      case "Qo":
        return localize2.ordinalNumber(quarter, { unit: "quarter" });
      case "QQQ":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function(date, token, localize2) {
    const quarter = Math.ceil((date.getMonth() + 1) / 3);
    switch (token) {
      case "q":
        return String(quarter);
      case "qq":
        return addLeadingZeros(quarter, 2);
      case "qo":
        return localize2.ordinalNumber(quarter, { unit: "quarter" });
      case "qqq":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function(date, token, localize2) {
    const month = date.getMonth();
    switch (token) {
      case "M":
      case "MM":
        return lightFormatters.M(date, token);
      case "Mo":
        return localize2.ordinalNumber(month + 1, { unit: "month" });
      case "MMM":
        return localize2.month(month, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return localize2.month(month, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return localize2.month(month, { width: "wide", context: "formatting" });
    }
  },
  // Stand-alone month
  L: function(date, token, localize2) {
    const month = date.getMonth();
    switch (token) {
      case "L":
        return String(month + 1);
      case "LL":
        return addLeadingZeros(month + 1, 2);
      case "Lo":
        return localize2.ordinalNumber(month + 1, { unit: "month" });
      case "LLL":
        return localize2.month(month, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return localize2.month(month, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return localize2.month(month, { width: "wide", context: "standalone" });
    }
  },
  // Local week of year
  w: function(date, token, localize2, options) {
    const week = getWeek(date, options);
    if (token === "wo") {
      return localize2.ordinalNumber(week, { unit: "week" });
    }
    return addLeadingZeros(week, token.length);
  },
  // ISO week of year
  I: function(date, token, localize2) {
    const isoWeek = getISOWeek(date);
    if (token === "Io") {
      return localize2.ordinalNumber(isoWeek, { unit: "week" });
    }
    return addLeadingZeros(isoWeek, token.length);
  },
  // Day of the month
  d: function(date, token, localize2) {
    if (token === "do") {
      return localize2.ordinalNumber(date.getDate(), { unit: "date" });
    }
    return lightFormatters.d(date, token);
  },
  // Day of year
  D: function(date, token, localize2) {
    const dayOfYear = getDayOfYear(date);
    if (token === "Do") {
      return localize2.ordinalNumber(dayOfYear, { unit: "dayOfYear" });
    }
    return addLeadingZeros(dayOfYear, token.length);
  },
  // Day of week
  E: function(date, token, localize2) {
    const dayOfWeek = date.getDay();
    switch (token) {
      case "E":
      case "EE":
      case "EEE":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function(date, token, localize2, options) {
    const dayOfWeek = date.getDay();
    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "e":
        return String(localDayOfWeek);
      case "ee":
        return addLeadingZeros(localDayOfWeek, 2);
      case "eo":
        return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "eee":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function(date, token, localize2, options) {
    const dayOfWeek = date.getDay();
    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "c":
        return String(localDayOfWeek);
      case "cc":
        return addLeadingZeros(localDayOfWeek, token.length);
      case "co":
        return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "ccc":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function(date, token, localize2) {
    const dayOfWeek = date.getDay();
    const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token) {
      case "i":
        return String(isoDayOfWeek);
      case "ii":
        return addLeadingZeros(isoDayOfWeek, token.length);
      case "io":
        return localize2.ordinalNumber(isoDayOfWeek, { unit: "day" });
      case "iii":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function(date, token, localize2) {
    const hours = date.getHours();
    const dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function(date, token, localize2) {
    const hours = date.getHours();
    let dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }
    switch (token) {
      case "b":
      case "bb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function(date, token, localize2) {
    const hours = date.getHours();
    let dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function(date, token, localize2) {
    if (token === "ho") {
      let hours = date.getHours() % 12;
      if (hours === 0) hours = 12;
      return localize2.ordinalNumber(hours, { unit: "hour" });
    }
    return lightFormatters.h(date, token);
  },
  // Hour [0-23]
  H: function(date, token, localize2) {
    if (token === "Ho") {
      return localize2.ordinalNumber(date.getHours(), { unit: "hour" });
    }
    return lightFormatters.H(date, token);
  },
  // Hour [0-11]
  K: function(date, token, localize2) {
    const hours = date.getHours() % 12;
    if (token === "Ko") {
      return localize2.ordinalNumber(hours, { unit: "hour" });
    }
    return addLeadingZeros(hours, token.length);
  },
  // Hour [1-24]
  k: function(date, token, localize2) {
    let hours = date.getHours();
    if (hours === 0) hours = 24;
    if (token === "ko") {
      return localize2.ordinalNumber(hours, { unit: "hour" });
    }
    return addLeadingZeros(hours, token.length);
  },
  // Minute
  m: function(date, token, localize2) {
    if (token === "mo") {
      return localize2.ordinalNumber(date.getMinutes(), { unit: "minute" });
    }
    return lightFormatters.m(date, token);
  },
  // Second
  s: function(date, token, localize2) {
    if (token === "so") {
      return localize2.ordinalNumber(date.getSeconds(), { unit: "second" });
    }
    return lightFormatters.s(date, token);
  },
  // Fraction of second
  S: function(date, token) {
    return lightFormatters.S(date, token);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token) {
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      case "XXXXX":
      case "XXX":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    switch (token) {
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      case "xxxxx":
      case "xxx":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (GMT)
  O: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    switch (token) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    switch (token) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Seconds timestamp
  t: function(date, token, _localize) {
    const timestamp = Math.trunc(+date / 1e3);
    return addLeadingZeros(timestamp, token.length);
  },
  // Milliseconds timestamp
  T: function(date, token, _localize) {
    return addLeadingZeros(+date, token.length);
  }
};
function formatTimezoneShort(offset, delimiter = "") {
  const sign = offset > 0 ? "-" : "+";
  const absOffset = Math.abs(offset);
  const hours = Math.trunc(absOffset / 60);
  const minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset, delimiter) {
  if (offset % 60 === 0) {
    const sign = offset > 0 ? "-" : "+";
    return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
  }
  return formatTimezone(offset, delimiter);
}
function formatTimezone(offset, delimiter = "") {
  const sign = offset > 0 ? "-" : "+";
  const absOffset = Math.abs(offset);
  const hours = addLeadingZeros(Math.trunc(absOffset / 60), 2);
  const minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}

// node_modules/date-fns/_lib/format/longFormatters.js
var dateLongFormatter = (pattern, formatLong2) => {
  switch (pattern) {
    case "P":
      return formatLong2.date({ width: "short" });
    case "PP":
      return formatLong2.date({ width: "medium" });
    case "PPP":
      return formatLong2.date({ width: "long" });
    case "PPPP":
    default:
      return formatLong2.date({ width: "full" });
  }
};
var timeLongFormatter = (pattern, formatLong2) => {
  switch (pattern) {
    case "p":
      return formatLong2.time({ width: "short" });
    case "pp":
      return formatLong2.time({ width: "medium" });
    case "ppp":
      return formatLong2.time({ width: "long" });
    case "pppp":
    default:
      return formatLong2.time({ width: "full" });
  }
};
var dateTimeLongFormatter = (pattern, formatLong2) => {
  const matchResult = pattern.match(/(P+)(p+)?/) || [];
  const datePattern = matchResult[1];
  const timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong2);
  }
  let dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong2.dateTime({ width: "short" });
      break;
    case "PP":
      dateTimeFormat = formatLong2.dateTime({ width: "medium" });
      break;
    case "PPP":
      dateTimeFormat = formatLong2.dateTime({ width: "long" });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong2.dateTime({ width: "full" });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
};
var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};

// node_modules/date-fns/_lib/protectedTokens.js
var dayOfYearTokenRE = /^D+$/;
var weekYearTokenRE = /^Y+$/;
var throwTokens = ["D", "DD", "YY", "YYYY"];
function isProtectedDayOfYearToken(token) {
  return dayOfYearTokenRE.test(token);
}
function isProtectedWeekYearToken(token) {
  return weekYearTokenRE.test(token);
}
function warnOrThrowProtectedError(token, format2, input) {
  const _message = message(token, format2, input);
  console.warn(_message);
  if (throwTokens.includes(token)) throw new RangeError(_message);
}
function message(token, format2, input) {
  const subject = token[0] === "Y" ? "years" : "days of the month";
  return `Use \`${token.toLowerCase()}\` instead of \`${token}\` (in \`${format2}\`) for formatting ${subject} to the input \`${input}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}

// node_modules/date-fns/format.js
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function format(date, formatStr, options) {
  const defaultOptions2 = getDefaultOptions();
  const locale = options?.locale ?? defaultOptions2.locale ?? enUS;
  const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
  const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions2.weekStartsOn ?? defaultOptions2.locale?.options?.weekStartsOn ?? 0;
  const originalDate = toDate(date, options?.in);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  let parts = formatStr.match(longFormattingTokensRegExp).map((substring) => {
    const firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      const longFormatter = longFormatters[firstCharacter];
      return longFormatter(substring, locale.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp).map((substring) => {
    if (substring === "''") {
      return { isToken: false, value: "'" };
    }
    const firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return { isToken: false, value: cleanEscapedString(substring) };
    }
    if (formatters[firstCharacter]) {
      return { isToken: true, value: substring };
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError(
        "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
      );
    }
    return { isToken: false, value: substring };
  });
  if (locale.localize.preprocessor) {
    parts = locale.localize.preprocessor(originalDate, parts);
  }
  const formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale
  };
  return parts.map((part) => {
    if (!part.isToken) return part.value;
    const token = part.value;
    if (!options?.useAdditionalWeekYearTokens && isProtectedWeekYearToken(token) || !options?.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(token)) {
      warnOrThrowProtectedError(token, formatStr, String(date));
    }
    const formatter = formatters[token[0]];
    return formatter(originalDate, token, locale.localize, formatterOptions);
  }).join("");
}
function cleanEscapedString(input) {
  const matched = input.match(escapedStringRegExp);
  if (!matched) {
    return input;
  }
  return matched[1].replace(doubleQuoteRegExp, "'");
}

// node_modules/date-fns/getISODay.js
function getISODay(date, options) {
  const day = toDate(date, options?.in).getDay();
  return day === 0 ? 7 : day;
}

// node_modules/date-fns/parse/_lib/Setter.js
var Setter = class {
  subPriority = 0;
  validate(_utcDate, _options) {
    return true;
  }
};
var ValueSetter = class extends Setter {
  constructor(value, validateValue, setValue, priority, subPriority) {
    super();
    this.value = value;
    this.validateValue = validateValue;
    this.setValue = setValue;
    this.priority = priority;
    if (subPriority) {
      this.subPriority = subPriority;
    }
  }
  validate(date, options) {
    return this.validateValue(date, this.value, options);
  }
  set(date, flags, options) {
    return this.setValue(date, flags, this.value, options);
  }
};

// node_modules/date-fns/parse/_lib/Parser.js
var Parser = class {
  run(dateString, token, match2, options) {
    const result = this.parse(dateString, token, match2, options);
    if (!result) {
      return null;
    }
    return {
      setter: new ValueSetter(
        result.value,
        this.validate,
        this.set,
        this.priority,
        this.subPriority
      ),
      rest: result.rest
    };
  }
  validate(_utcDate, _value, _options) {
    return true;
  }
};

// node_modules/date-fns/parse/_lib/parsers/EraParser.js
var EraParser = class extends Parser {
  priority = 140;
  parse(dateString, token, match2) {
    switch (token) {
      case "G":
      case "GG":
      case "GGG":
        return match2.era(dateString, { width: "abbreviated" }) || match2.era(dateString, { width: "narrow" });
      case "GGGGG":
        return match2.era(dateString, { width: "narrow" });
      case "GGGG":
      default:
        return match2.era(dateString, { width: "wide" }) || match2.era(dateString, { width: "abbreviated" }) || match2.era(dateString, { width: "narrow" });
    }
  }
  set(date, flags, value) {
    flags.era = value;
    date.setFullYear(value, 0, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
  incompatibleTokens = ["R", "u", "t", "T"];
};

// node_modules/date-fns/parse/_lib/constants.js
var numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59
  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/
  // 0 to 9999, -0 to -9999
};
var timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};

// node_modules/date-fns/parse/_lib/utils.js
function mapValue(parseFnResult, mapFn) {
  if (!parseFnResult) {
    return parseFnResult;
  }
  return {
    value: mapFn(parseFnResult.value),
    rest: parseFnResult.rest
  };
}
function parseNumericPattern(pattern, dateString) {
  const matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  return {
    value: parseInt(matchResult[0], 10),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseTimezonePattern(pattern, dateString) {
  const matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  if (matchResult[0] === "Z") {
    return {
      value: 0,
      rest: dateString.slice(1)
    };
  }
  const sign = matchResult[1] === "+" ? 1 : -1;
  const hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  const minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  const seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseAnyDigitsSigned(dateString) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
}
function parseNDigits(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, dateString);
    default:
      return parseNumericPattern(new RegExp("^\\d{1," + n + "}"), dateString);
  }
}
function parseNDigitsSigned(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
    default:
      return parseNumericPattern(new RegExp("^-?\\d{1," + n + "}"), dateString);
  }
}
function dayPeriodEnumToHours(dayPeriod) {
  switch (dayPeriod) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  const isCommonEra = currentYear > 0;
  const absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  let result;
  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    const rangeEnd = absCurrentYear + 50;
    const rangeEndCentury = Math.trunc(rangeEnd / 100) * 100;
    const isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }
  return isCommonEra ? result : 1 - result;
}
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}

// node_modules/date-fns/parse/_lib/parsers/YearParser.js
var YearParser = class extends Parser {
  priority = 130;
  incompatibleTokens = ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"];
  parse(dateString, token, match2) {
    const valueCallback = (year) => ({
      year,
      isTwoDigitYear: token === "yy"
    });
    switch (token) {
      case "y":
        return mapValue(parseNDigits(4, dateString), valueCallback);
      case "yo":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "year"
          }),
          valueCallback
        );
      default:
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
    }
  }
  validate(_date, value) {
    return value.isTwoDigitYear || value.year > 0;
  }
  set(date, flags, value) {
    const currentYear = date.getFullYear();
    if (value.isTwoDigitYear) {
      const normalizedTwoDigitYear = normalizeTwoDigitYear(
        value.year,
        currentYear
      );
      date.setFullYear(normalizedTwoDigitYear, 0, 1);
      date.setHours(0, 0, 0, 0);
      return date;
    }
    const year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
    date.setFullYear(year, 0, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/LocalWeekYearParser.js
var LocalWeekYearParser = class extends Parser {
  priority = 130;
  parse(dateString, token, match2) {
    const valueCallback = (year) => ({
      year,
      isTwoDigitYear: token === "YY"
    });
    switch (token) {
      case "Y":
        return mapValue(parseNDigits(4, dateString), valueCallback);
      case "Yo":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "year"
          }),
          valueCallback
        );
      default:
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
    }
  }
  validate(_date, value) {
    return value.isTwoDigitYear || value.year > 0;
  }
  set(date, flags, value, options) {
    const currentYear = getWeekYear(date, options);
    if (value.isTwoDigitYear) {
      const normalizedTwoDigitYear = normalizeTwoDigitYear(
        value.year,
        currentYear
      );
      date.setFullYear(
        normalizedTwoDigitYear,
        0,
        options.firstWeekContainsDate
      );
      date.setHours(0, 0, 0, 0);
      return startOfWeek(date, options);
    }
    const year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
    date.setFullYear(year, 0, options.firstWeekContainsDate);
    date.setHours(0, 0, 0, 0);
    return startOfWeek(date, options);
  }
  incompatibleTokens = [
    "y",
    "R",
    "u",
    "Q",
    "q",
    "M",
    "L",
    "I",
    "d",
    "D",
    "i",
    "t",
    "T"
  ];
};

// node_modules/date-fns/parse/_lib/parsers/ISOWeekYearParser.js
var ISOWeekYearParser = class extends Parser {
  priority = 130;
  parse(dateString, token) {
    if (token === "R") {
      return parseNDigitsSigned(4, dateString);
    }
    return parseNDigitsSigned(token.length, dateString);
  }
  set(date, _flags, value) {
    const firstWeekOfYear = constructFrom(date, 0);
    firstWeekOfYear.setFullYear(value, 0, 4);
    firstWeekOfYear.setHours(0, 0, 0, 0);
    return startOfISOWeek(firstWeekOfYear);
  }
  incompatibleTokens = [
    "G",
    "y",
    "Y",
    "u",
    "Q",
    "q",
    "M",
    "L",
    "w",
    "d",
    "D",
    "e",
    "c",
    "t",
    "T"
  ];
};

// node_modules/date-fns/parse/_lib/parsers/ExtendedYearParser.js
var ExtendedYearParser = class extends Parser {
  priority = 130;
  parse(dateString, token) {
    if (token === "u") {
      return parseNDigitsSigned(4, dateString);
    }
    return parseNDigitsSigned(token.length, dateString);
  }
  set(date, _flags, value) {
    date.setFullYear(value, 0, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
  incompatibleTokens = ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"];
};

// node_modules/date-fns/parse/_lib/parsers/QuarterParser.js
var QuarterParser = class extends Parser {
  priority = 120;
  parse(dateString, token, match2) {
    switch (token) {
      case "Q":
      case "QQ":
        return parseNDigits(token.length, dateString);
      case "Qo":
        return match2.ordinalNumber(dateString, { unit: "quarter" });
      case "QQQ":
        return match2.quarter(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.quarter(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQQ":
        return match2.quarter(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return match2.quarter(dateString, {
          width: "wide",
          context: "formatting"
        }) || match2.quarter(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.quarter(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 4;
  }
  set(date, _flags, value) {
    date.setMonth((value - 1) * 3, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
  incompatibleTokens = [
    "Y",
    "R",
    "q",
    "M",
    "L",
    "w",
    "I",
    "d",
    "D",
    "i",
    "e",
    "c",
    "t",
    "T"
  ];
};

// node_modules/date-fns/parse/_lib/parsers/StandAloneQuarterParser.js
var StandAloneQuarterParser = class extends Parser {
  priority = 120;
  parse(dateString, token, match2) {
    switch (token) {
      case "q":
      case "qq":
        return parseNDigits(token.length, dateString);
      case "qo":
        return match2.ordinalNumber(dateString, { unit: "quarter" });
      case "qqq":
        return match2.quarter(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.quarter(dateString, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqqq":
        return match2.quarter(dateString, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return match2.quarter(dateString, {
          width: "wide",
          context: "standalone"
        }) || match2.quarter(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.quarter(dateString, {
          width: "narrow",
          context: "standalone"
        });
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 4;
  }
  set(date, _flags, value) {
    date.setMonth((value - 1) * 3, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
  incompatibleTokens = [
    "Y",
    "R",
    "Q",
    "M",
    "L",
    "w",
    "I",
    "d",
    "D",
    "i",
    "e",
    "c",
    "t",
    "T"
  ];
};

// node_modules/date-fns/parse/_lib/parsers/MonthParser.js
var MonthParser = class extends Parser {
  incompatibleTokens = [
    "Y",
    "R",
    "q",
    "Q",
    "L",
    "w",
    "I",
    "D",
    "i",
    "e",
    "c",
    "t",
    "T"
  ];
  priority = 110;
  parse(dateString, token, match2) {
    const valueCallback = (value) => value - 1;
    switch (token) {
      case "M":
        return mapValue(
          parseNumericPattern(numericPatterns.month, dateString),
          valueCallback
        );
      case "MM":
        return mapValue(parseNDigits(2, dateString), valueCallback);
      case "Mo":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "month"
          }),
          valueCallback
        );
      case "MMM":
        return match2.month(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.month(dateString, { width: "narrow", context: "formatting" });
      case "MMMMM":
        return match2.month(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return match2.month(dateString, { width: "wide", context: "formatting" }) || match2.month(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.month(dateString, { width: "narrow", context: "formatting" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 11;
  }
  set(date, _flags, value) {
    date.setMonth(value, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/StandAloneMonthParser.js
var StandAloneMonthParser = class extends Parser {
  priority = 110;
  parse(dateString, token, match2) {
    const valueCallback = (value) => value - 1;
    switch (token) {
      case "L":
        return mapValue(
          parseNumericPattern(numericPatterns.month, dateString),
          valueCallback
        );
      case "LL":
        return mapValue(parseNDigits(2, dateString), valueCallback);
      case "Lo":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "month"
          }),
          valueCallback
        );
      case "LLL":
        return match2.month(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.month(dateString, { width: "narrow", context: "standalone" });
      case "LLLLL":
        return match2.month(dateString, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return match2.month(dateString, { width: "wide", context: "standalone" }) || match2.month(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.month(dateString, { width: "narrow", context: "standalone" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 11;
  }
  set(date, _flags, value) {
    date.setMonth(value, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
  incompatibleTokens = [
    "Y",
    "R",
    "q",
    "Q",
    "M",
    "w",
    "I",
    "D",
    "i",
    "e",
    "c",
    "t",
    "T"
  ];
};

// node_modules/date-fns/setWeek.js
function setWeek(date, week, options) {
  const date_ = toDate(date, options?.in);
  const diff = getWeek(date_, options) - week;
  date_.setDate(date_.getDate() - diff * 7);
  return toDate(date_, options?.in);
}

// node_modules/date-fns/parse/_lib/parsers/LocalWeekParser.js
var LocalWeekParser = class extends Parser {
  priority = 100;
  parse(dateString, token, match2) {
    switch (token) {
      case "w":
        return parseNumericPattern(numericPatterns.week, dateString);
      case "wo":
        return match2.ordinalNumber(dateString, { unit: "week" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 53;
  }
  set(date, _flags, value, options) {
    return startOfWeek(setWeek(date, value, options), options);
  }
  incompatibleTokens = [
    "y",
    "R",
    "u",
    "q",
    "Q",
    "M",
    "L",
    "I",
    "d",
    "D",
    "i",
    "t",
    "T"
  ];
};

// node_modules/date-fns/setISOWeek.js
function setISOWeek(date, week, options) {
  const _date = toDate(date, options?.in);
  const diff = getISOWeek(_date, options) - week;
  _date.setDate(_date.getDate() - diff * 7);
  return _date;
}

// node_modules/date-fns/parse/_lib/parsers/ISOWeekParser.js
var ISOWeekParser = class extends Parser {
  priority = 100;
  parse(dateString, token, match2) {
    switch (token) {
      case "I":
        return parseNumericPattern(numericPatterns.week, dateString);
      case "Io":
        return match2.ordinalNumber(dateString, { unit: "week" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 53;
  }
  set(date, _flags, value) {
    return startOfISOWeek(setISOWeek(date, value));
  }
  incompatibleTokens = [
    "y",
    "Y",
    "u",
    "q",
    "Q",
    "M",
    "L",
    "w",
    "d",
    "D",
    "e",
    "c",
    "t",
    "T"
  ];
};

// node_modules/date-fns/parse/_lib/parsers/DateParser.js
var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR = [
  31,
  29,
  31,
  30,
  31,
  30,
  31,
  31,
  30,
  31,
  30,
  31
];
var DateParser = class extends Parser {
  priority = 90;
  subPriority = 1;
  parse(dateString, token, match2) {
    switch (token) {
      case "d":
        return parseNumericPattern(numericPatterns.date, dateString);
      case "do":
        return match2.ordinalNumber(dateString, { unit: "date" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(date, value) {
    const year = date.getFullYear();
    const isLeapYear2 = isLeapYearIndex(year);
    const month = date.getMonth();
    if (isLeapYear2) {
      return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
    } else {
      return value >= 1 && value <= DAYS_IN_MONTH[month];
    }
  }
  set(date, _flags, value) {
    date.setDate(value);
    date.setHours(0, 0, 0, 0);
    return date;
  }
  incompatibleTokens = [
    "Y",
    "R",
    "q",
    "Q",
    "w",
    "I",
    "D",
    "i",
    "e",
    "c",
    "t",
    "T"
  ];
};

// node_modules/date-fns/parse/_lib/parsers/DayOfYearParser.js
var DayOfYearParser = class extends Parser {
  priority = 90;
  subpriority = 1;
  parse(dateString, token, match2) {
    switch (token) {
      case "D":
      case "DD":
        return parseNumericPattern(numericPatterns.dayOfYear, dateString);
      case "Do":
        return match2.ordinalNumber(dateString, { unit: "date" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(date, value) {
    const year = date.getFullYear();
    const isLeapYear2 = isLeapYearIndex(year);
    if (isLeapYear2) {
      return value >= 1 && value <= 366;
    } else {
      return value >= 1 && value <= 365;
    }
  }
  set(date, _flags, value) {
    date.setMonth(0, value);
    date.setHours(0, 0, 0, 0);
    return date;
  }
  incompatibleTokens = [
    "Y",
    "R",
    "q",
    "Q",
    "M",
    "L",
    "w",
    "I",
    "d",
    "E",
    "i",
    "e",
    "c",
    "t",
    "T"
  ];
};

// node_modules/date-fns/setDay.js
function setDay(date, day, options) {
  const defaultOptions2 = getDefaultOptions();
  const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions2.weekStartsOn ?? defaultOptions2.locale?.options?.weekStartsOn ?? 0;
  const date_ = toDate(date, options?.in);
  const currentDay = date_.getDay();
  const remainder = day % 7;
  const dayIndex = (remainder + 7) % 7;
  const delta = 7 - weekStartsOn;
  const diff = day < 0 || day > 6 ? day - (currentDay + delta) % 7 : (dayIndex + delta) % 7 - (currentDay + delta) % 7;
  return addDays(date_, diff, options);
}

// node_modules/date-fns/parse/_lib/parsers/DayParser.js
var DayParser = class extends Parser {
  priority = 90;
  parse(dateString, token, match2) {
    switch (token) {
      case "E":
      case "EE":
      case "EEE":
        return match2.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
      case "EEEEE":
        return match2.day(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
      case "EEEE":
      default:
        return match2.day(dateString, { width: "wide", context: "formatting" }) || match2.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 6;
  }
  set(date, _flags, value, options) {
    date = setDay(date, value, options);
    date.setHours(0, 0, 0, 0);
    return date;
  }
  incompatibleTokens = ["D", "i", "e", "c", "t", "T"];
};

// node_modules/date-fns/parse/_lib/parsers/LocalDayParser.js
var LocalDayParser = class extends Parser {
  priority = 90;
  parse(dateString, token, match2, options) {
    const valueCallback = (value) => {
      const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
      return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
    };
    switch (token) {
      case "e":
      case "ee":
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
      case "eo":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "day"
          }),
          valueCallback
        );
      case "eee":
        return match2.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
      case "eeeee":
        return match2.day(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
      case "eeee":
      default:
        return match2.day(dateString, { width: "wide", context: "formatting" }) || match2.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 6;
  }
  set(date, _flags, value, options) {
    date = setDay(date, value, options);
    date.setHours(0, 0, 0, 0);
    return date;
  }
  incompatibleTokens = [
    "y",
    "R",
    "u",
    "q",
    "Q",
    "M",
    "L",
    "I",
    "d",
    "D",
    "E",
    "i",
    "c",
    "t",
    "T"
  ];
};

// node_modules/date-fns/parse/_lib/parsers/StandAloneLocalDayParser.js
var StandAloneLocalDayParser = class extends Parser {
  priority = 90;
  parse(dateString, token, match2, options) {
    const valueCallback = (value) => {
      const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
      return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
    };
    switch (token) {
      case "c":
      case "cc":
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
      case "co":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "day"
          }),
          valueCallback
        );
      case "ccc":
        return match2.day(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.day(dateString, { width: "short", context: "standalone" }) || match2.day(dateString, { width: "narrow", context: "standalone" });
      case "ccccc":
        return match2.day(dateString, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return match2.day(dateString, { width: "short", context: "standalone" }) || match2.day(dateString, { width: "narrow", context: "standalone" });
      case "cccc":
      default:
        return match2.day(dateString, { width: "wide", context: "standalone" }) || match2.day(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.day(dateString, { width: "short", context: "standalone" }) || match2.day(dateString, { width: "narrow", context: "standalone" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 6;
  }
  set(date, _flags, value, options) {
    date = setDay(date, value, options);
    date.setHours(0, 0, 0, 0);
    return date;
  }
  incompatibleTokens = [
    "y",
    "R",
    "u",
    "q",
    "Q",
    "M",
    "L",
    "I",
    "d",
    "D",
    "E",
    "i",
    "e",
    "t",
    "T"
  ];
};

// node_modules/date-fns/setISODay.js
function setISODay(date, day, options) {
  const date_ = toDate(date, options?.in);
  const currentDay = getISODay(date_, options);
  const diff = day - currentDay;
  return addDays(date_, diff, options);
}

// node_modules/date-fns/parse/_lib/parsers/ISODayParser.js
var ISODayParser = class extends Parser {
  priority = 90;
  parse(dateString, token, match2) {
    const valueCallback = (value) => {
      if (value === 0) {
        return 7;
      }
      return value;
    };
    switch (token) {
      case "i":
      case "ii":
        return parseNDigits(token.length, dateString);
      case "io":
        return match2.ordinalNumber(dateString, { unit: "day" });
      case "iii":
        return mapValue(
          match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
      case "iiiii":
        return mapValue(
          match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
      case "iiiiii":
        return mapValue(
          match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
      case "iiii":
      default:
        return mapValue(
          match2.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 7;
  }
  set(date, _flags, value) {
    date = setISODay(date, value);
    date.setHours(0, 0, 0, 0);
    return date;
  }
  incompatibleTokens = [
    "y",
    "Y",
    "u",
    "q",
    "Q",
    "M",
    "L",
    "w",
    "d",
    "D",
    "E",
    "e",
    "c",
    "t",
    "T"
  ];
};

// node_modules/date-fns/parse/_lib/parsers/AMPMParser.js
var AMPMParser = class extends Parser {
  priority = 80;
  parse(dateString, token, match2) {
    switch (token) {
      case "a":
      case "aa":
      case "aaa":
        return match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaaa":
        return match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return match2.dayPeriod(dateString, {
          width: "wide",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(date, _flags, value) {
    date.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
    return date;
  }
  incompatibleTokens = ["b", "B", "H", "k", "t", "T"];
};

// node_modules/date-fns/parse/_lib/parsers/AMPMMidnightParser.js
var AMPMMidnightParser = class extends Parser {
  priority = 80;
  parse(dateString, token, match2) {
    switch (token) {
      case "b":
      case "bb":
      case "bbb":
        return match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbbb":
        return match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return match2.dayPeriod(dateString, {
          width: "wide",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(date, _flags, value) {
    date.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
    return date;
  }
  incompatibleTokens = ["a", "B", "H", "k", "t", "T"];
};

// node_modules/date-fns/parse/_lib/parsers/DayPeriodParser.js
var DayPeriodParser = class extends Parser {
  priority = 80;
  parse(dateString, token, match2) {
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBBB":
        return match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return match2.dayPeriod(dateString, {
          width: "wide",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(date, _flags, value) {
    date.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
    return date;
  }
  incompatibleTokens = ["a", "b", "t", "T"];
};

// node_modules/date-fns/parse/_lib/parsers/Hour1to12Parser.js
var Hour1to12Parser = class extends Parser {
  priority = 70;
  parse(dateString, token, match2) {
    switch (token) {
      case "h":
        return parseNumericPattern(numericPatterns.hour12h, dateString);
      case "ho":
        return match2.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 12;
  }
  set(date, _flags, value) {
    const isPM = date.getHours() >= 12;
    if (isPM && value < 12) {
      date.setHours(value + 12, 0, 0, 0);
    } else if (!isPM && value === 12) {
      date.setHours(0, 0, 0, 0);
    } else {
      date.setHours(value, 0, 0, 0);
    }
    return date;
  }
  incompatibleTokens = ["H", "K", "k", "t", "T"];
};

// node_modules/date-fns/parse/_lib/parsers/Hour0to23Parser.js
var Hour0to23Parser = class extends Parser {
  priority = 70;
  parse(dateString, token, match2) {
    switch (token) {
      case "H":
        return parseNumericPattern(numericPatterns.hour23h, dateString);
      case "Ho":
        return match2.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 23;
  }
  set(date, _flags, value) {
    date.setHours(value, 0, 0, 0);
    return date;
  }
  incompatibleTokens = ["a", "b", "h", "K", "k", "t", "T"];
};

// node_modules/date-fns/parse/_lib/parsers/Hour0To11Parser.js
var Hour0To11Parser = class extends Parser {
  priority = 70;
  parse(dateString, token, match2) {
    switch (token) {
      case "K":
        return parseNumericPattern(numericPatterns.hour11h, dateString);
      case "Ko":
        return match2.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 11;
  }
  set(date, _flags, value) {
    const isPM = date.getHours() >= 12;
    if (isPM && value < 12) {
      date.setHours(value + 12, 0, 0, 0);
    } else {
      date.setHours(value, 0, 0, 0);
    }
    return date;
  }
  incompatibleTokens = ["h", "H", "k", "t", "T"];
};

// node_modules/date-fns/parse/_lib/parsers/Hour1To24Parser.js
var Hour1To24Parser = class extends Parser {
  priority = 70;
  parse(dateString, token, match2) {
    switch (token) {
      case "k":
        return parseNumericPattern(numericPatterns.hour24h, dateString);
      case "ko":
        return match2.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 24;
  }
  set(date, _flags, value) {
    const hours = value <= 24 ? value % 24 : value;
    date.setHours(hours, 0, 0, 0);
    return date;
  }
  incompatibleTokens = ["a", "b", "h", "H", "K", "t", "T"];
};

// node_modules/date-fns/parse/_lib/parsers/MinuteParser.js
var MinuteParser = class extends Parser {
  priority = 60;
  parse(dateString, token, match2) {
    switch (token) {
      case "m":
        return parseNumericPattern(numericPatterns.minute, dateString);
      case "mo":
        return match2.ordinalNumber(dateString, { unit: "minute" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 59;
  }
  set(date, _flags, value) {
    date.setMinutes(value, 0, 0);
    return date;
  }
  incompatibleTokens = ["t", "T"];
};

// node_modules/date-fns/parse/_lib/parsers/SecondParser.js
var SecondParser = class extends Parser {
  priority = 50;
  parse(dateString, token, match2) {
    switch (token) {
      case "s":
        return parseNumericPattern(numericPatterns.second, dateString);
      case "so":
        return match2.ordinalNumber(dateString, { unit: "second" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 59;
  }
  set(date, _flags, value) {
    date.setSeconds(value, 0);
    return date;
  }
  incompatibleTokens = ["t", "T"];
};

// node_modules/date-fns/parse/_lib/parsers/FractionOfSecondParser.js
var FractionOfSecondParser = class extends Parser {
  priority = 30;
  parse(dateString, token) {
    const valueCallback = (value) => Math.trunc(value * Math.pow(10, -token.length + 3));
    return mapValue(parseNDigits(token.length, dateString), valueCallback);
  }
  set(date, _flags, value) {
    date.setMilliseconds(value);
    return date;
  }
  incompatibleTokens = ["t", "T"];
};

// node_modules/date-fns/parse/_lib/parsers/ISOTimezoneWithZParser.js
var ISOTimezoneWithZParser = class extends Parser {
  priority = 10;
  parse(dateString, token) {
    switch (token) {
      case "X":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalMinutes,
          dateString
        );
      case "XX":
        return parseTimezonePattern(timezonePatterns.basic, dateString);
      case "XXXX":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalSeconds,
          dateString
        );
      case "XXXXX":
        return parseTimezonePattern(
          timezonePatterns.extendedOptionalSeconds,
          dateString
        );
      case "XXX":
      default:
        return parseTimezonePattern(timezonePatterns.extended, dateString);
    }
  }
  set(date, flags, value) {
    if (flags.timestampIsSet) return date;
    return constructFrom(
      date,
      date.getTime() - getTimezoneOffsetInMilliseconds(date) - value
    );
  }
  incompatibleTokens = ["t", "T", "x"];
};

// node_modules/date-fns/parse/_lib/parsers/ISOTimezoneParser.js
var ISOTimezoneParser = class extends Parser {
  priority = 10;
  parse(dateString, token) {
    switch (token) {
      case "x":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalMinutes,
          dateString
        );
      case "xx":
        return parseTimezonePattern(timezonePatterns.basic, dateString);
      case "xxxx":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalSeconds,
          dateString
        );
      case "xxxxx":
        return parseTimezonePattern(
          timezonePatterns.extendedOptionalSeconds,
          dateString
        );
      case "xxx":
      default:
        return parseTimezonePattern(timezonePatterns.extended, dateString);
    }
  }
  set(date, flags, value) {
    if (flags.timestampIsSet) return date;
    return constructFrom(
      date,
      date.getTime() - getTimezoneOffsetInMilliseconds(date) - value
    );
  }
  incompatibleTokens = ["t", "T", "X"];
};

// node_modules/date-fns/parse/_lib/parsers/TimestampSecondsParser.js
var TimestampSecondsParser = class extends Parser {
  priority = 40;
  parse(dateString) {
    return parseAnyDigitsSigned(dateString);
  }
  set(date, _flags, value) {
    return [constructFrom(date, value * 1e3), { timestampIsSet: true }];
  }
  incompatibleTokens = "*";
};

// node_modules/date-fns/parse/_lib/parsers/TimestampMillisecondsParser.js
var TimestampMillisecondsParser = class extends Parser {
  priority = 20;
  parse(dateString) {
    return parseAnyDigitsSigned(dateString);
  }
  set(date, _flags, value) {
    return [constructFrom(date, value), { timestampIsSet: true }];
  }
  incompatibleTokens = "*";
};

// node_modules/date-fns/parse/_lib/parsers.js
var parsers = {
  G: new EraParser(),
  y: new YearParser(),
  Y: new LocalWeekYearParser(),
  R: new ISOWeekYearParser(),
  u: new ExtendedYearParser(),
  Q: new QuarterParser(),
  q: new StandAloneQuarterParser(),
  M: new MonthParser(),
  L: new StandAloneMonthParser(),
  w: new LocalWeekParser(),
  I: new ISOWeekParser(),
  d: new DateParser(),
  D: new DayOfYearParser(),
  E: new DayParser(),
  e: new LocalDayParser(),
  c: new StandAloneLocalDayParser(),
  i: new ISODayParser(),
  a: new AMPMParser(),
  b: new AMPMMidnightParser(),
  B: new DayPeriodParser(),
  h: new Hour1to12Parser(),
  H: new Hour0to23Parser(),
  K: new Hour0To11Parser(),
  k: new Hour1To24Parser(),
  m: new MinuteParser(),
  s: new SecondParser(),
  S: new FractionOfSecondParser(),
  X: new ISOTimezoneWithZParser(),
  x: new ISOTimezoneParser(),
  t: new TimestampSecondsParser(),
  T: new TimestampMillisecondsParser()
};

// node_modules/@angular/material/fesm2022/slider.mjs
var _c03 = ["knob"];
var _c110 = ["valueIndicatorContainer"];
function MatSliderVisualThumb_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 2, 1)(2, "div", 5)(3, "span", 6);
    ɵɵtext(4);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(4);
    ɵɵtextInterpolate(ctx_r0.valueIndicatorText);
  }
}
var _c29 = ["trackActive"];
var _c32 = ["*"];
function MatSlider_Conditional_6_Conditional_2_For_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div");
  }
  if (rf & 2) {
    const tickMark_r1 = ctx.$implicit;
    const i_r2 = ctx.$index;
    const ctx_r2 = ɵɵnextContext(3);
    ɵɵclassMap(tickMark_r1 === 0 ? "mdc-slider__tick-mark--active" : "mdc-slider__tick-mark--inactive");
    ɵɵstyleProp("transform", ctx_r2._calcTickMarkTransform(i_r2));
  }
}
function MatSlider_Conditional_6_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵrepeaterCreate(0, MatSlider_Conditional_6_Conditional_2_For_1_Template, 1, 4, "div", 8, ɵɵrepeaterTrackByIndex);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵrepeater(ctx_r2._tickMarks);
  }
}
function MatSlider_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6, 1);
    ɵɵtemplate(2, MatSlider_Conditional_6_Conditional_2_Template, 2, 0);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵconditional(2, ctx_r2._cachedWidth ? 2 : -1);
  }
}
function MatSlider_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "mat-slider-visual-thumb", 7);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("discrete", ctx_r2.discrete)("thumbPosition", 1)("valueIndicatorText", ctx_r2.startValueIndicatorText);
  }
}
var _MatThumb;
(function(_MatThumb2) {
  _MatThumb2[_MatThumb2["START"] = 1] = "START";
  _MatThumb2[_MatThumb2["END"] = 2] = "END";
})(_MatThumb || (_MatThumb = {}));
var _MatTickMark;
(function(_MatTickMark2) {
  _MatTickMark2[_MatTickMark2["ACTIVE"] = 0] = "ACTIVE";
  _MatTickMark2[_MatTickMark2["INACTIVE"] = 1] = "INACTIVE";
})(_MatTickMark || (_MatTickMark = {}));
var MAT_SLIDER = new InjectionToken("_MatSlider");
var MAT_SLIDER_THUMB = new InjectionToken("_MatSliderThumb");
var MAT_SLIDER_RANGE_THUMB = new InjectionToken("_MatSliderRangeThumb");
var MAT_SLIDER_VISUAL_THUMB = new InjectionToken("_MatSliderVisualThumb");
var MatSliderVisualThumb = class _MatSliderVisualThumb {
  constructor(_cdr, _ngZone, _elementRef, _slider) {
    this._cdr = _cdr;
    this._ngZone = _ngZone;
    this._slider = _slider;
    this._isHovered = false;
    this._isActive = false;
    this._isValueIndicatorVisible = false;
    this._platform = inject(Platform);
    this._onPointerMove = (event) => {
      if (this._sliderInput._isFocused) {
        return;
      }
      const rect = this._hostElement.getBoundingClientRect();
      const isHovered = this._slider._isCursorOnSliderThumb(event, rect);
      this._isHovered = isHovered;
      if (isHovered) {
        this._showHoverRipple();
      } else {
        this._hideRipple(this._hoverRippleRef);
      }
    };
    this._onMouseLeave = () => {
      this._isHovered = false;
      this._hideRipple(this._hoverRippleRef);
    };
    this._onFocus = () => {
      this._hideRipple(this._hoverRippleRef);
      this._showFocusRipple();
      this._hostElement.classList.add("mdc-slider__thumb--focused");
    };
    this._onBlur = () => {
      if (!this._isActive) {
        this._hideRipple(this._focusRippleRef);
      }
      if (this._isHovered) {
        this._showHoverRipple();
      }
      this._hostElement.classList.remove("mdc-slider__thumb--focused");
    };
    this._onDragStart = (event) => {
      if (event.button !== 0) {
        return;
      }
      this._isActive = true;
      this._showActiveRipple();
    };
    this._onDragEnd = () => {
      this._isActive = false;
      this._hideRipple(this._activeRippleRef);
      if (!this._sliderInput._isFocused) {
        this._hideRipple(this._focusRippleRef);
      }
      if (this._platform.SAFARI) {
        this._showHoverRipple();
      }
    };
    this._hostElement = _elementRef.nativeElement;
  }
  ngAfterViewInit() {
    this._ripple.radius = 24;
    this._sliderInput = this._slider._getInput(this.thumbPosition);
    this._sliderInputEl = this._sliderInput._hostElement;
    const input = this._sliderInputEl;
    this._ngZone.runOutsideAngular(() => {
      input.addEventListener("pointermove", this._onPointerMove);
      input.addEventListener("pointerdown", this._onDragStart);
      input.addEventListener("pointerup", this._onDragEnd);
      input.addEventListener("pointerleave", this._onMouseLeave);
      input.addEventListener("focus", this._onFocus);
      input.addEventListener("blur", this._onBlur);
    });
  }
  ngOnDestroy() {
    const input = this._sliderInputEl;
    if (input) {
      input.removeEventListener("pointermove", this._onPointerMove);
      input.removeEventListener("pointerdown", this._onDragStart);
      input.removeEventListener("pointerup", this._onDragEnd);
      input.removeEventListener("pointerleave", this._onMouseLeave);
      input.removeEventListener("focus", this._onFocus);
      input.removeEventListener("blur", this._onBlur);
    }
  }
  /** Handles displaying the hover ripple. */
  _showHoverRipple() {
    if (!this._isShowingRipple(this._hoverRippleRef)) {
      this._hoverRippleRef = this._showRipple({
        enterDuration: 0,
        exitDuration: 0
      });
      this._hoverRippleRef?.element.classList.add("mat-mdc-slider-hover-ripple");
    }
  }
  /** Handles displaying the focus ripple. */
  _showFocusRipple() {
    if (!this._isShowingRipple(this._focusRippleRef)) {
      this._focusRippleRef = this._showRipple({
        enterDuration: 0,
        exitDuration: 0
      }, true);
      this._focusRippleRef?.element.classList.add("mat-mdc-slider-focus-ripple");
    }
  }
  /** Handles displaying the active ripple. */
  _showActiveRipple() {
    if (!this._isShowingRipple(this._activeRippleRef)) {
      this._activeRippleRef = this._showRipple({
        enterDuration: 225,
        exitDuration: 400
      });
      this._activeRippleRef?.element.classList.add("mat-mdc-slider-active-ripple");
    }
  }
  /** Whether the given rippleRef is currently fading in or visible. */
  _isShowingRipple(rippleRef) {
    return rippleRef?.state === RippleState.FADING_IN || rippleRef?.state === RippleState.VISIBLE;
  }
  /** Manually launches the slider thumb ripple using the specified ripple animation config. */
  _showRipple(animation, ignoreGlobalRippleConfig) {
    if (this._slider.disabled) {
      return;
    }
    this._showValueIndicator();
    if (this._slider._isRange) {
      const sibling = this._slider._getThumb(this.thumbPosition === _MatThumb.START ? _MatThumb.END : _MatThumb.START);
      sibling._showValueIndicator();
    }
    if (this._slider._globalRippleOptions?.disabled && !ignoreGlobalRippleConfig) {
      return;
    }
    return this._ripple.launch({
      animation: this._slider._noopAnimations ? {
        enterDuration: 0,
        exitDuration: 0
      } : animation,
      centered: true,
      persistent: true
    });
  }
  /**
   * Fades out the given ripple.
   * Also hides the value indicator if no ripple is showing.
   */
  _hideRipple(rippleRef) {
    rippleRef?.fadeOut();
    if (this._isShowingAnyRipple()) {
      return;
    }
    if (!this._slider._isRange) {
      this._hideValueIndicator();
    }
    const sibling = this._getSibling();
    if (!sibling._isShowingAnyRipple()) {
      this._hideValueIndicator();
      sibling._hideValueIndicator();
    }
  }
  /** Shows the value indicator ui. */
  _showValueIndicator() {
    this._hostElement.classList.add("mdc-slider__thumb--with-indicator");
  }
  /** Hides the value indicator ui. */
  _hideValueIndicator() {
    this._hostElement.classList.remove("mdc-slider__thumb--with-indicator");
  }
  _getSibling() {
    return this._slider._getThumb(this.thumbPosition === _MatThumb.START ? _MatThumb.END : _MatThumb.START);
  }
  /** Gets the value indicator container's native HTML element. */
  _getValueIndicatorContainer() {
    return this._valueIndicatorContainer?.nativeElement;
  }
  /** Gets the native HTML element of the slider thumb knob. */
  _getKnob() {
    return this._knob.nativeElement;
  }
  _isShowingAnyRipple() {
    return this._isShowingRipple(this._hoverRippleRef) || this._isShowingRipple(this._focusRippleRef) || this._isShowingRipple(this._activeRippleRef);
  }
  static {
    this.ɵfac = function MatSliderVisualThumb_Factory(t) {
      return new (t || _MatSliderVisualThumb)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(MAT_SLIDER));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _MatSliderVisualThumb,
      selectors: [["mat-slider-visual-thumb"]],
      viewQuery: function MatSliderVisualThumb_Query(rf, ctx) {
        if (rf & 1) {
          ɵɵviewQuery(MatRipple, 5);
          ɵɵviewQuery(_c03, 5);
          ɵɵviewQuery(_c110, 5);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._ripple = _t.first);
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._knob = _t.first);
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._valueIndicatorContainer = _t.first);
        }
      },
      hostAttrs: [1, "mdc-slider__thumb", "mat-mdc-slider-visual-thumb"],
      inputs: {
        discrete: "discrete",
        thumbPosition: "thumbPosition",
        valueIndicatorText: "valueIndicatorText"
      },
      standalone: true,
      features: [ɵɵProvidersFeature([{
        provide: MAT_SLIDER_VISUAL_THUMB,
        useExisting: _MatSliderVisualThumb
      }]), ɵɵStandaloneFeature],
      decls: 4,
      vars: 2,
      consts: [["knob", ""], ["valueIndicatorContainer", ""], [1, "mdc-slider__value-indicator-container"], [1, "mdc-slider__thumb-knob"], ["matRipple", "", 1, "mat-mdc-focus-indicator", 3, "matRippleDisabled"], [1, "mdc-slider__value-indicator"], [1, "mdc-slider__value-indicator-text"]],
      template: function MatSliderVisualThumb_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵtemplate(0, MatSliderVisualThumb_Conditional_0_Template, 5, 1, "div", 2);
          ɵɵelement(1, "div", 3, 0)(3, "div", 4);
        }
        if (rf & 2) {
          ɵɵconditional(0, ctx.discrete ? 0 : -1);
          ɵɵadvance(3);
          ɵɵproperty("matRippleDisabled", true);
        }
      },
      dependencies: [MatRipple],
      styles: [".mat-mdc-slider-visual-thumb .mat-ripple{height:100%;width:100%}.mat-mdc-slider .mdc-slider__tick-marks{justify-content:start}.mat-mdc-slider .mdc-slider__tick-marks .mdc-slider__tick-mark--active,.mat-mdc-slider .mdc-slider__tick-marks .mdc-slider__tick-mark--inactive{position:absolute;left:2px}"],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatSliderVisualThumb, [{
    type: Component,
    args: [{
      selector: "mat-slider-visual-thumb",
      host: {
        "class": "mdc-slider__thumb mat-mdc-slider-visual-thumb"
      },
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      providers: [{
        provide: MAT_SLIDER_VISUAL_THUMB,
        useExisting: MatSliderVisualThumb
      }],
      standalone: true,
      imports: [MatRipple],
      template: '@if (discrete) {\n  <div class="mdc-slider__value-indicator-container" #valueIndicatorContainer>\n    <div class="mdc-slider__value-indicator">\n      <span class="mdc-slider__value-indicator-text">{{valueIndicatorText}}</span>\n    </div>\n  </div>\n}\n<div class="mdc-slider__thumb-knob" #knob></div>\n<div matRipple class="mat-mdc-focus-indicator" [matRippleDisabled]="true"></div>\n',
      styles: [".mat-mdc-slider-visual-thumb .mat-ripple{height:100%;width:100%}.mat-mdc-slider .mdc-slider__tick-marks{justify-content:start}.mat-mdc-slider .mdc-slider__tick-marks .mdc-slider__tick-mark--active,.mat-mdc-slider .mdc-slider__tick-marks .mdc-slider__tick-mark--inactive{position:absolute;left:2px}"]
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: NgZone
  }, {
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [MAT_SLIDER]
    }]
  }], {
    discrete: [{
      type: Input
    }],
    thumbPosition: [{
      type: Input
    }],
    valueIndicatorText: [{
      type: Input
    }],
    _ripple: [{
      type: ViewChild,
      args: [MatRipple]
    }],
    _knob: [{
      type: ViewChild,
      args: ["knob"]
    }],
    _valueIndicatorContainer: [{
      type: ViewChild,
      args: ["valueIndicatorContainer"]
    }]
  });
})();
var MatSlider = class _MatSlider {
  /** Whether the slider is disabled. */
  get disabled() {
    return this._disabled;
  }
  set disabled(v) {
    this._disabled = v;
    const endInput = this._getInput(_MatThumb.END);
    const startInput = this._getInput(_MatThumb.START);
    if (endInput) {
      endInput.disabled = this._disabled;
    }
    if (startInput) {
      startInput.disabled = this._disabled;
    }
  }
  /** Whether the slider displays a numeric value label upon pressing the thumb. */
  get discrete() {
    return this._discrete;
  }
  set discrete(v) {
    this._discrete = v;
    this._updateValueIndicatorUIs();
  }
  /** The minimum value that the slider can have. */
  get min() {
    return this._min;
  }
  set min(v) {
    const min2 = isNaN(v) ? this._min : v;
    if (this._min !== min2) {
      this._updateMin(min2);
    }
  }
  _updateMin(min2) {
    const prevMin = this._min;
    this._min = min2;
    this._isRange ? this._updateMinRange({
      old: prevMin,
      new: min2
    }) : this._updateMinNonRange(min2);
    this._onMinMaxOrStepChange();
  }
  _updateMinRange(min2) {
    const endInput = this._getInput(_MatThumb.END);
    const startInput = this._getInput(_MatThumb.START);
    const oldEndValue = endInput.value;
    const oldStartValue = startInput.value;
    startInput.min = min2.new;
    endInput.min = Math.max(min2.new, startInput.value);
    startInput.max = Math.min(endInput.max, endInput.value);
    startInput._updateWidthInactive();
    endInput._updateWidthInactive();
    min2.new < min2.old ? this._onTranslateXChangeBySideEffect(endInput, startInput) : this._onTranslateXChangeBySideEffect(startInput, endInput);
    if (oldEndValue !== endInput.value) {
      this._onValueChange(endInput);
    }
    if (oldStartValue !== startInput.value) {
      this._onValueChange(startInput);
    }
  }
  _updateMinNonRange(min2) {
    const input = this._getInput(_MatThumb.END);
    if (input) {
      const oldValue = input.value;
      input.min = min2;
      input._updateThumbUIByValue();
      this._updateTrackUI(input);
      if (oldValue !== input.value) {
        this._onValueChange(input);
      }
    }
  }
  /** The maximum value that the slider can have. */
  get max() {
    return this._max;
  }
  set max(v) {
    const max2 = isNaN(v) ? this._max : v;
    if (this._max !== max2) {
      this._updateMax(max2);
    }
  }
  _updateMax(max2) {
    const prevMax = this._max;
    this._max = max2;
    this._isRange ? this._updateMaxRange({
      old: prevMax,
      new: max2
    }) : this._updateMaxNonRange(max2);
    this._onMinMaxOrStepChange();
  }
  _updateMaxRange(max2) {
    const endInput = this._getInput(_MatThumb.END);
    const startInput = this._getInput(_MatThumb.START);
    const oldEndValue = endInput.value;
    const oldStartValue = startInput.value;
    endInput.max = max2.new;
    startInput.max = Math.min(max2.new, endInput.value);
    endInput.min = startInput.value;
    endInput._updateWidthInactive();
    startInput._updateWidthInactive();
    max2.new > max2.old ? this._onTranslateXChangeBySideEffect(startInput, endInput) : this._onTranslateXChangeBySideEffect(endInput, startInput);
    if (oldEndValue !== endInput.value) {
      this._onValueChange(endInput);
    }
    if (oldStartValue !== startInput.value) {
      this._onValueChange(startInput);
    }
  }
  _updateMaxNonRange(max2) {
    const input = this._getInput(_MatThumb.END);
    if (input) {
      const oldValue = input.value;
      input.max = max2;
      input._updateThumbUIByValue();
      this._updateTrackUI(input);
      if (oldValue !== input.value) {
        this._onValueChange(input);
      }
    }
  }
  /** The values at which the thumb will snap. */
  get step() {
    return this._step;
  }
  set step(v) {
    const step = isNaN(v) ? this._step : v;
    if (this._step !== step) {
      this._updateStep(step);
    }
  }
  _updateStep(step) {
    this._step = step;
    this._isRange ? this._updateStepRange() : this._updateStepNonRange();
    this._onMinMaxOrStepChange();
  }
  _updateStepRange() {
    const endInput = this._getInput(_MatThumb.END);
    const startInput = this._getInput(_MatThumb.START);
    const oldEndValue = endInput.value;
    const oldStartValue = startInput.value;
    const prevStartValue = startInput.value;
    endInput.min = this._min;
    startInput.max = this._max;
    endInput.step = this._step;
    startInput.step = this._step;
    if (this._platform.SAFARI) {
      endInput.value = endInput.value;
      startInput.value = startInput.value;
    }
    endInput.min = Math.max(this._min, startInput.value);
    startInput.max = Math.min(this._max, endInput.value);
    startInput._updateWidthInactive();
    endInput._updateWidthInactive();
    endInput.value < prevStartValue ? this._onTranslateXChangeBySideEffect(startInput, endInput) : this._onTranslateXChangeBySideEffect(endInput, startInput);
    if (oldEndValue !== endInput.value) {
      this._onValueChange(endInput);
    }
    if (oldStartValue !== startInput.value) {
      this._onValueChange(startInput);
    }
  }
  _updateStepNonRange() {
    const input = this._getInput(_MatThumb.END);
    if (input) {
      const oldValue = input.value;
      input.step = this._step;
      if (this._platform.SAFARI) {
        input.value = input.value;
      }
      input._updateThumbUIByValue();
      if (oldValue !== input.value) {
        this._onValueChange(input);
      }
    }
  }
  constructor(_ngZone, _cdr, _elementRef, _dir, _globalRippleOptions, animationMode) {
    this._ngZone = _ngZone;
    this._cdr = _cdr;
    this._elementRef = _elementRef;
    this._dir = _dir;
    this._globalRippleOptions = _globalRippleOptions;
    this._disabled = false;
    this._discrete = false;
    this.showTickMarks = false;
    this._min = 0;
    this.disableRipple = false;
    this._max = 100;
    this._step = 1;
    this.displayWith = (value) => `${value}`;
    this._rippleRadius = 24;
    this.startValueIndicatorText = "";
    this.endValueIndicatorText = "";
    this._isRange = false;
    this._isRtl = false;
    this._hasViewInitialized = false;
    this._tickMarkTrackWidth = 0;
    this._hasAnimation = false;
    this._resizeTimer = null;
    this._platform = inject(Platform);
    this._knobRadius = 8;
    this._thumbsOverlap = false;
    this._noopAnimations = animationMode === "NoopAnimations";
    this._dirChangeSubscription = this._dir.change.subscribe(() => this._onDirChange());
    this._isRtl = this._dir.value === "rtl";
  }
  ngAfterViewInit() {
    if (this._platform.isBrowser) {
      this._updateDimensions();
    }
    const eInput = this._getInput(_MatThumb.END);
    const sInput = this._getInput(_MatThumb.START);
    this._isRange = !!eInput && !!sInput;
    this._cdr.detectChanges();
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      _validateInputs(this._isRange, this._getInput(_MatThumb.END), this._getInput(_MatThumb.START));
    }
    const thumb = this._getThumb(_MatThumb.END);
    this._rippleRadius = thumb._ripple.radius;
    this._inputPadding = this._rippleRadius - this._knobRadius;
    this._isRange ? this._initUIRange(eInput, sInput) : this._initUINonRange(eInput);
    this._updateTrackUI(eInput);
    this._updateTickMarkUI();
    this._updateTickMarkTrackUI();
    this._observeHostResize();
    this._cdr.detectChanges();
  }
  _initUINonRange(eInput) {
    eInput.initProps();
    eInput.initUI();
    this._updateValueIndicatorUI(eInput);
    this._hasViewInitialized = true;
    eInput._updateThumbUIByValue();
  }
  _initUIRange(eInput, sInput) {
    eInput.initProps();
    eInput.initUI();
    sInput.initProps();
    sInput.initUI();
    eInput._updateMinMax();
    sInput._updateMinMax();
    eInput._updateStaticStyles();
    sInput._updateStaticStyles();
    this._updateValueIndicatorUIs();
    this._hasViewInitialized = true;
    eInput._updateThumbUIByValue();
    sInput._updateThumbUIByValue();
  }
  ngOnDestroy() {
    this._dirChangeSubscription.unsubscribe();
    this._resizeObserver?.disconnect();
    this._resizeObserver = null;
  }
  /** Handles updating the slider ui after a dir change. */
  _onDirChange() {
    this._isRtl = this._dir.value === "rtl";
    this._isRange ? this._onDirChangeRange() : this._onDirChangeNonRange();
    this._updateTickMarkUI();
  }
  _onDirChangeRange() {
    const endInput = this._getInput(_MatThumb.END);
    const startInput = this._getInput(_MatThumb.START);
    endInput._setIsLeftThumb();
    startInput._setIsLeftThumb();
    endInput.translateX = endInput._calcTranslateXByValue();
    startInput.translateX = startInput._calcTranslateXByValue();
    endInput._updateStaticStyles();
    startInput._updateStaticStyles();
    endInput._updateWidthInactive();
    startInput._updateWidthInactive();
    endInput._updateThumbUIByValue();
    startInput._updateThumbUIByValue();
  }
  _onDirChangeNonRange() {
    const input = this._getInput(_MatThumb.END);
    input._updateThumbUIByValue();
  }
  /** Starts observing and updating the slider if the host changes its size. */
  _observeHostResize() {
    if (typeof ResizeObserver === "undefined" || !ResizeObserver) {
      return;
    }
    this._ngZone.runOutsideAngular(() => {
      this._resizeObserver = new ResizeObserver(() => {
        if (this._isActive()) {
          return;
        }
        if (this._resizeTimer) {
          clearTimeout(this._resizeTimer);
        }
        this._onResize();
      });
      this._resizeObserver.observe(this._elementRef.nativeElement);
    });
  }
  /** Whether any of the thumbs are currently active. */
  _isActive() {
    return this._getThumb(_MatThumb.START)._isActive || this._getThumb(_MatThumb.END)._isActive;
  }
  _getValue(thumbPosition = _MatThumb.END) {
    const input = this._getInput(thumbPosition);
    if (!input) {
      return this.min;
    }
    return input.value;
  }
  _skipUpdate() {
    return !!(this._getInput(_MatThumb.START)?._skipUIUpdate || this._getInput(_MatThumb.END)?._skipUIUpdate);
  }
  /** Stores the slider dimensions. */
  _updateDimensions() {
    this._cachedWidth = this._elementRef.nativeElement.offsetWidth;
    this._cachedLeft = this._elementRef.nativeElement.getBoundingClientRect().left;
  }
  /** Sets the styles for the active portion of the track. */
  _setTrackActiveStyles(styles) {
    const trackStyle = this._trackActive.nativeElement.style;
    trackStyle.left = styles.left;
    trackStyle.right = styles.right;
    trackStyle.transformOrigin = styles.transformOrigin;
    trackStyle.transform = styles.transform;
  }
  /** Returns the translateX positioning for a tick mark based on it's index. */
  _calcTickMarkTransform(index) {
    const translateX = index * (this._tickMarkTrackWidth / (this._tickMarks.length - 1));
    return `translateX(${translateX}px`;
  }
  // Handlers for updating the slider ui.
  _onTranslateXChange(source) {
    if (!this._hasViewInitialized) {
      return;
    }
    this._updateThumbUI(source);
    this._updateTrackUI(source);
    this._updateOverlappingThumbUI(source);
  }
  _onTranslateXChangeBySideEffect(input1, input2) {
    if (!this._hasViewInitialized) {
      return;
    }
    input1._updateThumbUIByValue();
    input2._updateThumbUIByValue();
  }
  _onValueChange(source) {
    if (!this._hasViewInitialized) {
      return;
    }
    this._updateValueIndicatorUI(source);
    this._updateTickMarkUI();
    this._cdr.detectChanges();
  }
  _onMinMaxOrStepChange() {
    if (!this._hasViewInitialized) {
      return;
    }
    this._updateTickMarkUI();
    this._updateTickMarkTrackUI();
    this._cdr.markForCheck();
  }
  _onResize() {
    if (!this._hasViewInitialized) {
      return;
    }
    this._updateDimensions();
    if (this._isRange) {
      const eInput = this._getInput(_MatThumb.END);
      const sInput = this._getInput(_MatThumb.START);
      eInput._updateThumbUIByValue();
      sInput._updateThumbUIByValue();
      eInput._updateStaticStyles();
      sInput._updateStaticStyles();
      eInput._updateMinMax();
      sInput._updateMinMax();
      eInput._updateWidthInactive();
      sInput._updateWidthInactive();
    } else {
      const eInput = this._getInput(_MatThumb.END);
      if (eInput) {
        eInput._updateThumbUIByValue();
      }
    }
    this._updateTickMarkUI();
    this._updateTickMarkTrackUI();
    this._cdr.detectChanges();
  }
  /** Returns true if the slider knobs are overlapping one another. */
  _areThumbsOverlapping() {
    const startInput = this._getInput(_MatThumb.START);
    const endInput = this._getInput(_MatThumb.END);
    if (!startInput || !endInput) {
      return false;
    }
    return endInput.translateX - startInput.translateX < 20;
  }
  /**
   * Updates the class names of overlapping slider thumbs so
   * that the current active thumb is styled to be on "top".
   */
  _updateOverlappingThumbClassNames(source) {
    const sibling = source.getSibling();
    const sourceThumb = this._getThumb(source.thumbPosition);
    const siblingThumb = this._getThumb(sibling.thumbPosition);
    siblingThumb._hostElement.classList.remove("mdc-slider__thumb--top");
    sourceThumb._hostElement.classList.toggle("mdc-slider__thumb--top", this._thumbsOverlap);
  }
  /** Updates the UI of slider thumbs when they begin or stop overlapping. */
  _updateOverlappingThumbUI(source) {
    if (!this._isRange || this._skipUpdate()) {
      return;
    }
    if (this._thumbsOverlap !== this._areThumbsOverlapping()) {
      this._thumbsOverlap = !this._thumbsOverlap;
      this._updateOverlappingThumbClassNames(source);
    }
  }
  // _MatThumb styles update conditions
  //
  // 1. TranslateX, resize, or dir change
  //    - Reason: The thumb styles need to be updated according to the new translateX.
  // 2. Min, max, or step
  //    - Reason: The value may have silently changed.
  /** Updates the translateX of the given thumb. */
  _updateThumbUI(source) {
    if (this._skipUpdate()) {
      return;
    }
    const thumb = this._getThumb(source.thumbPosition === _MatThumb.END ? _MatThumb.END : _MatThumb.START);
    thumb._hostElement.style.transform = `translateX(${source.translateX}px)`;
  }
  // Value indicator text update conditions
  //
  // 1. Value
  //    - Reason: The value displayed needs to be updated.
  // 2. Min, max, or step
  //    - Reason: The value may have silently changed.
  /** Updates the value indicator tooltip ui for the given thumb. */
  _updateValueIndicatorUI(source) {
    if (this._skipUpdate()) {
      return;
    }
    const valuetext = this.displayWith(source.value);
    this._hasViewInitialized ? source._valuetext.set(valuetext) : source._hostElement.setAttribute("aria-valuetext", valuetext);
    if (this.discrete) {
      source.thumbPosition === _MatThumb.START ? this.startValueIndicatorText = valuetext : this.endValueIndicatorText = valuetext;
      const visualThumb = this._getThumb(source.thumbPosition);
      valuetext.length < 3 ? visualThumb._hostElement.classList.add("mdc-slider__thumb--short-value") : visualThumb._hostElement.classList.remove("mdc-slider__thumb--short-value");
    }
  }
  /** Updates all value indicator UIs in the slider. */
  _updateValueIndicatorUIs() {
    const eInput = this._getInput(_MatThumb.END);
    const sInput = this._getInput(_MatThumb.START);
    if (eInput) {
      this._updateValueIndicatorUI(eInput);
    }
    if (sInput) {
      this._updateValueIndicatorUI(sInput);
    }
  }
  // Update Tick Mark Track Width
  //
  // 1. Min, max, or step
  //    - Reason: The maximum reachable value may have changed.
  //    - Side note: The maximum reachable value is different from the maximum value set by the
  //      user. For example, a slider with [min: 5, max: 100, step: 10] would have a maximum
  //      reachable value of 95.
  // 2. Resize
  //    - Reason: The position for the maximum reachable value needs to be recalculated.
  /** Updates the width of the tick mark track. */
  _updateTickMarkTrackUI() {
    if (!this.showTickMarks || this._skipUpdate()) {
      return;
    }
    const step = this._step && this._step > 0 ? this._step : 1;
    const maxValue = Math.floor(this.max / step) * step;
    const percentage = (maxValue - this.min) / (this.max - this.min);
    this._tickMarkTrackWidth = this._cachedWidth * percentage - 6;
  }
  // Track active update conditions
  //
  // 1. TranslateX
  //    - Reason: The track active should line up with the new thumb position.
  // 2. Min or max
  //    - Reason #1: The 'active' percentage needs to be recalculated.
  //    - Reason #2: The value may have silently changed.
  // 3. Step
  //    - Reason: The value may have silently changed causing the thumb(s) to shift.
  // 4. Dir change
  //    - Reason: The track active will need to be updated according to the new thumb position(s).
  // 5. Resize
  //    - Reason: The total width the 'active' tracks translateX is based on has changed.
  /** Updates the scale on the active portion of the track. */
  _updateTrackUI(source) {
    if (this._skipUpdate()) {
      return;
    }
    this._isRange ? this._updateTrackUIRange(source) : this._updateTrackUINonRange(source);
  }
  _updateTrackUIRange(source) {
    const sibling = source.getSibling();
    if (!sibling || !this._cachedWidth) {
      return;
    }
    const activePercentage = Math.abs(sibling.translateX - source.translateX) / this._cachedWidth;
    if (source._isLeftThumb && this._cachedWidth) {
      this._setTrackActiveStyles({
        left: "auto",
        right: `${this._cachedWidth - sibling.translateX}px`,
        transformOrigin: "right",
        transform: `scaleX(${activePercentage})`
      });
    } else {
      this._setTrackActiveStyles({
        left: `${sibling.translateX}px`,
        right: "auto",
        transformOrigin: "left",
        transform: `scaleX(${activePercentage})`
      });
    }
  }
  _updateTrackUINonRange(source) {
    this._isRtl ? this._setTrackActiveStyles({
      left: "auto",
      right: "0px",
      transformOrigin: "right",
      transform: `scaleX(${1 - source.fillPercentage})`
    }) : this._setTrackActiveStyles({
      left: "0px",
      right: "auto",
      transformOrigin: "left",
      transform: `scaleX(${source.fillPercentage})`
    });
  }
  // Tick mark update conditions
  //
  // 1. Value
  //    - Reason: a tick mark which was once active might now be inactive or vice versa.
  // 2. Min, max, or step
  //    - Reason #1: the number of tick marks may have changed.
  //    - Reason #2: The value may have silently changed.
  /** Updates the dots along the slider track. */
  _updateTickMarkUI() {
    if (!this.showTickMarks || this.step === void 0 || this.min === void 0 || this.max === void 0) {
      return;
    }
    const step = this.step > 0 ? this.step : 1;
    this._isRange ? this._updateTickMarkUIRange(step) : this._updateTickMarkUINonRange(step);
    if (this._isRtl) {
      this._tickMarks.reverse();
    }
  }
  _updateTickMarkUINonRange(step) {
    const value = this._getValue();
    let numActive = Math.max(Math.floor((value - this.min) / step), 0);
    let numInactive = Math.max(Math.floor((this.max - value) / step), 0);
    this._isRtl ? numActive++ : numInactive++;
    this._tickMarks = Array(numActive).fill(_MatTickMark.ACTIVE).concat(Array(numInactive).fill(_MatTickMark.INACTIVE));
  }
  _updateTickMarkUIRange(step) {
    const endValue = this._getValue();
    const startValue = this._getValue(_MatThumb.START);
    const numInactiveBeforeStartThumb = Math.max(Math.floor((startValue - this.min) / step), 0);
    const numActive = Math.max(Math.floor((endValue - startValue) / step) + 1, 0);
    const numInactiveAfterEndThumb = Math.max(Math.floor((this.max - endValue) / step), 0);
    this._tickMarks = Array(numInactiveBeforeStartThumb).fill(_MatTickMark.INACTIVE).concat(Array(numActive).fill(_MatTickMark.ACTIVE), Array(numInactiveAfterEndThumb).fill(_MatTickMark.INACTIVE));
  }
  /** Gets the slider thumb input of the given thumb position. */
  _getInput(thumbPosition) {
    if (thumbPosition === _MatThumb.END && this._input) {
      return this._input;
    }
    if (this._inputs?.length) {
      return thumbPosition === _MatThumb.START ? this._inputs.first : this._inputs.last;
    }
    return;
  }
  /** Gets the slider thumb HTML input element of the given thumb position. */
  _getThumb(thumbPosition) {
    return thumbPosition === _MatThumb.END ? this._thumbs?.last : this._thumbs?.first;
  }
  _setTransition(withAnimation) {
    this._hasAnimation = !this._platform.IOS && withAnimation && !this._noopAnimations;
    this._elementRef.nativeElement.classList.toggle("mat-mdc-slider-with-animation", this._hasAnimation);
  }
  /** Whether the given pointer event occurred within the bounds of the slider pointer's DOM Rect. */
  _isCursorOnSliderThumb(event, rect) {
    const radius = rect.width / 2;
    const centerX = rect.x + radius;
    const centerY = rect.y + radius;
    const dx = event.clientX - centerX;
    const dy = event.clientY - centerY;
    return Math.pow(dx, 2) + Math.pow(dy, 2) < Math.pow(radius, 2);
  }
  static {
    this.ɵfac = function MatSlider_Factory(t) {
      return new (t || _MatSlider)(ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Directionality, 8), ɵɵdirectiveInject(MAT_RIPPLE_GLOBAL_OPTIONS, 8), ɵɵdirectiveInject(ANIMATION_MODULE_TYPE, 8));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _MatSlider,
      selectors: [["mat-slider"]],
      contentQueries: function MatSlider_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          ɵɵcontentQuery(dirIndex, MAT_SLIDER_THUMB, 5);
          ɵɵcontentQuery(dirIndex, MAT_SLIDER_RANGE_THUMB, 4);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._input = _t.first);
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._inputs = _t);
        }
      },
      viewQuery: function MatSlider_Query(rf, ctx) {
        if (rf & 1) {
          ɵɵviewQuery(_c29, 5);
          ɵɵviewQuery(MAT_SLIDER_VISUAL_THUMB, 5);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._trackActive = _t.first);
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._thumbs = _t);
        }
      },
      hostAttrs: [1, "mat-mdc-slider", "mdc-slider"],
      hostVars: 12,
      hostBindings: function MatSlider_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassMap("mat-" + (ctx.color || "primary"));
          ɵɵclassProp("mdc-slider--range", ctx._isRange)("mdc-slider--disabled", ctx.disabled)("mdc-slider--discrete", ctx.discrete)("mdc-slider--tick-marks", ctx.showTickMarks)("_mat-animation-noopable", ctx._noopAnimations);
        }
      },
      inputs: {
        disabled: [InputFlags.HasDecoratorInputTransform, "disabled", "disabled", booleanAttribute],
        discrete: [InputFlags.HasDecoratorInputTransform, "discrete", "discrete", booleanAttribute],
        showTickMarks: [InputFlags.HasDecoratorInputTransform, "showTickMarks", "showTickMarks", booleanAttribute],
        min: [InputFlags.HasDecoratorInputTransform, "min", "min", numberAttribute],
        color: "color",
        disableRipple: [InputFlags.HasDecoratorInputTransform, "disableRipple", "disableRipple", booleanAttribute],
        max: [InputFlags.HasDecoratorInputTransform, "max", "max", numberAttribute],
        step: [InputFlags.HasDecoratorInputTransform, "step", "step", numberAttribute],
        displayWith: "displayWith"
      },
      exportAs: ["matSlider"],
      standalone: true,
      features: [ɵɵProvidersFeature([{
        provide: MAT_SLIDER,
        useExisting: _MatSlider
      }]), ɵɵInputTransformsFeature, ɵɵStandaloneFeature],
      ngContentSelectors: _c32,
      decls: 9,
      vars: 5,
      consts: [["trackActive", ""], ["tickMarkContainer", ""], [1, "mdc-slider__track"], [1, "mdc-slider__track--inactive"], [1, "mdc-slider__track--active"], [1, "mdc-slider__track--active_fill"], [1, "mdc-slider__tick-marks"], [3, "discrete", "thumbPosition", "valueIndicatorText"], [3, "class", "transform"]],
      template: function MatSlider_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef();
          ɵɵprojection(0);
          ɵɵelementStart(1, "div", 2);
          ɵɵelement(2, "div", 3);
          ɵɵelementStart(3, "div", 4);
          ɵɵelement(4, "div", 5, 0);
          ɵɵelementEnd();
          ɵɵtemplate(6, MatSlider_Conditional_6_Template, 3, 1, "div", 6);
          ɵɵelementEnd();
          ɵɵtemplate(7, MatSlider_Conditional_7_Template, 1, 3, "mat-slider-visual-thumb", 7);
          ɵɵelement(8, "mat-slider-visual-thumb", 7);
        }
        if (rf & 2) {
          ɵɵadvance(6);
          ɵɵconditional(6, ctx.showTickMarks ? 6 : -1);
          ɵɵadvance();
          ɵɵconditional(7, ctx._isRange ? 7 : -1);
          ɵɵadvance();
          ɵɵproperty("discrete", ctx.discrete)("thumbPosition", 2)("valueIndicatorText", ctx.endValueIndicatorText);
        }
      },
      dependencies: [MatSliderVisualThumb],
      styles: ['.mdc-slider{cursor:pointer;height:48px;margin:0 24px;position:relative;touch-action:pan-y}.mdc-slider .mdc-slider__track{position:absolute;top:50%;transform:translateY(-50%);width:100%}.mdc-slider .mdc-slider__track--active,.mdc-slider .mdc-slider__track--inactive{display:flex;height:100%;position:absolute;width:100%}.mdc-slider .mdc-slider__track--active{overflow:hidden}.mdc-slider .mdc-slider__track--active_fill{border-top-style:solid;box-sizing:border-box;height:100%;width:100%;position:relative;-webkit-transform-origin:left;transform-origin:left}[dir=rtl] .mdc-slider .mdc-slider__track--active_fill,.mdc-slider .mdc-slider__track--active_fill[dir=rtl]{-webkit-transform-origin:right;transform-origin:right}.mdc-slider .mdc-slider__track--inactive{left:0;top:0}.mdc-slider .mdc-slider__track--inactive::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}@media screen and (forced-colors: active){.mdc-slider .mdc-slider__track--inactive::before{border-color:CanvasText}}.mdc-slider .mdc-slider__value-indicator-container{bottom:44px;left:50%;left:var(--slider-value-indicator-container-left, 50%);pointer-events:none;position:absolute;right:var(--slider-value-indicator-container-right);transform:translateX(-50%);transform:var(--slider-value-indicator-container-transform, translateX(-50%))}.mdc-slider .mdc-slider__value-indicator{transition:transform 100ms 0ms cubic-bezier(0.4, 0, 1, 1);align-items:center;border-radius:4px;display:flex;height:32px;padding:0 12px;transform:scale(0);transform-origin:bottom}.mdc-slider .mdc-slider__value-indicator::before{border-left:6px solid rgba(0,0,0,0);border-right:6px solid rgba(0,0,0,0);border-top:6px solid;bottom:-5px;content:"";height:0;left:50%;left:var(--slider-value-indicator-caret-left, 50%);position:absolute;right:var(--slider-value-indicator-caret-right);transform:translateX(-50%);transform:var(--slider-value-indicator-caret-transform, translateX(-50%));width:0}.mdc-slider .mdc-slider__value-indicator::after{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}@media screen and (forced-colors: active){.mdc-slider .mdc-slider__value-indicator::after{border-color:CanvasText}}.mdc-slider .mdc-slider__thumb--with-indicator .mdc-slider__value-indicator-container{pointer-events:auto}.mdc-slider .mdc-slider__thumb--with-indicator .mdc-slider__value-indicator{transition:transform 100ms 0ms cubic-bezier(0, 0, 0.2, 1);transform:scale(1)}@media(prefers-reduced-motion){.mdc-slider .mdc-slider__value-indicator,.mdc-slider .mdc-slider__thumb--with-indicator .mdc-slider__value-indicator{transition:none}}.mdc-slider .mdc-slider__thumb{display:flex;left:-24px;outline:none;position:absolute;user-select:none;height:48px;width:48px}.mdc-slider .mdc-slider__thumb--top{z-index:1}.mdc-slider .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-style:solid;border-width:1px;box-sizing:content-box}.mdc-slider .mdc-slider__thumb-knob{box-sizing:border-box;left:50%;position:absolute;top:50%;transform:translate(-50%, -50%)}.mdc-slider .mdc-slider__tick-marks{align-items:center;box-sizing:border-box;display:flex;height:100%;justify-content:space-between;padding:0 1px;position:absolute;width:100%}.mdc-slider--discrete .mdc-slider__thumb,.mdc-slider--discrete .mdc-slider__track--active_fill{transition:transform 80ms ease}@media(prefers-reduced-motion){.mdc-slider--discrete .mdc-slider__thumb,.mdc-slider--discrete .mdc-slider__track--active_fill{transition:none}}.mdc-slider--disabled{cursor:auto}.mdc-slider--disabled .mdc-slider__thumb{pointer-events:none}.mdc-slider__input{cursor:pointer;left:2px;margin:0;height:44px;opacity:0;pointer-events:none;position:absolute;top:2px;width:44px}.mat-mdc-slider{display:inline-block;box-sizing:border-box;outline:none;vertical-align:middle;margin-left:8px;margin-right:8px;width:auto;min-width:112px;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-slider .mdc-slider__thumb-knob{background-color:var(--mdc-slider-handle-color);border-color:var(--mdc-slider-handle-color)}.mat-mdc-slider .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:#fff}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__thumb-knob{background-color:var(--mdc-slider-disabled-handle-color);border-color:var(--mdc-slider-disabled-handle-color)}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider.mdc-slider--disabled .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider.mdc-slider--disabled .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:#fff}.mat-mdc-slider .mdc-slider__thumb::before,.mat-mdc-slider .mdc-slider__thumb::after{background-color:var(--mdc-slider-handle-color)}.mat-mdc-slider .mdc-slider__thumb:hover::before,.mat-mdc-slider .mdc-slider__thumb.mdc-ripple-surface--hover::before{opacity:var(--mdc-ripple-hover-opacity)}.mat-mdc-slider .mdc-slider__thumb.mdc-ripple-upgraded--background-focused::before,.mat-mdc-slider .mdc-slider__thumb:not(.mdc-ripple-upgraded):focus::before{transition-duration:75ms;opacity:var(--mdc-ripple-focus-opacity)}.mat-mdc-slider .mdc-slider__thumb:not(.mdc-ripple-upgraded)::after{transition:opacity 150ms linear}.mat-mdc-slider .mdc-slider__thumb:not(.mdc-ripple-upgraded):active::after{transition-duration:75ms;opacity:var(--mdc-ripple-press-opacity)}.mat-mdc-slider .mdc-slider__thumb.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity)}.mat-mdc-slider .mdc-slider__track--active_fill{border-color:var(--mdc-slider-active-track-color)}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__track--active_fill{border-color:var(--mdc-slider-disabled-active-track-color)}.mat-mdc-slider .mdc-slider__track--inactive{background-color:var(--mdc-slider-inactive-track-color);opacity:.24}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__track--inactive{background-color:var(--mdc-slider-disabled-inactive-track-color);opacity:.24}.mat-mdc-slider .mdc-slider__tick-mark--active{background-color:var(--mdc-slider-with-tick-marks-active-container-color);opacity:var(--mdc-slider-with-tick-marks-active-container-opacity)}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__tick-mark--active{background-color:var(--mdc-slider-with-tick-marks-active-container-color);opacity:var(--mdc-slider-with-tick-marks-active-container-opacity)}.mat-mdc-slider .mdc-slider__tick-mark--inactive{background-color:var(--mdc-slider-with-tick-marks-inactive-container-color);opacity:var(--mdc-slider-with-tick-marks-inactive-container-opacity)}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__tick-mark--inactive{background-color:var(--mdc-slider-with-tick-marks-disabled-container-color);opacity:var(--mdc-slider-with-tick-marks-inactive-container-opacity)}.mat-mdc-slider .mdc-slider__value-indicator{background-color:var(--mdc-slider-label-container-color);opacity:1}.mat-mdc-slider .mdc-slider__value-indicator::before{border-top-color:var(--mdc-slider-label-container-color)}.mat-mdc-slider .mdc-slider__value-indicator{color:var(--mdc-slider-label-label-text-color)}.mat-mdc-slider .mdc-slider__track{height:var(--mdc-slider-inactive-track-height)}.mat-mdc-slider .mdc-slider__track--active{height:var(--mdc-slider-active-track-height);top:calc((var(--mdc-slider-inactive-track-height) - var(--mdc-slider-active-track-height)) / 2)}.mat-mdc-slider .mdc-slider__track--active_fill{border-top-width:var(--mdc-slider-active-track-height)}.mat-mdc-slider .mdc-slider__track--inactive{height:var(--mdc-slider-inactive-track-height)}.mat-mdc-slider .mdc-slider__tick-mark--active,.mat-mdc-slider .mdc-slider__tick-mark--inactive{height:var(--mdc-slider-with-tick-marks-container-size);width:var(--mdc-slider-with-tick-marks-container-size)}.mat-mdc-slider.mdc-slider--disabled{opacity:0.38}.mat-mdc-slider .mdc-slider__value-indicator-text{letter-spacing:var(--mdc-slider-label-label-text-tracking);font-size:var(--mdc-slider-label-label-text-size);font-family:var(--mdc-slider-label-label-text-font);font-weight:var(--mdc-slider-label-label-text-weight);line-height:var(--mdc-slider-label-label-text-line-height)}.mat-mdc-slider .mdc-slider__track--active{border-radius:var(--mdc-slider-active-track-shape)}.mat-mdc-slider .mdc-slider__track--inactive{border-radius:var(--mdc-slider-inactive-track-shape)}.mat-mdc-slider .mdc-slider__thumb-knob{border-radius:var(--mdc-slider-handle-shape);width:var(--mdc-slider-handle-width);height:var(--mdc-slider-handle-height);border-style:solid;border-width:calc(var(--mdc-slider-handle-height) / 2) calc(var(--mdc-slider-handle-width) / 2)}.mat-mdc-slider .mdc-slider__tick-mark--active,.mat-mdc-slider .mdc-slider__tick-mark--inactive{border-radius:var(--mdc-slider-with-tick-marks-container-shape)}.mat-mdc-slider .mdc-slider__thumb:hover .mdc-slider__thumb-knob{background-color:var(--mdc-slider-hover-handle-color);border-color:var(--mdc-slider-hover-handle-color)}.mat-mdc-slider .mdc-slider__thumb:hover .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb:hover .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb:hover .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:#fff}.mat-mdc-slider .mdc-slider__thumb--focused .mdc-slider__thumb-knob{background-color:var(--mdc-slider-focus-handle-color);border-color:var(--mdc-slider-focus-handle-color)}.mat-mdc-slider .mdc-slider__thumb--focused .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--focused .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--focused .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:#fff}.mat-mdc-slider .mdc-slider__thumb:not(:disabled):active .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb:not(:disabled):active .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb:not(:disabled):active .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:#fff}.mat-mdc-slider .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:var(--mdc-slider-with-overlap-handle-outline-color);border-width:var(--mdc-slider-with-overlap-handle-outline-width)}.mat-mdc-slider .mdc-slider__thumb-knob{box-shadow:var(--mdc-slider-handle-elevation)}.mat-mdc-slider .mdc-slider__input{box-sizing:content-box;pointer-events:auto}.mat-mdc-slider .mdc-slider__input.mat-mdc-slider-input-no-pointer-events{pointer-events:none}.mat-mdc-slider .mdc-slider__input.mat-slider__right-input{left:auto;right:0}.mat-mdc-slider .mdc-slider__thumb,.mat-mdc-slider .mdc-slider__track--active_fill{transition-duration:0ms}.mat-mdc-slider.mat-mdc-slider-with-animation .mdc-slider__thumb,.mat-mdc-slider.mat-mdc-slider-with-animation .mdc-slider__track--active_fill{transition-duration:80ms}.mat-mdc-slider.mdc-slider--discrete .mdc-slider__thumb,.mat-mdc-slider.mdc-slider--discrete .mdc-slider__track--active_fill{transition-duration:0ms}.mat-mdc-slider.mat-mdc-slider-with-animation .mdc-slider__thumb,.mat-mdc-slider.mat-mdc-slider-with-animation .mdc-slider__track--active_fill{transition-duration:80ms}.mat-mdc-slider .mdc-slider__track,.mat-mdc-slider .mdc-slider__thumb{pointer-events:none}.mat-mdc-slider .mdc-slider__value-indicator-container{transform:var(--mat-slider-value-indicator-container-transform)}.mat-mdc-slider .mdc-slider__value-indicator{width:var(--mat-slider-value-indicator-width);height:var(--mat-slider-value-indicator-height);padding:var(--mat-slider-value-indicator-padding);opacity:var(--mat-slider-value-indicator-opacity);border-radius:var(--mat-slider-value-indicator-border-radius)}.mat-mdc-slider .mdc-slider__value-indicator::before{display:var(--mat-slider-value-indicator-caret-display)}.mat-mdc-slider .mdc-slider__value-indicator-text{width:var(--mat-slider-value-indicator-width);transform:var(--mat-slider-value-indicator-text-transform)}.mat-mdc-slider .mat-ripple .mat-ripple-element{background-color:var(--mat-slider-ripple-color)}.mat-mdc-slider .mat-ripple .mat-mdc-slider-hover-ripple{background-color:var(--mat-slider-hover-state-layer-color)}.mat-mdc-slider .mat-ripple .mat-mdc-slider-focus-ripple,.mat-mdc-slider .mat-ripple .mat-mdc-slider-active-ripple{background-color:var(--mat-slider-focus-state-layer-color)}.mat-mdc-slider._mat-animation-noopable.mdc-slider--discrete .mdc-slider__thumb,.mat-mdc-slider._mat-animation-noopable.mdc-slider--discrete .mdc-slider__track--active_fill,.mat-mdc-slider._mat-animation-noopable .mdc-slider__value-indicator{transition:none}.mat-mdc-slider .mat-mdc-focus-indicator::before{border-radius:50%}.mat-mdc-slider .mdc-slider__value-indicator{word-break:normal}.mat-mdc-slider .mdc-slider__value-indicator-text{text-align:center}.mdc-slider__thumb--focused .mat-mdc-focus-indicator::before{content:""}'],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatSlider, [{
    type: Component,
    args: [{
      selector: "mat-slider",
      host: {
        "class": "mat-mdc-slider mdc-slider",
        "[class]": '"mat-" + (color || "primary")',
        "[class.mdc-slider--range]": "_isRange",
        "[class.mdc-slider--disabled]": "disabled",
        "[class.mdc-slider--discrete]": "discrete",
        "[class.mdc-slider--tick-marks]": "showTickMarks",
        "[class._mat-animation-noopable]": "_noopAnimations"
      },
      exportAs: "matSlider",
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      providers: [{
        provide: MAT_SLIDER,
        useExisting: MatSlider
      }],
      standalone: true,
      imports: [MatSliderVisualThumb],
      template: `<!-- Inputs -->
<ng-content></ng-content>

<!-- Track -->
<div class="mdc-slider__track">
  <div class="mdc-slider__track--inactive"></div>
  <div class="mdc-slider__track--active">
    <div #trackActive class="mdc-slider__track--active_fill"></div>
  </div>
  @if (showTickMarks) {
    <div class="mdc-slider__tick-marks" #tickMarkContainer>
      @if (_cachedWidth) {
        @for (tickMark of _tickMarks; track i; let i = $index) {
          <div
            [class]="tickMark === 0 ? 'mdc-slider__tick-mark--active' : 'mdc-slider__tick-mark--inactive'"
            [style.transform]="_calcTickMarkTransform(i)"></div>
        }
      }
    </div>
  }
</div>

<!-- Thumbs -->
@if (_isRange) {
  <mat-slider-visual-thumb
    [discrete]="discrete"
    [thumbPosition]="1"
    [valueIndicatorText]="startValueIndicatorText">
  </mat-slider-visual-thumb>
}

<mat-slider-visual-thumb
  [discrete]="discrete"
  [thumbPosition]="2"
  [valueIndicatorText]="endValueIndicatorText">
</mat-slider-visual-thumb>
`,
      styles: ['.mdc-slider{cursor:pointer;height:48px;margin:0 24px;position:relative;touch-action:pan-y}.mdc-slider .mdc-slider__track{position:absolute;top:50%;transform:translateY(-50%);width:100%}.mdc-slider .mdc-slider__track--active,.mdc-slider .mdc-slider__track--inactive{display:flex;height:100%;position:absolute;width:100%}.mdc-slider .mdc-slider__track--active{overflow:hidden}.mdc-slider .mdc-slider__track--active_fill{border-top-style:solid;box-sizing:border-box;height:100%;width:100%;position:relative;-webkit-transform-origin:left;transform-origin:left}[dir=rtl] .mdc-slider .mdc-slider__track--active_fill,.mdc-slider .mdc-slider__track--active_fill[dir=rtl]{-webkit-transform-origin:right;transform-origin:right}.mdc-slider .mdc-slider__track--inactive{left:0;top:0}.mdc-slider .mdc-slider__track--inactive::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}@media screen and (forced-colors: active){.mdc-slider .mdc-slider__track--inactive::before{border-color:CanvasText}}.mdc-slider .mdc-slider__value-indicator-container{bottom:44px;left:50%;left:var(--slider-value-indicator-container-left, 50%);pointer-events:none;position:absolute;right:var(--slider-value-indicator-container-right);transform:translateX(-50%);transform:var(--slider-value-indicator-container-transform, translateX(-50%))}.mdc-slider .mdc-slider__value-indicator{transition:transform 100ms 0ms cubic-bezier(0.4, 0, 1, 1);align-items:center;border-radius:4px;display:flex;height:32px;padding:0 12px;transform:scale(0);transform-origin:bottom}.mdc-slider .mdc-slider__value-indicator::before{border-left:6px solid rgba(0,0,0,0);border-right:6px solid rgba(0,0,0,0);border-top:6px solid;bottom:-5px;content:"";height:0;left:50%;left:var(--slider-value-indicator-caret-left, 50%);position:absolute;right:var(--slider-value-indicator-caret-right);transform:translateX(-50%);transform:var(--slider-value-indicator-caret-transform, translateX(-50%));width:0}.mdc-slider .mdc-slider__value-indicator::after{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}@media screen and (forced-colors: active){.mdc-slider .mdc-slider__value-indicator::after{border-color:CanvasText}}.mdc-slider .mdc-slider__thumb--with-indicator .mdc-slider__value-indicator-container{pointer-events:auto}.mdc-slider .mdc-slider__thumb--with-indicator .mdc-slider__value-indicator{transition:transform 100ms 0ms cubic-bezier(0, 0, 0.2, 1);transform:scale(1)}@media(prefers-reduced-motion){.mdc-slider .mdc-slider__value-indicator,.mdc-slider .mdc-slider__thumb--with-indicator .mdc-slider__value-indicator{transition:none}}.mdc-slider .mdc-slider__thumb{display:flex;left:-24px;outline:none;position:absolute;user-select:none;height:48px;width:48px}.mdc-slider .mdc-slider__thumb--top{z-index:1}.mdc-slider .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-style:solid;border-width:1px;box-sizing:content-box}.mdc-slider .mdc-slider__thumb-knob{box-sizing:border-box;left:50%;position:absolute;top:50%;transform:translate(-50%, -50%)}.mdc-slider .mdc-slider__tick-marks{align-items:center;box-sizing:border-box;display:flex;height:100%;justify-content:space-between;padding:0 1px;position:absolute;width:100%}.mdc-slider--discrete .mdc-slider__thumb,.mdc-slider--discrete .mdc-slider__track--active_fill{transition:transform 80ms ease}@media(prefers-reduced-motion){.mdc-slider--discrete .mdc-slider__thumb,.mdc-slider--discrete .mdc-slider__track--active_fill{transition:none}}.mdc-slider--disabled{cursor:auto}.mdc-slider--disabled .mdc-slider__thumb{pointer-events:none}.mdc-slider__input{cursor:pointer;left:2px;margin:0;height:44px;opacity:0;pointer-events:none;position:absolute;top:2px;width:44px}.mat-mdc-slider{display:inline-block;box-sizing:border-box;outline:none;vertical-align:middle;margin-left:8px;margin-right:8px;width:auto;min-width:112px;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-slider .mdc-slider__thumb-knob{background-color:var(--mdc-slider-handle-color);border-color:var(--mdc-slider-handle-color)}.mat-mdc-slider .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:#fff}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__thumb-knob{background-color:var(--mdc-slider-disabled-handle-color);border-color:var(--mdc-slider-disabled-handle-color)}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider.mdc-slider--disabled .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider.mdc-slider--disabled .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:#fff}.mat-mdc-slider .mdc-slider__thumb::before,.mat-mdc-slider .mdc-slider__thumb::after{background-color:var(--mdc-slider-handle-color)}.mat-mdc-slider .mdc-slider__thumb:hover::before,.mat-mdc-slider .mdc-slider__thumb.mdc-ripple-surface--hover::before{opacity:var(--mdc-ripple-hover-opacity)}.mat-mdc-slider .mdc-slider__thumb.mdc-ripple-upgraded--background-focused::before,.mat-mdc-slider .mdc-slider__thumb:not(.mdc-ripple-upgraded):focus::before{transition-duration:75ms;opacity:var(--mdc-ripple-focus-opacity)}.mat-mdc-slider .mdc-slider__thumb:not(.mdc-ripple-upgraded)::after{transition:opacity 150ms linear}.mat-mdc-slider .mdc-slider__thumb:not(.mdc-ripple-upgraded):active::after{transition-duration:75ms;opacity:var(--mdc-ripple-press-opacity)}.mat-mdc-slider .mdc-slider__thumb.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity)}.mat-mdc-slider .mdc-slider__track--active_fill{border-color:var(--mdc-slider-active-track-color)}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__track--active_fill{border-color:var(--mdc-slider-disabled-active-track-color)}.mat-mdc-slider .mdc-slider__track--inactive{background-color:var(--mdc-slider-inactive-track-color);opacity:.24}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__track--inactive{background-color:var(--mdc-slider-disabled-inactive-track-color);opacity:.24}.mat-mdc-slider .mdc-slider__tick-mark--active{background-color:var(--mdc-slider-with-tick-marks-active-container-color);opacity:var(--mdc-slider-with-tick-marks-active-container-opacity)}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__tick-mark--active{background-color:var(--mdc-slider-with-tick-marks-active-container-color);opacity:var(--mdc-slider-with-tick-marks-active-container-opacity)}.mat-mdc-slider .mdc-slider__tick-mark--inactive{background-color:var(--mdc-slider-with-tick-marks-inactive-container-color);opacity:var(--mdc-slider-with-tick-marks-inactive-container-opacity)}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__tick-mark--inactive{background-color:var(--mdc-slider-with-tick-marks-disabled-container-color);opacity:var(--mdc-slider-with-tick-marks-inactive-container-opacity)}.mat-mdc-slider .mdc-slider__value-indicator{background-color:var(--mdc-slider-label-container-color);opacity:1}.mat-mdc-slider .mdc-slider__value-indicator::before{border-top-color:var(--mdc-slider-label-container-color)}.mat-mdc-slider .mdc-slider__value-indicator{color:var(--mdc-slider-label-label-text-color)}.mat-mdc-slider .mdc-slider__track{height:var(--mdc-slider-inactive-track-height)}.mat-mdc-slider .mdc-slider__track--active{height:var(--mdc-slider-active-track-height);top:calc((var(--mdc-slider-inactive-track-height) - var(--mdc-slider-active-track-height)) / 2)}.mat-mdc-slider .mdc-slider__track--active_fill{border-top-width:var(--mdc-slider-active-track-height)}.mat-mdc-slider .mdc-slider__track--inactive{height:var(--mdc-slider-inactive-track-height)}.mat-mdc-slider .mdc-slider__tick-mark--active,.mat-mdc-slider .mdc-slider__tick-mark--inactive{height:var(--mdc-slider-with-tick-marks-container-size);width:var(--mdc-slider-with-tick-marks-container-size)}.mat-mdc-slider.mdc-slider--disabled{opacity:0.38}.mat-mdc-slider .mdc-slider__value-indicator-text{letter-spacing:var(--mdc-slider-label-label-text-tracking);font-size:var(--mdc-slider-label-label-text-size);font-family:var(--mdc-slider-label-label-text-font);font-weight:var(--mdc-slider-label-label-text-weight);line-height:var(--mdc-slider-label-label-text-line-height)}.mat-mdc-slider .mdc-slider__track--active{border-radius:var(--mdc-slider-active-track-shape)}.mat-mdc-slider .mdc-slider__track--inactive{border-radius:var(--mdc-slider-inactive-track-shape)}.mat-mdc-slider .mdc-slider__thumb-knob{border-radius:var(--mdc-slider-handle-shape);width:var(--mdc-slider-handle-width);height:var(--mdc-slider-handle-height);border-style:solid;border-width:calc(var(--mdc-slider-handle-height) / 2) calc(var(--mdc-slider-handle-width) / 2)}.mat-mdc-slider .mdc-slider__tick-mark--active,.mat-mdc-slider .mdc-slider__tick-mark--inactive{border-radius:var(--mdc-slider-with-tick-marks-container-shape)}.mat-mdc-slider .mdc-slider__thumb:hover .mdc-slider__thumb-knob{background-color:var(--mdc-slider-hover-handle-color);border-color:var(--mdc-slider-hover-handle-color)}.mat-mdc-slider .mdc-slider__thumb:hover .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb:hover .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb:hover .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:#fff}.mat-mdc-slider .mdc-slider__thumb--focused .mdc-slider__thumb-knob{background-color:var(--mdc-slider-focus-handle-color);border-color:var(--mdc-slider-focus-handle-color)}.mat-mdc-slider .mdc-slider__thumb--focused .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--focused .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--focused .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:#fff}.mat-mdc-slider .mdc-slider__thumb:not(:disabled):active .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb:not(:disabled):active .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb:not(:disabled):active .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:#fff}.mat-mdc-slider .mdc-slider__thumb--top .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mat-mdc-slider .mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border-color:var(--mdc-slider-with-overlap-handle-outline-color);border-width:var(--mdc-slider-with-overlap-handle-outline-width)}.mat-mdc-slider .mdc-slider__thumb-knob{box-shadow:var(--mdc-slider-handle-elevation)}.mat-mdc-slider .mdc-slider__input{box-sizing:content-box;pointer-events:auto}.mat-mdc-slider .mdc-slider__input.mat-mdc-slider-input-no-pointer-events{pointer-events:none}.mat-mdc-slider .mdc-slider__input.mat-slider__right-input{left:auto;right:0}.mat-mdc-slider .mdc-slider__thumb,.mat-mdc-slider .mdc-slider__track--active_fill{transition-duration:0ms}.mat-mdc-slider.mat-mdc-slider-with-animation .mdc-slider__thumb,.mat-mdc-slider.mat-mdc-slider-with-animation .mdc-slider__track--active_fill{transition-duration:80ms}.mat-mdc-slider.mdc-slider--discrete .mdc-slider__thumb,.mat-mdc-slider.mdc-slider--discrete .mdc-slider__track--active_fill{transition-duration:0ms}.mat-mdc-slider.mat-mdc-slider-with-animation .mdc-slider__thumb,.mat-mdc-slider.mat-mdc-slider-with-animation .mdc-slider__track--active_fill{transition-duration:80ms}.mat-mdc-slider .mdc-slider__track,.mat-mdc-slider .mdc-slider__thumb{pointer-events:none}.mat-mdc-slider .mdc-slider__value-indicator-container{transform:var(--mat-slider-value-indicator-container-transform)}.mat-mdc-slider .mdc-slider__value-indicator{width:var(--mat-slider-value-indicator-width);height:var(--mat-slider-value-indicator-height);padding:var(--mat-slider-value-indicator-padding);opacity:var(--mat-slider-value-indicator-opacity);border-radius:var(--mat-slider-value-indicator-border-radius)}.mat-mdc-slider .mdc-slider__value-indicator::before{display:var(--mat-slider-value-indicator-caret-display)}.mat-mdc-slider .mdc-slider__value-indicator-text{width:var(--mat-slider-value-indicator-width);transform:var(--mat-slider-value-indicator-text-transform)}.mat-mdc-slider .mat-ripple .mat-ripple-element{background-color:var(--mat-slider-ripple-color)}.mat-mdc-slider .mat-ripple .mat-mdc-slider-hover-ripple{background-color:var(--mat-slider-hover-state-layer-color)}.mat-mdc-slider .mat-ripple .mat-mdc-slider-focus-ripple,.mat-mdc-slider .mat-ripple .mat-mdc-slider-active-ripple{background-color:var(--mat-slider-focus-state-layer-color)}.mat-mdc-slider._mat-animation-noopable.mdc-slider--discrete .mdc-slider__thumb,.mat-mdc-slider._mat-animation-noopable.mdc-slider--discrete .mdc-slider__track--active_fill,.mat-mdc-slider._mat-animation-noopable .mdc-slider__value-indicator{transition:none}.mat-mdc-slider .mat-mdc-focus-indicator::before{border-radius:50%}.mat-mdc-slider .mdc-slider__value-indicator{word-break:normal}.mat-mdc-slider .mdc-slider__value-indicator-text{text-align:center}.mdc-slider__thumb--focused .mat-mdc-focus-indicator::before{content:""}']
    }]
  }], () => [{
    type: NgZone
  }, {
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [MAT_RIPPLE_GLOBAL_OPTIONS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [ANIMATION_MODULE_TYPE]
    }]
  }], {
    _trackActive: [{
      type: ViewChild,
      args: ["trackActive"]
    }],
    _thumbs: [{
      type: ViewChildren,
      args: [MAT_SLIDER_VISUAL_THUMB]
    }],
    _input: [{
      type: ContentChild,
      args: [MAT_SLIDER_THUMB]
    }],
    _inputs: [{
      type: ContentChildren,
      args: [MAT_SLIDER_RANGE_THUMB, {
        descendants: false
      }]
    }],
    disabled: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    discrete: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    showTickMarks: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    min: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    color: [{
      type: Input
    }],
    disableRipple: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    max: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    step: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    displayWith: [{
      type: Input
    }]
  });
})();
function _validateInputs(isRange, endInputElement, startInputElement) {
  const startValid = !isRange || startInputElement?._hostElement.hasAttribute("matSliderStartThumb");
  const endValid = endInputElement._hostElement.hasAttribute(isRange ? "matSliderEndThumb" : "matSliderThumb");
  if (!startValid || !endValid) {
    _throwInvalidInputConfigurationError();
  }
}
function _throwInvalidInputConfigurationError() {
  throw Error(`Invalid slider thumb input configuration!

   Valid configurations are as follows:

     <mat-slider>
       <input matSliderThumb>
     </mat-slider>

     or

     <mat-slider>
       <input matSliderStartThumb>
       <input matSliderEndThumb>
     </mat-slider>
   `);
}
var MAT_SLIDER_THUMB_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => MatSliderThumb),
  multi: true
};
var MAT_SLIDER_RANGE_THUMB_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => MatSliderRangeThumb),
  multi: true
};
var MatSliderThumb = class _MatSliderThumb {
  get value() {
    return numberAttribute(this._hostElement.value, 0);
  }
  set value(value) {
    value = isNaN(value) ? 0 : value;
    const stringValue = value + "";
    if (!this._hasSetInitialValue) {
      this._initialValue = stringValue;
      return;
    }
    if (this._isActive) {
      return;
    }
    this._setValue(stringValue);
  }
  /**
   * Handles programmatic value setting. This has been split out to
   * allow the range thumb to override it and add additional necessary logic.
   */
  _setValue(value) {
    this._hostElement.value = value;
    this._updateThumbUIByValue();
    this._slider._onValueChange(this);
    this._cdr.detectChanges();
    this._slider._cdr.markForCheck();
  }
  /**
   * The current translateX in px of the slider visual thumb.
   * @docs-private
   */
  get translateX() {
    if (this._slider.min >= this._slider.max) {
      this._translateX = this._tickMarkOffset;
      return this._translateX;
    }
    if (this._translateX === void 0) {
      this._translateX = this._calcTranslateXByValue();
    }
    return this._translateX;
  }
  set translateX(v) {
    this._translateX = v;
  }
  /** @docs-private */
  get min() {
    return numberAttribute(this._hostElement.min, 0);
  }
  set min(v) {
    this._hostElement.min = v + "";
    this._cdr.detectChanges();
  }
  /** @docs-private */
  get max() {
    return numberAttribute(this._hostElement.max, 0);
  }
  set max(v) {
    this._hostElement.max = v + "";
    this._cdr.detectChanges();
  }
  get step() {
    return numberAttribute(this._hostElement.step, 0);
  }
  set step(v) {
    this._hostElement.step = v + "";
    this._cdr.detectChanges();
  }
  /** @docs-private */
  get disabled() {
    return booleanAttribute(this._hostElement.disabled);
  }
  set disabled(v) {
    this._hostElement.disabled = v;
    this._cdr.detectChanges();
    if (this._slider.disabled !== this.disabled) {
      this._slider.disabled = this.disabled;
    }
  }
  /** The percentage of the slider that coincides with the value. */
  get percentage() {
    if (this._slider.min >= this._slider.max) {
      return this._slider._isRtl ? 1 : 0;
    }
    return (this.value - this._slider.min) / (this._slider.max - this._slider.min);
  }
  /** @docs-private */
  get fillPercentage() {
    if (!this._slider._cachedWidth) {
      return this._slider._isRtl ? 1 : 0;
    }
    if (this._translateX === 0) {
      return 0;
    }
    return this.translateX / this._slider._cachedWidth;
  }
  /** Used to relay updates to _isFocused to the slider visual thumbs. */
  _setIsFocused(v) {
    this._isFocused = v;
  }
  constructor(_ngZone, _elementRef, _cdr, _slider) {
    this._ngZone = _ngZone;
    this._elementRef = _elementRef;
    this._cdr = _cdr;
    this._slider = _slider;
    this.valueChange = new EventEmitter();
    this.dragStart = new EventEmitter();
    this.dragEnd = new EventEmitter();
    this.thumbPosition = _MatThumb.END;
    this._valuetext = signal("");
    this._knobRadius = 8;
    this._tickMarkOffset = 3;
    this._isActive = false;
    this._isFocused = false;
    this._hasSetInitialValue = false;
    this._destroyed = new Subject();
    this._skipUIUpdate = false;
    this._onTouchedFn = () => {
    };
    this._isControlInitialized = false;
    this._platform = inject(Platform);
    this._hostElement = _elementRef.nativeElement;
    this._ngZone.runOutsideAngular(() => {
      this._hostElement.addEventListener("pointerdown", this._onPointerDown.bind(this));
      this._hostElement.addEventListener("pointermove", this._onPointerMove.bind(this));
      this._hostElement.addEventListener("pointerup", this._onPointerUp.bind(this));
    });
  }
  ngOnDestroy() {
    this._hostElement.removeEventListener("pointerdown", this._onPointerDown);
    this._hostElement.removeEventListener("pointermove", this._onPointerMove);
    this._hostElement.removeEventListener("pointerup", this._onPointerUp);
    this._destroyed.next();
    this._destroyed.complete();
    this.dragStart.complete();
    this.dragEnd.complete();
  }
  /** @docs-private */
  initProps() {
    this._updateWidthInactive();
    if (this.disabled !== this._slider.disabled) {
      this._slider.disabled = true;
    }
    this.step = this._slider.step;
    this.min = this._slider.min;
    this.max = this._slider.max;
    this._initValue();
  }
  /** @docs-private */
  initUI() {
    this._updateThumbUIByValue();
  }
  _initValue() {
    this._hasSetInitialValue = true;
    if (this._initialValue === void 0) {
      this.value = this._getDefaultValue();
    } else {
      this._hostElement.value = this._initialValue;
      this._updateThumbUIByValue();
      this._slider._onValueChange(this);
      this._cdr.detectChanges();
    }
  }
  _getDefaultValue() {
    return this.min;
  }
  _onBlur() {
    this._setIsFocused(false);
    this._onTouchedFn();
  }
  _onFocus() {
    this._slider._setTransition(false);
    this._slider._updateTrackUI(this);
    this._setIsFocused(true);
  }
  _onChange() {
    this.valueChange.emit(this.value);
    if (this._isActive) {
      this._updateThumbUIByValue({
        withAnimation: true
      });
    }
  }
  _onInput() {
    this._onChangeFn?.(this.value);
    if (this._slider.step || !this._isActive) {
      this._updateThumbUIByValue({
        withAnimation: true
      });
    }
    this._slider._onValueChange(this);
  }
  _onNgControlValueChange() {
    if (!this._isActive || !this._isFocused) {
      this._slider._onValueChange(this);
      this._updateThumbUIByValue();
    }
    this._slider.disabled = this._formControl.disabled;
  }
  _onPointerDown(event) {
    if (this.disabled || event.button !== 0) {
      return;
    }
    if (this._platform.IOS) {
      const isCursorOnSliderThumb = this._slider._isCursorOnSliderThumb(event, this._slider._getThumb(this.thumbPosition)._hostElement.getBoundingClientRect());
      this._isActive = isCursorOnSliderThumb;
      this._updateWidthActive();
      this._slider._updateDimensions();
      return;
    }
    this._isActive = true;
    this._setIsFocused(true);
    this._updateWidthActive();
    this._slider._updateDimensions();
    if (!this._slider.step) {
      this._updateThumbUIByPointerEvent(event, {
        withAnimation: true
      });
    }
    if (!this.disabled) {
      this._handleValueCorrection(event);
      this.dragStart.emit({
        source: this,
        parent: this._slider,
        value: this.value
      });
    }
  }
  /**
   * Corrects the value of the slider on pointer up/down.
   *
   * Called on pointer down and up because the value is set based
   * on the inactive width instead of the active width.
   */
  _handleValueCorrection(event) {
    this._skipUIUpdate = true;
    setTimeout(() => {
      this._skipUIUpdate = false;
      this._fixValue(event);
    }, 0);
  }
  /** Corrects the value of the slider based on the pointer event's position. */
  _fixValue(event) {
    const xPos = event.clientX - this._slider._cachedLeft;
    const width = this._slider._cachedWidth;
    const step = this._slider.step === 0 ? 1 : this._slider.step;
    const numSteps = Math.floor((this._slider.max - this._slider.min) / step);
    const percentage = this._slider._isRtl ? 1 - xPos / width : xPos / width;
    const fixedPercentage = Math.round(percentage * numSteps) / numSteps;
    const impreciseValue = fixedPercentage * (this._slider.max - this._slider.min) + this._slider.min;
    const value = Math.round(impreciseValue / step) * step;
    const prevValue = this.value;
    if (value === prevValue) {
      this._slider._onValueChange(this);
      this._slider.step > 0 ? this._updateThumbUIByValue() : this._updateThumbUIByPointerEvent(event, {
        withAnimation: this._slider._hasAnimation
      });
      return;
    }
    this.value = value;
    this.valueChange.emit(this.value);
    this._onChangeFn?.(this.value);
    this._slider._onValueChange(this);
    this._slider.step > 0 ? this._updateThumbUIByValue() : this._updateThumbUIByPointerEvent(event, {
      withAnimation: this._slider._hasAnimation
    });
  }
  _onPointerMove(event) {
    if (!this._slider.step && this._isActive) {
      this._updateThumbUIByPointerEvent(event);
    }
  }
  _onPointerUp() {
    if (this._isActive) {
      this._isActive = false;
      if (this._platform.SAFARI) {
        this._setIsFocused(false);
      }
      this.dragEnd.emit({
        source: this,
        parent: this._slider,
        value: this.value
      });
      setTimeout(() => this._updateWidthInactive(), this._platform.IOS ? 10 : 0);
    }
  }
  _clamp(v) {
    const min2 = this._tickMarkOffset;
    const max2 = this._slider._cachedWidth - this._tickMarkOffset;
    return Math.max(Math.min(v, max2), min2);
  }
  _calcTranslateXByValue() {
    if (this._slider._isRtl) {
      return (1 - this.percentage) * (this._slider._cachedWidth - this._tickMarkOffset * 2) + this._tickMarkOffset;
    }
    return this.percentage * (this._slider._cachedWidth - this._tickMarkOffset * 2) + this._tickMarkOffset;
  }
  _calcTranslateXByPointerEvent(event) {
    return event.clientX - this._slider._cachedLeft;
  }
  /**
   * Used to set the slider width to the correct
   * dimensions while the user is dragging.
   */
  _updateWidthActive() {
  }
  /**
   * Sets the slider input to disproportionate dimensions to allow for touch
   * events to be captured on touch devices.
   */
  _updateWidthInactive() {
    this._hostElement.style.padding = `0 ${this._slider._inputPadding}px`;
    this._hostElement.style.width = `calc(100% + ${this._slider._inputPadding - this._tickMarkOffset * 2}px)`;
    this._hostElement.style.left = `-${this._slider._rippleRadius - this._tickMarkOffset}px`;
  }
  _updateThumbUIByValue(options) {
    this.translateX = this._clamp(this._calcTranslateXByValue());
    this._updateThumbUI(options);
  }
  _updateThumbUIByPointerEvent(event, options) {
    this.translateX = this._clamp(this._calcTranslateXByPointerEvent(event));
    this._updateThumbUI(options);
  }
  _updateThumbUI(options) {
    this._slider._setTransition(!!options?.withAnimation);
    this._slider._onTranslateXChange(this);
  }
  /**
   * Sets the input's value.
   * @param value The new value of the input
   * @docs-private
   */
  writeValue(value) {
    if (this._isControlInitialized || value !== null) {
      this.value = value;
    }
  }
  /**
   * Registers a callback to be invoked when the input's value changes from user input.
   * @param fn The callback to register
   * @docs-private
   */
  registerOnChange(fn) {
    this._onChangeFn = fn;
    this._isControlInitialized = true;
  }
  /**
   * Registers a callback to be invoked when the input is blurred by the user.
   * @param fn The callback to register
   * @docs-private
   */
  registerOnTouched(fn) {
    this._onTouchedFn = fn;
  }
  /**
   * Sets the disabled state of the slider.
   * @param isDisabled The new disabled state
   * @docs-private
   */
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  focus() {
    this._hostElement.focus();
  }
  blur() {
    this._hostElement.blur();
  }
  static {
    this.ɵfac = function MatSliderThumb_Factory(t) {
      return new (t || _MatSliderThumb)(ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(MAT_SLIDER));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _MatSliderThumb,
      selectors: [["input", "matSliderThumb", ""]],
      hostAttrs: ["type", "range", 1, "mdc-slider__input"],
      hostVars: 1,
      hostBindings: function MatSliderThumb_HostBindings(rf, ctx) {
        if (rf & 1) {
          ɵɵlistener("change", function MatSliderThumb_change_HostBindingHandler() {
            return ctx._onChange();
          })("input", function MatSliderThumb_input_HostBindingHandler() {
            return ctx._onInput();
          })("blur", function MatSliderThumb_blur_HostBindingHandler() {
            return ctx._onBlur();
          })("focus", function MatSliderThumb_focus_HostBindingHandler() {
            return ctx._onFocus();
          });
        }
        if (rf & 2) {
          ɵɵattribute("aria-valuetext", ctx._valuetext());
        }
      },
      inputs: {
        value: [InputFlags.HasDecoratorInputTransform, "value", "value", numberAttribute]
      },
      outputs: {
        valueChange: "valueChange",
        dragStart: "dragStart",
        dragEnd: "dragEnd"
      },
      exportAs: ["matSliderThumb"],
      standalone: true,
      features: [ɵɵProvidersFeature([MAT_SLIDER_THUMB_VALUE_ACCESSOR, {
        provide: MAT_SLIDER_THUMB,
        useExisting: _MatSliderThumb
      }]), ɵɵInputTransformsFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatSliderThumb, [{
    type: Directive,
    args: [{
      selector: "input[matSliderThumb]",
      exportAs: "matSliderThumb",
      host: {
        "class": "mdc-slider__input",
        "type": "range",
        "[attr.aria-valuetext]": "_valuetext()",
        "(change)": "_onChange()",
        "(input)": "_onInput()",
        // TODO(wagnermaciel): Consider using a global event listener instead.
        // Reason: I have found a semi-consistent way to mouse up without triggering this event.
        "(blur)": "_onBlur()",
        "(focus)": "_onFocus()"
      },
      providers: [MAT_SLIDER_THUMB_VALUE_ACCESSOR, {
        provide: MAT_SLIDER_THUMB,
        useExisting: MatSliderThumb
      }],
      standalone: true
    }]
  }], () => [{
    type: NgZone
  }, {
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [MAT_SLIDER]
    }]
  }], {
    value: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    valueChange: [{
      type: Output
    }],
    dragStart: [{
      type: Output
    }],
    dragEnd: [{
      type: Output
    }]
  });
})();
var MatSliderRangeThumb = class _MatSliderRangeThumb extends MatSliderThumb {
  /** @docs-private */
  getSibling() {
    if (!this._sibling) {
      this._sibling = this._slider._getInput(this._isEndThumb ? _MatThumb.START : _MatThumb.END);
    }
    return this._sibling;
  }
  /**
   * Returns the minimum translateX position allowed for this slider input's visual thumb.
   * @docs-private
   */
  getMinPos() {
    const sibling = this.getSibling();
    if (!this._isLeftThumb && sibling) {
      return sibling.translateX;
    }
    return this._tickMarkOffset;
  }
  /**
   * Returns the maximum translateX position allowed for this slider input's visual thumb.
   * @docs-private
   */
  getMaxPos() {
    const sibling = this.getSibling();
    if (this._isLeftThumb && sibling) {
      return sibling.translateX;
    }
    return this._slider._cachedWidth - this._tickMarkOffset;
  }
  _setIsLeftThumb() {
    this._isLeftThumb = this._isEndThumb && this._slider._isRtl || !this._isEndThumb && !this._slider._isRtl;
  }
  constructor(_ngZone, _slider, _elementRef, _cdr) {
    super(_ngZone, _elementRef, _cdr, _slider);
    this._cdr = _cdr;
    this._isEndThumb = this._hostElement.hasAttribute("matSliderEndThumb");
    this._setIsLeftThumb();
    this.thumbPosition = this._isEndThumb ? _MatThumb.END : _MatThumb.START;
  }
  _getDefaultValue() {
    return this._isEndThumb && this._slider._isRange ? this.max : this.min;
  }
  _onInput() {
    super._onInput();
    this._updateSibling();
    if (!this._isActive) {
      this._updateWidthInactive();
    }
  }
  _onNgControlValueChange() {
    super._onNgControlValueChange();
    this.getSibling()?._updateMinMax();
  }
  _onPointerDown(event) {
    if (this.disabled || event.button !== 0) {
      return;
    }
    if (this._sibling) {
      this._sibling._updateWidthActive();
      this._sibling._hostElement.classList.add("mat-mdc-slider-input-no-pointer-events");
    }
    super._onPointerDown(event);
  }
  _onPointerUp() {
    super._onPointerUp();
    if (this._sibling) {
      setTimeout(() => {
        this._sibling._updateWidthInactive();
        this._sibling._hostElement.classList.remove("mat-mdc-slider-input-no-pointer-events");
      });
    }
  }
  _onPointerMove(event) {
    super._onPointerMove(event);
    if (!this._slider.step && this._isActive) {
      this._updateSibling();
    }
  }
  _fixValue(event) {
    super._fixValue(event);
    this._sibling?._updateMinMax();
  }
  _clamp(v) {
    return Math.max(Math.min(v, this.getMaxPos()), this.getMinPos());
  }
  _updateMinMax() {
    const sibling = this.getSibling();
    if (!sibling) {
      return;
    }
    if (this._isEndThumb) {
      this.min = Math.max(this._slider.min, sibling.value);
      this.max = this._slider.max;
    } else {
      this.min = this._slider.min;
      this.max = Math.min(this._slider.max, sibling.value);
    }
  }
  _updateWidthActive() {
    const minWidth = this._slider._rippleRadius * 2 - this._slider._inputPadding * 2;
    const maxWidth = this._slider._cachedWidth + this._slider._inputPadding - minWidth - this._tickMarkOffset * 2;
    const percentage = this._slider.min < this._slider.max ? (this.max - this.min) / (this._slider.max - this._slider.min) : 1;
    const width = maxWidth * percentage + minWidth;
    this._hostElement.style.width = `${width}px`;
    this._hostElement.style.padding = `0 ${this._slider._inputPadding}px`;
  }
  _updateWidthInactive() {
    const sibling = this.getSibling();
    if (!sibling) {
      return;
    }
    const maxWidth = this._slider._cachedWidth - this._tickMarkOffset * 2;
    const midValue = this._isEndThumb ? this.value - (this.value - sibling.value) / 2 : this.value + (sibling.value - this.value) / 2;
    const _percentage = this._isEndThumb ? (this.max - midValue) / (this._slider.max - this._slider.min) : (midValue - this.min) / (this._slider.max - this._slider.min);
    const percentage = this._slider.min < this._slider.max ? _percentage : 1;
    let ripplePadding = this._slider._rippleRadius;
    if (percentage === 1) {
      ripplePadding = 48;
    } else if (percentage === 0) {
      ripplePadding = 0;
    }
    const width = maxWidth * percentage + ripplePadding;
    this._hostElement.style.width = `${width}px`;
    this._hostElement.style.padding = "0px";
    if (this._isLeftThumb) {
      this._hostElement.style.left = `-${this._slider._rippleRadius - this._tickMarkOffset}px`;
      this._hostElement.style.right = "auto";
    } else {
      this._hostElement.style.left = "auto";
      this._hostElement.style.right = `-${this._slider._rippleRadius - this._tickMarkOffset}px`;
    }
  }
  _updateStaticStyles() {
    this._hostElement.classList.toggle("mat-slider__right-input", !this._isLeftThumb);
  }
  _updateSibling() {
    const sibling = this.getSibling();
    if (!sibling) {
      return;
    }
    sibling._updateMinMax();
    if (this._isActive) {
      sibling._updateWidthActive();
    } else {
      sibling._updateWidthInactive();
    }
  }
  /**
   * Sets the input's value.
   * @param value The new value of the input
   * @docs-private
   */
  writeValue(value) {
    if (this._isControlInitialized || value !== null) {
      this.value = value;
      this._updateWidthInactive();
      this._updateSibling();
    }
  }
  _setValue(value) {
    super._setValue(value);
    this._updateWidthInactive();
    this._updateSibling();
  }
  static {
    this.ɵfac = function MatSliderRangeThumb_Factory(t) {
      return new (t || _MatSliderRangeThumb)(ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(MAT_SLIDER), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _MatSliderRangeThumb,
      selectors: [["input", "matSliderStartThumb", ""], ["input", "matSliderEndThumb", ""]],
      exportAs: ["matSliderRangeThumb"],
      standalone: true,
      features: [ɵɵProvidersFeature([MAT_SLIDER_RANGE_THUMB_VALUE_ACCESSOR, {
        provide: MAT_SLIDER_RANGE_THUMB,
        useExisting: _MatSliderRangeThumb
      }]), ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatSliderRangeThumb, [{
    type: Directive,
    args: [{
      selector: "input[matSliderStartThumb], input[matSliderEndThumb]",
      exportAs: "matSliderRangeThumb",
      providers: [MAT_SLIDER_RANGE_THUMB_VALUE_ACCESSOR, {
        provide: MAT_SLIDER_RANGE_THUMB,
        useExisting: MatSliderRangeThumb
      }],
      standalone: true
    }]
  }], () => [{
    type: NgZone
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [MAT_SLIDER]
    }]
  }, {
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }], null);
})();
var MatSliderModule = class _MatSliderModule {
  static {
    this.ɵfac = function MatSliderModule_Factory(t) {
      return new (t || _MatSliderModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _MatSliderModule,
      imports: [MatCommonModule, MatRippleModule, MatSlider, MatSliderThumb, MatSliderRangeThumb, MatSliderVisualThumb],
      exports: [MatSlider, MatSliderThumb, MatSliderRangeThumb]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [MatCommonModule, MatRippleModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatSliderModule, [{
    type: NgModule,
    args: [{
      imports: [MatCommonModule, MatRippleModule, MatSlider, MatSliderThumb, MatSliderRangeThumb, MatSliderVisualThumb],
      exports: [MatSlider, MatSliderThumb, MatSliderRangeThumb]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/stepper.mjs
var _c04 = ["*"];
function CdkStep_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
var CdkStepHeader = class _CdkStepHeader {
  constructor(_elementRef) {
    this._elementRef = _elementRef;
  }
  /** Focuses the step header. */
  focus() {
    this._elementRef.nativeElement.focus();
  }
  static {
    this.ɵfac = function CdkStepHeader_Factory(t) {
      return new (t || _CdkStepHeader)(ɵɵdirectiveInject(ElementRef));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _CdkStepHeader,
      selectors: [["", "cdkStepHeader", ""]],
      hostAttrs: ["role", "tab"],
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkStepHeader, [{
    type: Directive,
    args: [{
      selector: "[cdkStepHeader]",
      host: {
        "role": "tab"
      },
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }], null);
})();
var CdkStepLabel = class _CdkStepLabel {
  constructor(template) {
    this.template = template;
  }
  static {
    this.ɵfac = function CdkStepLabel_Factory(t) {
      return new (t || _CdkStepLabel)(ɵɵdirectiveInject(TemplateRef));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _CdkStepLabel,
      selectors: [["", "cdkStepLabel", ""]],
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkStepLabel, [{
    type: Directive,
    args: [{
      selector: "[cdkStepLabel]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var nextId = 0;
var STEP_STATE = {
  NUMBER: "number",
  EDIT: "edit",
  DONE: "done",
  ERROR: "error"
};
var STEPPER_GLOBAL_OPTIONS = new InjectionToken("STEPPER_GLOBAL_OPTIONS");
var CdkStep = class _CdkStep {
  /** Whether step is marked as completed. */
  get completed() {
    return this._completedOverride == null ? this._getDefaultCompleted() : this._completedOverride;
  }
  set completed(value) {
    this._completedOverride = value;
  }
  _getDefaultCompleted() {
    return this.stepControl ? this.stepControl.valid && this.interacted : this.interacted;
  }
  /** Whether step has an error. */
  get hasError() {
    return this._customError == null ? this._getDefaultError() : this._customError;
  }
  set hasError(value) {
    this._customError = value;
  }
  _getDefaultError() {
    return this.stepControl && this.stepControl.invalid && this.interacted;
  }
  constructor(_stepper, stepperOptions) {
    this._stepper = _stepper;
    this.interacted = false;
    this.interactedStream = new EventEmitter();
    this.editable = true;
    this.optional = false;
    this._completedOverride = null;
    this._customError = null;
    this._stepperOptions = stepperOptions ? stepperOptions : {};
    this._displayDefaultIndicatorType = this._stepperOptions.displayDefaultIndicatorType !== false;
  }
  /** Selects this step component. */
  select() {
    this._stepper.selected = this;
  }
  /** Resets the step to its initial state. Note that this includes resetting form data. */
  reset() {
    this.interacted = false;
    if (this._completedOverride != null) {
      this._completedOverride = false;
    }
    if (this._customError != null) {
      this._customError = false;
    }
    if (this.stepControl) {
      this.stepControl.reset();
    }
  }
  ngOnChanges() {
    this._stepper._stateChanged();
  }
  _markAsInteracted() {
    if (!this.interacted) {
      this.interacted = true;
      this.interactedStream.emit(this);
    }
  }
  /** Determines whether the error state can be shown. */
  _showError() {
    return this._stepperOptions.showError ?? this._customError != null;
  }
  static {
    this.ɵfac = function CdkStep_Factory(t) {
      return new (t || _CdkStep)(ɵɵdirectiveInject(forwardRef(() => CdkStepper)), ɵɵdirectiveInject(STEPPER_GLOBAL_OPTIONS, 8));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _CdkStep,
      selectors: [["cdk-step"]],
      contentQueries: function CdkStep_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          ɵɵcontentQuery(dirIndex, CdkStepLabel, 5);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.stepLabel = _t.first);
        }
      },
      viewQuery: function CdkStep_Query(rf, ctx) {
        if (rf & 1) {
          ɵɵviewQuery(TemplateRef, 7);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.content = _t.first);
        }
      },
      inputs: {
        stepControl: "stepControl",
        label: "label",
        errorMessage: "errorMessage",
        ariaLabel: [InputFlags.None, "aria-label", "ariaLabel"],
        ariaLabelledby: [InputFlags.None, "aria-labelledby", "ariaLabelledby"],
        state: "state",
        editable: [InputFlags.HasDecoratorInputTransform, "editable", "editable", booleanAttribute],
        optional: [InputFlags.HasDecoratorInputTransform, "optional", "optional", booleanAttribute],
        completed: [InputFlags.HasDecoratorInputTransform, "completed", "completed", booleanAttribute],
        hasError: [InputFlags.HasDecoratorInputTransform, "hasError", "hasError", booleanAttribute]
      },
      outputs: {
        interactedStream: "interacted"
      },
      exportAs: ["cdkStep"],
      standalone: true,
      features: [ɵɵInputTransformsFeature, ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
      ngContentSelectors: _c04,
      decls: 1,
      vars: 0,
      template: function CdkStep_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef();
          ɵɵtemplate(0, CdkStep_ng_template_0_Template, 1, 0, "ng-template");
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkStep, [{
    type: Component,
    args: [{
      selector: "cdk-step",
      exportAs: "cdkStep",
      template: "<ng-template><ng-content></ng-content></ng-template>",
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: true
    }]
  }], () => [{
    type: CdkStepper,
    decorators: [{
      type: Inject,
      args: [forwardRef(() => CdkStepper)]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [STEPPER_GLOBAL_OPTIONS]
    }]
  }], {
    stepLabel: [{
      type: ContentChild,
      args: [CdkStepLabel]
    }],
    content: [{
      type: ViewChild,
      args: [TemplateRef, {
        static: true
      }]
    }],
    stepControl: [{
      type: Input
    }],
    interactedStream: [{
      type: Output,
      args: ["interacted"]
    }],
    label: [{
      type: Input
    }],
    errorMessage: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input,
      args: ["aria-label"]
    }],
    ariaLabelledby: [{
      type: Input,
      args: ["aria-labelledby"]
    }],
    state: [{
      type: Input
    }],
    editable: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    optional: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    completed: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    hasError: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }]
  });
})();
var CdkStepper = class _CdkStepper {
  /** The index of the selected step. */
  get selectedIndex() {
    return this._selectedIndex;
  }
  set selectedIndex(index) {
    if (this.steps && this._steps) {
      if (!this._isValidIndex(index) && (typeof ngDevMode === "undefined" || ngDevMode)) {
        throw Error("cdkStepper: Cannot assign out-of-bounds value to `selectedIndex`.");
      }
      this.selected?._markAsInteracted();
      if (this._selectedIndex !== index && !this._anyControlsInvalidOrPending(index) && (index >= this._selectedIndex || this.steps.toArray()[index].editable)) {
        this._updateSelectedItemIndex(index);
      }
    } else {
      this._selectedIndex = index;
    }
  }
  /** The step that is selected. */
  get selected() {
    return this.steps ? this.steps.toArray()[this.selectedIndex] : void 0;
  }
  set selected(step) {
    this.selectedIndex = step && this.steps ? this.steps.toArray().indexOf(step) : -1;
  }
  /** Orientation of the stepper. */
  get orientation() {
    return this._orientation;
  }
  set orientation(value) {
    this._orientation = value;
    if (this._keyManager) {
      this._keyManager.withVerticalOrientation(value === "vertical");
    }
  }
  constructor(_dir, _changeDetectorRef, _elementRef) {
    this._dir = _dir;
    this._changeDetectorRef = _changeDetectorRef;
    this._elementRef = _elementRef;
    this._destroyed = new Subject();
    this.steps = new QueryList();
    this._sortedHeaders = new QueryList();
    this.linear = false;
    this._selectedIndex = 0;
    this.selectionChange = new EventEmitter();
    this.selectedIndexChange = new EventEmitter();
    this._orientation = "horizontal";
    this._groupId = nextId++;
  }
  ngAfterContentInit() {
    this._steps.changes.pipe(startWith(this._steps), takeUntil(this._destroyed)).subscribe((steps) => {
      this.steps.reset(steps.filter((step) => step._stepper === this));
      this.steps.notifyOnChanges();
    });
  }
  ngAfterViewInit() {
    this._stepHeader.changes.pipe(startWith(this._stepHeader), takeUntil(this._destroyed)).subscribe((headers) => {
      this._sortedHeaders.reset(headers.toArray().sort((a, b) => {
        const documentPosition = a._elementRef.nativeElement.compareDocumentPosition(b._elementRef.nativeElement);
        return documentPosition & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1;
      }));
      this._sortedHeaders.notifyOnChanges();
    });
    this._keyManager = new FocusKeyManager(this._sortedHeaders).withWrap().withHomeAndEnd().withVerticalOrientation(this._orientation === "vertical");
    (this._dir ? this._dir.change : of()).pipe(startWith(this._layoutDirection()), takeUntil(this._destroyed)).subscribe((direction) => this._keyManager.withHorizontalOrientation(direction));
    this._keyManager.updateActiveItem(this._selectedIndex);
    this.steps.changes.subscribe(() => {
      if (!this.selected) {
        this._selectedIndex = Math.max(this._selectedIndex - 1, 0);
      }
    });
    if (!this._isValidIndex(this._selectedIndex)) {
      this._selectedIndex = 0;
    }
  }
  ngOnDestroy() {
    this._keyManager?.destroy();
    this.steps.destroy();
    this._sortedHeaders.destroy();
    this._destroyed.next();
    this._destroyed.complete();
  }
  /** Selects and focuses the next step in list. */
  next() {
    this.selectedIndex = Math.min(this._selectedIndex + 1, this.steps.length - 1);
  }
  /** Selects and focuses the previous step in list. */
  previous() {
    this.selectedIndex = Math.max(this._selectedIndex - 1, 0);
  }
  /** Resets the stepper to its initial state. Note that this includes clearing form data. */
  reset() {
    this._updateSelectedItemIndex(0);
    this.steps.forEach((step) => step.reset());
    this._stateChanged();
  }
  /** Returns a unique id for each step label element. */
  _getStepLabelId(i) {
    return `cdk-step-label-${this._groupId}-${i}`;
  }
  /** Returns unique id for each step content element. */
  _getStepContentId(i) {
    return `cdk-step-content-${this._groupId}-${i}`;
  }
  /** Marks the component to be change detected. */
  _stateChanged() {
    this._changeDetectorRef.markForCheck();
  }
  /** Returns position state of the step with the given index. */
  _getAnimationDirection(index) {
    const position = index - this._selectedIndex;
    if (position < 0) {
      return this._layoutDirection() === "rtl" ? "next" : "previous";
    } else if (position > 0) {
      return this._layoutDirection() === "rtl" ? "previous" : "next";
    }
    return "current";
  }
  /** Returns the type of icon to be displayed. */
  _getIndicatorType(index, state2 = STEP_STATE.NUMBER) {
    const step = this.steps.toArray()[index];
    const isCurrentStep = this._isCurrentStep(index);
    return step._displayDefaultIndicatorType ? this._getDefaultIndicatorLogic(step, isCurrentStep) : this._getGuidelineLogic(step, isCurrentStep, state2);
  }
  _getDefaultIndicatorLogic(step, isCurrentStep) {
    if (step._showError() && step.hasError && !isCurrentStep) {
      return STEP_STATE.ERROR;
    } else if (!step.completed || isCurrentStep) {
      return STEP_STATE.NUMBER;
    } else {
      return step.editable ? STEP_STATE.EDIT : STEP_STATE.DONE;
    }
  }
  _getGuidelineLogic(step, isCurrentStep, state2 = STEP_STATE.NUMBER) {
    if (step._showError() && step.hasError && !isCurrentStep) {
      return STEP_STATE.ERROR;
    } else if (step.completed && !isCurrentStep) {
      return STEP_STATE.DONE;
    } else if (step.completed && isCurrentStep) {
      return state2;
    } else if (step.editable && isCurrentStep) {
      return STEP_STATE.EDIT;
    } else {
      return state2;
    }
  }
  _isCurrentStep(index) {
    return this._selectedIndex === index;
  }
  /** Returns the index of the currently-focused step header. */
  _getFocusIndex() {
    return this._keyManager ? this._keyManager.activeItemIndex : this._selectedIndex;
  }
  _updateSelectedItemIndex(newIndex) {
    const stepsArray = this.steps.toArray();
    this.selectionChange.emit({
      selectedIndex: newIndex,
      previouslySelectedIndex: this._selectedIndex,
      selectedStep: stepsArray[newIndex],
      previouslySelectedStep: stepsArray[this._selectedIndex]
    });
    this._containsFocus() ? this._keyManager.setActiveItem(newIndex) : this._keyManager.updateActiveItem(newIndex);
    this._selectedIndex = newIndex;
    this.selectedIndexChange.emit(this._selectedIndex);
    this._stateChanged();
  }
  _onKeydown(event) {
    const hasModifier = hasModifierKey(event);
    const keyCode = event.keyCode;
    const manager = this._keyManager;
    if (manager.activeItemIndex != null && !hasModifier && (keyCode === SPACE || keyCode === ENTER)) {
      this.selectedIndex = manager.activeItemIndex;
      event.preventDefault();
    } else {
      manager.setFocusOrigin("keyboard").onKeydown(event);
    }
  }
  _anyControlsInvalidOrPending(index) {
    if (this.linear && index >= 0) {
      return this.steps.toArray().slice(0, index).some((step) => {
        const control = step.stepControl;
        const isIncomplete = control ? control.invalid || control.pending || !step.interacted : !step.completed;
        return isIncomplete && !step.optional && !step._completedOverride;
      });
    }
    return false;
  }
  _layoutDirection() {
    return this._dir && this._dir.value === "rtl" ? "rtl" : "ltr";
  }
  /** Checks whether the stepper contains the focused element. */
  _containsFocus() {
    const stepperElement = this._elementRef.nativeElement;
    const focusedElement = _getFocusedElementPierceShadowDom();
    return stepperElement === focusedElement || stepperElement.contains(focusedElement);
  }
  /** Checks whether the passed-in index is a valid step index. */
  _isValidIndex(index) {
    return index > -1 && (!this.steps || index < this.steps.length);
  }
  static {
    this.ɵfac = function CdkStepper_Factory(t) {
      return new (t || _CdkStepper)(ɵɵdirectiveInject(Directionality, 8), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _CdkStepper,
      selectors: [["", "cdkStepper", ""]],
      contentQueries: function CdkStepper_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          ɵɵcontentQuery(dirIndex, CdkStep, 5);
          ɵɵcontentQuery(dirIndex, CdkStepHeader, 5);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._steps = _t);
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._stepHeader = _t);
        }
      },
      inputs: {
        linear: [InputFlags.HasDecoratorInputTransform, "linear", "linear", booleanAttribute],
        selectedIndex: [InputFlags.HasDecoratorInputTransform, "selectedIndex", "selectedIndex", numberAttribute],
        selected: "selected",
        orientation: "orientation"
      },
      outputs: {
        selectionChange: "selectionChange",
        selectedIndexChange: "selectedIndexChange"
      },
      exportAs: ["cdkStepper"],
      standalone: true,
      features: [ɵɵInputTransformsFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkStepper, [{
    type: Directive,
    args: [{
      selector: "[cdkStepper]",
      exportAs: "cdkStepper",
      standalone: true
    }]
  }], () => [{
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }, {
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }], {
    _steps: [{
      type: ContentChildren,
      args: [CdkStep, {
        descendants: true
      }]
    }],
    _stepHeader: [{
      type: ContentChildren,
      args: [CdkStepHeader, {
        descendants: true
      }]
    }],
    linear: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    selectedIndex: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    selected: [{
      type: Input
    }],
    selectionChange: [{
      type: Output
    }],
    selectedIndexChange: [{
      type: Output
    }],
    orientation: [{
      type: Input
    }]
  });
})();
var CdkStepperNext = class _CdkStepperNext {
  constructor(_stepper) {
    this._stepper = _stepper;
    this.type = "submit";
  }
  static {
    this.ɵfac = function CdkStepperNext_Factory(t) {
      return new (t || _CdkStepperNext)(ɵɵdirectiveInject(CdkStepper));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _CdkStepperNext,
      selectors: [["button", "cdkStepperNext", ""]],
      hostVars: 1,
      hostBindings: function CdkStepperNext_HostBindings(rf, ctx) {
        if (rf & 1) {
          ɵɵlistener("click", function CdkStepperNext_click_HostBindingHandler() {
            return ctx._stepper.next();
          });
        }
        if (rf & 2) {
          ɵɵhostProperty("type", ctx.type);
        }
      },
      inputs: {
        type: "type"
      },
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkStepperNext, [{
    type: Directive,
    args: [{
      selector: "button[cdkStepperNext]",
      host: {
        "[type]": "type",
        "(click)": "_stepper.next()"
      },
      standalone: true
    }]
  }], () => [{
    type: CdkStepper
  }], {
    type: [{
      type: Input
    }]
  });
})();
var CdkStepperPrevious = class _CdkStepperPrevious {
  constructor(_stepper) {
    this._stepper = _stepper;
    this.type = "button";
  }
  static {
    this.ɵfac = function CdkStepperPrevious_Factory(t) {
      return new (t || _CdkStepperPrevious)(ɵɵdirectiveInject(CdkStepper));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _CdkStepperPrevious,
      selectors: [["button", "cdkStepperPrevious", ""]],
      hostVars: 1,
      hostBindings: function CdkStepperPrevious_HostBindings(rf, ctx) {
        if (rf & 1) {
          ɵɵlistener("click", function CdkStepperPrevious_click_HostBindingHandler() {
            return ctx._stepper.previous();
          });
        }
        if (rf & 2) {
          ɵɵhostProperty("type", ctx.type);
        }
      },
      inputs: {
        type: "type"
      },
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkStepperPrevious, [{
    type: Directive,
    args: [{
      selector: "button[cdkStepperPrevious]",
      host: {
        "[type]": "type",
        "(click)": "_stepper.previous()"
      },
      standalone: true
    }]
  }], () => [{
    type: CdkStepper
  }], {
    type: [{
      type: Input
    }]
  });
})();
var CdkStepperModule = class _CdkStepperModule {
  static {
    this.ɵfac = function CdkStepperModule_Factory(t) {
      return new (t || _CdkStepperModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _CdkStepperModule,
      imports: [BidiModule, CdkStep, CdkStepper, CdkStepHeader, CdkStepLabel, CdkStepperNext, CdkStepperPrevious],
      exports: [CdkStep, CdkStepper, CdkStepHeader, CdkStepLabel, CdkStepperNext, CdkStepperPrevious]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [BidiModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkStepperModule, [{
    type: NgModule,
    args: [{
      imports: [BidiModule, CdkStep, CdkStepper, CdkStepHeader, CdkStepLabel, CdkStepperNext, CdkStepperPrevious],
      exports: [CdkStep, CdkStepper, CdkStepHeader, CdkStepLabel, CdkStepperNext, CdkStepperPrevious]
    }]
  }], null, null);
})();

// node_modules/@angular/material/fesm2022/stepper.mjs
function MatStepHeader_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 2);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.iconOverrides[ctx_r0.state])("ngTemplateOutletContext", ctx_r0._getIconContext());
  }
}
function MatStepHeader_Conditional_4_Case_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 7);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0._getDefaultTextForState(ctx_r0.state));
  }
}
function MatStepHeader_Conditional_4_Case_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 8);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0._intl.completedLabel);
  }
}
function MatStepHeader_Conditional_4_Case_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 8);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0._intl.editableLabel);
  }
}
function MatStepHeader_Conditional_4_Case_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MatStepHeader_Conditional_4_Case_1_Conditional_0_Template, 2, 1, "span", 8)(1, MatStepHeader_Conditional_4_Case_1_Conditional_1_Template, 2, 1);
    ɵɵelementStart(2, "mat-icon", 7);
    ɵɵtext(3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵconditional(0, ctx_r0.state === "done" ? 0 : ctx_r0.state === "edit" ? 1 : -1);
    ɵɵadvance(3);
    ɵɵtextInterpolate(ctx_r0._getDefaultTextForState(ctx_r0.state));
  }
}
function MatStepHeader_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MatStepHeader_Conditional_4_Case_0_Template, 2, 1)(1, MatStepHeader_Conditional_4_Case_1_Template, 4, 2);
  }
  if (rf & 2) {
    let tmp_1_0;
    const ctx_r0 = ɵɵnextContext();
    ɵɵconditional(0, (tmp_1_0 = ctx_r0.state) === "number" ? 0 : 1);
  }
}
function MatStepHeader_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 4);
    ɵɵelementContainer(1, 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx.template);
  }
}
function MatStepHeader_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 4);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.label);
  }
}
function MatStepHeader_Conditional_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 5);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0._intl.optionalLabel);
  }
}
function MatStepHeader_Conditional_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.errorMessage);
  }
}
var _c05 = ["*"];
function MatStep_ng_template_0_ng_template_1_Template(rf, ctx) {
}
function MatStep_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
    ɵɵtemplate(1, MatStep_ng_template_0_ng_template_1_Template, 0, 0, "ng-template", 0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("cdkPortalOutlet", ctx_r0._portal);
  }
}
var _c111 = (a0, a1) => ({
  step: a0,
  i: a1
});
var _c210 = (a0) => ({
  "animationDuration": a0
});
var _c33 = (a0, a1) => ({
  "value": a0,
  "params": a1
});
function MatStepper_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
function MatStepper_Case_1_For_3_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 6);
  }
}
function MatStepper_Case_1_For_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 5);
    ɵɵtemplate(1, MatStepper_Case_1_For_3_Conditional_1_Template, 1, 0, "div", 6);
  }
  if (rf & 2) {
    const step_r1 = ctx.$implicit;
    const i_r2 = ctx.$index;
    const ɵi_8_r3 = ctx.$index;
    const ɵ$count_8_r4 = ctx.$count;
    ɵɵnextContext(2);
    const stepTemplate_r5 = ɵɵreference(4);
    ɵɵproperty("ngTemplateOutlet", stepTemplate_r5)("ngTemplateOutletContext", ɵɵpureFunction2(3, _c111, step_r1, i_r2));
    ɵɵadvance();
    ɵɵconditional(1, !(ɵi_8_r3 === ɵ$count_8_r4 - 1) ? 1 : -1);
  }
}
function MatStepper_Case_1_For_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 7);
    ɵɵlistener("@horizontalStepTransition.done", function MatStepper_Case_1_For_6_Template_div_animation_horizontalStepTransition_done_0_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r6 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r6._animationDone.next($event));
    });
    ɵɵelementContainer(1, 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const step_r8 = ctx.$implicit;
    const i_r9 = ctx.$index;
    const ctx_r6 = ɵɵnextContext(2);
    ɵɵclassProp("mat-horizontal-stepper-content-inactive", ctx_r6.selectedIndex !== i_r9);
    ɵɵproperty("@horizontalStepTransition", ɵɵpureFunction2(8, _c33, ctx_r6._getAnimationDirection(i_r9), ɵɵpureFunction1(6, _c210, ctx_r6._getAnimationDuration())))("id", ctx_r6._getStepContentId(i_r9));
    ɵɵattribute("aria-labelledby", ctx_r6._getStepLabelId(i_r9));
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", step_r8.content);
  }
}
function MatStepper_Case_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 1)(1, "div", 2);
    ɵɵrepeaterCreate(2, MatStepper_Case_1_For_3_Template, 2, 6, null, null, ɵɵrepeaterTrackByIdentity);
    ɵɵelementEnd();
    ɵɵelementStart(4, "div", 3);
    ɵɵrepeaterCreate(5, MatStepper_Case_1_For_6_Template, 2, 11, "div", 4, ɵɵrepeaterTrackByIdentity);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r6 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵrepeater(ctx_r6.steps);
    ɵɵadvance(3);
    ɵɵrepeater(ctx_r6.steps);
  }
}
function MatStepper_Case_2_For_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 9);
    ɵɵelementContainer(1, 5);
    ɵɵelementStart(2, "div", 10)(3, "div", 11);
    ɵɵlistener("@verticalStepTransition.done", function MatStepper_Case_2_For_1_Template_div_animation_verticalStepTransition_done_3_listener($event) {
      ɵɵrestoreView(_r10);
      const ctx_r6 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r6._animationDone.next($event));
    });
    ɵɵelementStart(4, "div", 12);
    ɵɵelementContainer(5, 8);
    ɵɵelementEnd()()()();
  }
  if (rf & 2) {
    const step_r11 = ctx.$implicit;
    const i_r12 = ctx.$index;
    const ɵi_22_r13 = ctx.$index;
    const ɵ$count_22_r14 = ctx.$count;
    const ctx_r6 = ɵɵnextContext(2);
    const stepTemplate_r5 = ɵɵreference(4);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", stepTemplate_r5)("ngTemplateOutletContext", ɵɵpureFunction2(10, _c111, step_r11, i_r12));
    ɵɵadvance();
    ɵɵclassProp("mat-stepper-vertical-line", !(ɵi_22_r13 === ɵ$count_22_r14 - 1));
    ɵɵadvance();
    ɵɵclassProp("mat-vertical-stepper-content-inactive", ctx_r6.selectedIndex !== i_r12);
    ɵɵproperty("@verticalStepTransition", ɵɵpureFunction2(15, _c33, ctx_r6._getAnimationDirection(i_r12), ɵɵpureFunction1(13, _c210, ctx_r6._getAnimationDuration())))("id", ctx_r6._getStepContentId(i_r12));
    ɵɵattribute("aria-labelledby", ctx_r6._getStepLabelId(i_r12));
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", step_r11.content);
  }
}
function MatStepper_Case_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵrepeaterCreate(0, MatStepper_Case_2_For_1_Template, 6, 18, "div", 9, ɵɵrepeaterTrackByIdentity);
  }
  if (rf & 2) {
    const ctx_r6 = ɵɵnextContext();
    ɵɵrepeater(ctx_r6.steps);
  }
}
function MatStepper_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r15 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mat-step-header", 13);
    ɵɵlistener("click", function MatStepper_ng_template_3_Template_mat_step_header_click_0_listener() {
      const step_r16 = ɵɵrestoreView(_r15).step;
      return ɵɵresetView(step_r16.select());
    })("keydown", function MatStepper_ng_template_3_Template_mat_step_header_keydown_0_listener($event) {
      ɵɵrestoreView(_r15);
      const ctx_r6 = ɵɵnextContext();
      return ɵɵresetView(ctx_r6._onKeydown($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const step_r16 = ctx.step;
    const i_r17 = ctx.i;
    const ctx_r6 = ɵɵnextContext();
    ɵɵclassProp("mat-horizontal-stepper-header", ctx_r6.orientation === "horizontal")("mat-vertical-stepper-header", ctx_r6.orientation === "vertical");
    ɵɵproperty("tabIndex", ctx_r6._getFocusIndex() === i_r17 ? 0 : -1)("id", ctx_r6._getStepLabelId(i_r17))("index", i_r17)("state", ctx_r6._getIndicatorType(i_r17, step_r16.state))("label", step_r16.stepLabel || step_r16.label)("selected", ctx_r6.selectedIndex === i_r17)("active", ctx_r6._stepIsNavigable(i_r17, step_r16))("optional", step_r16.optional)("errorMessage", step_r16.errorMessage)("iconOverrides", ctx_r6._iconOverrides)("disableRipple", ctx_r6.disableRipple || !ctx_r6._stepIsNavigable(i_r17, step_r16))("color", step_r16.color || ctx_r6.color);
    ɵɵattribute("aria-posinset", i_r17 + 1)("aria-setsize", ctx_r6.steps.length)("aria-controls", ctx_r6._getStepContentId(i_r17))("aria-selected", ctx_r6.selectedIndex == i_r17)("aria-label", step_r16.ariaLabel || null)("aria-labelledby", !step_r16.ariaLabel && step_r16.ariaLabelledby ? step_r16.ariaLabelledby : null)("aria-disabled", ctx_r6._stepIsNavigable(i_r17, step_r16) ? null : true);
  }
}
var MatStepLabel = class _MatStepLabel extends CdkStepLabel {
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵMatStepLabel_BaseFactory;
      return function MatStepLabel_Factory(t) {
        return (ɵMatStepLabel_BaseFactory || (ɵMatStepLabel_BaseFactory = ɵɵgetInheritedFactory(_MatStepLabel)))(t || _MatStepLabel);
      };
    })();
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _MatStepLabel,
      selectors: [["", "matStepLabel", ""]],
      standalone: true,
      features: [ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatStepLabel, [{
    type: Directive,
    args: [{
      selector: "[matStepLabel]",
      standalone: true
    }]
  }], null, null);
})();
var MatStepperIntl = class _MatStepperIntl {
  constructor() {
    this.changes = new Subject();
    this.optionalLabel = "Optional";
    this.completedLabel = "Completed";
    this.editableLabel = "Editable";
  }
  static {
    this.ɵfac = function MatStepperIntl_Factory(t) {
      return new (t || _MatStepperIntl)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _MatStepperIntl,
      factory: _MatStepperIntl.ɵfac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatStepperIntl, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
function MAT_STEPPER_INTL_PROVIDER_FACTORY(parentIntl) {
  return parentIntl || new MatStepperIntl();
}
var MAT_STEPPER_INTL_PROVIDER = {
  provide: MatStepperIntl,
  deps: [[new Optional(), new SkipSelf(), MatStepperIntl]],
  useFactory: MAT_STEPPER_INTL_PROVIDER_FACTORY
};
var MatStepHeader = class _MatStepHeader extends CdkStepHeader {
  constructor(_intl, _focusMonitor, _elementRef, changeDetectorRef) {
    super(_elementRef);
    this._intl = _intl;
    this._focusMonitor = _focusMonitor;
    this._intlSubscription = _intl.changes.subscribe(() => changeDetectorRef.markForCheck());
  }
  ngAfterViewInit() {
    this._focusMonitor.monitor(this._elementRef, true);
  }
  ngOnDestroy() {
    this._intlSubscription.unsubscribe();
    this._focusMonitor.stopMonitoring(this._elementRef);
  }
  /** Focuses the step header. */
  focus(origin, options) {
    if (origin) {
      this._focusMonitor.focusVia(this._elementRef, origin, options);
    } else {
      this._elementRef.nativeElement.focus(options);
    }
  }
  /** Returns string label of given step if it is a text label. */
  _stringLabel() {
    return this.label instanceof MatStepLabel ? null : this.label;
  }
  /** Returns MatStepLabel if the label of given step is a template label. */
  _templateLabel() {
    return this.label instanceof MatStepLabel ? this.label : null;
  }
  /** Returns the host HTML element. */
  _getHostElement() {
    return this._elementRef.nativeElement;
  }
  /** Template context variables that are exposed to the `matStepperIcon` instances. */
  _getIconContext() {
    return {
      index: this.index,
      active: this.active,
      optional: this.optional
    };
  }
  _getDefaultTextForState(state2) {
    if (state2 == "number") {
      return `${this.index + 1}`;
    }
    if (state2 == "edit") {
      return "create";
    }
    if (state2 == "error") {
      return "warning";
    }
    return state2;
  }
  static {
    this.ɵfac = function MatStepHeader_Factory(t) {
      return new (t || _MatStepHeader)(ɵɵdirectiveInject(MatStepperIntl), ɵɵdirectiveInject(FocusMonitor), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _MatStepHeader,
      selectors: [["mat-step-header"]],
      hostAttrs: ["role", "tab", 1, "mat-step-header"],
      hostVars: 2,
      hostBindings: function MatStepHeader_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵclassMap("mat-" + (ctx.color || "primary"));
        }
      },
      inputs: {
        state: "state",
        label: "label",
        errorMessage: "errorMessage",
        iconOverrides: "iconOverrides",
        index: "index",
        selected: "selected",
        active: "active",
        optional: "optional",
        disableRipple: "disableRipple",
        color: "color"
      },
      standalone: true,
      features: [ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
      decls: 10,
      vars: 17,
      consts: [["matRipple", "", 1, "mat-step-header-ripple", "mat-focus-indicator", 3, "matRippleTrigger", "matRippleDisabled"], [1, "mat-step-icon-content"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "mat-step-label"], [1, "mat-step-text-label"], [1, "mat-step-optional"], [1, "mat-step-sub-label-error"], ["aria-hidden", "true"], [1, "cdk-visually-hidden"], [3, "ngTemplateOutlet"]],
      template: function MatStepHeader_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelement(0, "div", 0);
          ɵɵelementStart(1, "div")(2, "div", 1);
          ɵɵtemplate(3, MatStepHeader_Conditional_3_Template, 1, 2, "ng-container", 2)(4, MatStepHeader_Conditional_4_Template, 2, 1);
          ɵɵelementEnd()();
          ɵɵelementStart(5, "div", 3);
          ɵɵtemplate(6, MatStepHeader_Conditional_6_Template, 2, 1, "div", 4)(7, MatStepHeader_Conditional_7_Template, 2, 1)(8, MatStepHeader_Conditional_8_Template, 2, 1, "div", 5)(9, MatStepHeader_Conditional_9_Template, 2, 1, "div", 6);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          let tmp_8_0;
          ɵɵproperty("matRippleTrigger", ctx._getHostElement())("matRippleDisabled", ctx.disableRipple);
          ɵɵadvance();
          ɵɵclassMapInterpolate1("mat-step-icon-state-", ctx.state, " mat-step-icon");
          ɵɵclassProp("mat-step-icon-selected", ctx.selected);
          ɵɵadvance(2);
          ɵɵconditional(3, ctx.iconOverrides && ctx.iconOverrides[ctx.state] ? 3 : 4);
          ɵɵadvance(2);
          ɵɵclassProp("mat-step-label-active", ctx.active)("mat-step-label-selected", ctx.selected)("mat-step-label-error", ctx.state == "error");
          ɵɵadvance();
          ɵɵconditional(6, (tmp_8_0 = ctx._templateLabel()) ? 6 : ctx._stringLabel() ? 7 : -1, tmp_8_0);
          ɵɵadvance(2);
          ɵɵconditional(8, ctx.optional && ctx.state != "error" ? 8 : -1);
          ɵɵadvance();
          ɵɵconditional(9, ctx.state === "error" ? 9 : -1);
        }
      },
      dependencies: [MatRipple, NgTemplateOutlet, MatIcon],
      styles: ['.mat-step-header{overflow:hidden;outline:none;cursor:pointer;position:relative;box-sizing:content-box;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-step-header:focus .mat-focus-indicator::before{content:""}.mat-step-header:hover[aria-disabled=true]{cursor:default}.mat-step-header:hover:not([aria-disabled]),.mat-step-header:hover[aria-disabled=false]{background-color:var(--mat-stepper-header-hover-state-layer-color);border-radius:var(--mat-stepper-header-hover-state-layer-shape)}.mat-step-header.cdk-keyboard-focused,.mat-step-header.cdk-program-focused{background-color:var(--mat-stepper-header-focus-state-layer-color);border-radius:var(--mat-stepper-header-focus-state-layer-shape)}@media(hover: none){.mat-step-header:hover{background:none}}.cdk-high-contrast-active .mat-step-header{outline:solid 1px}.cdk-high-contrast-active .mat-step-header[aria-selected=true] .mat-step-label{text-decoration:underline}.cdk-high-contrast-active .mat-step-header[aria-disabled=true]{outline-color:GrayText}.cdk-high-contrast-active .mat-step-header[aria-disabled=true] .mat-step-label,.cdk-high-contrast-active .mat-step-header[aria-disabled=true] .mat-step-icon,.cdk-high-contrast-active .mat-step-header[aria-disabled=true] .mat-step-optional{color:GrayText}.mat-step-optional{font-size:12px;color:var(--mat-stepper-header-optional-label-text-color)}.mat-step-sub-label-error{font-size:12px;font-weight:normal}.mat-step-icon{border-radius:50%;height:24px;width:24px;flex-shrink:0;position:relative;color:var(--mat-stepper-header-icon-foreground-color);background-color:var(--mat-stepper-header-icon-background-color)}.mat-step-icon-content{position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);display:flex}.mat-step-icon .mat-icon{font-size:16px;height:16px;width:16px}.mat-step-icon-state-error{background-color:var(--mat-stepper-header-error-state-icon-background-color);color:var(--mat-stepper-header-error-state-icon-foreground-color)}.mat-step-icon-state-error .mat-icon{font-size:24px;height:24px;width:24px}.mat-step-label{display:inline-block;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;min-width:50px;vertical-align:middle;font-family:var(--mat-stepper-header-label-text-font);font-size:var(--mat-stepper-header-label-text-size);font-weight:var(--mat-stepper-header-label-text-weight);color:var(--mat-stepper-header-label-text-color)}.mat-step-label.mat-step-label-active{color:var(--mat-stepper-header-selected-state-label-text-color)}.mat-step-label.mat-step-label-error{color:var(--mat-stepper-header-error-state-label-text-color);font-size:var(--mat-stepper-header-error-state-label-text-size)}.mat-step-label.mat-step-label-selected{font-size:var(--mat-stepper-header-selected-state-label-text-size);font-weight:var(--mat-stepper-header-selected-state-label-text-weight)}.mat-step-text-label{text-overflow:ellipsis;overflow:hidden}.mat-step-header .mat-step-header-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-step-icon-selected{background-color:var(--mat-stepper-header-selected-state-icon-background-color);color:var(--mat-stepper-header-selected-state-icon-foreground-color)}.mat-step-icon-state-done{background-color:var(--mat-stepper-header-done-state-icon-background-color);color:var(--mat-stepper-header-done-state-icon-foreground-color)}.mat-step-icon-state-edit{background-color:var(--mat-stepper-header-edit-state-icon-background-color);color:var(--mat-stepper-header-edit-state-icon-foreground-color)}'],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatStepHeader, [{
    type: Component,
    args: [{
      selector: "mat-step-header",
      host: {
        "class": "mat-step-header",
        "[class]": '"mat-" + (color || "primary")',
        "role": "tab"
      },
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: true,
      imports: [MatRipple, NgTemplateOutlet, MatIcon],
      template: `<div class="mat-step-header-ripple mat-focus-indicator" matRipple
     [matRippleTrigger]="_getHostElement()"
     [matRippleDisabled]="disableRipple"></div>

<div class="mat-step-icon-state-{{state}} mat-step-icon" [class.mat-step-icon-selected]="selected">
  <div class="mat-step-icon-content">
    @if (iconOverrides && iconOverrides[state]) {
      <ng-container
        [ngTemplateOutlet]="iconOverrides[state]"
        [ngTemplateOutletContext]="_getIconContext()"></ng-container>
    } @else {
      @switch (state) {
        @case ('number') {
          <span aria-hidden="true">{{_getDefaultTextForState(state)}}</span>
        }

        @default {
          @if (state === 'done') {
            <span class="cdk-visually-hidden">{{_intl.completedLabel}}</span>
          } @else if (state === 'edit') {
            <span class="cdk-visually-hidden">{{_intl.editableLabel}}</span>
          }

          <mat-icon aria-hidden="true">{{_getDefaultTextForState(state)}}</mat-icon>
        }
      }
    }
  </div>
</div>
<div class="mat-step-label"
     [class.mat-step-label-active]="active"
     [class.mat-step-label-selected]="selected"
     [class.mat-step-label-error]="state == 'error'">
  @if (_templateLabel(); as templateLabel) {
    <!-- If there is a label template, use it. -->
    <div class="mat-step-text-label">
      <ng-container [ngTemplateOutlet]="templateLabel.template"></ng-container>
    </div>
  } @else if (_stringLabel()) {
    <!-- If there is no label template, fall back to the text label. -->
    <div class="mat-step-text-label">{{label}}</div>
  }

  @if (optional && state != 'error') {
    <div class="mat-step-optional">{{_intl.optionalLabel}}</div>
  }

  @if (state === 'error') {
    <div class="mat-step-sub-label-error">{{errorMessage}}</div>
  }
</div>

`,
      styles: ['.mat-step-header{overflow:hidden;outline:none;cursor:pointer;position:relative;box-sizing:content-box;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-step-header:focus .mat-focus-indicator::before{content:""}.mat-step-header:hover[aria-disabled=true]{cursor:default}.mat-step-header:hover:not([aria-disabled]),.mat-step-header:hover[aria-disabled=false]{background-color:var(--mat-stepper-header-hover-state-layer-color);border-radius:var(--mat-stepper-header-hover-state-layer-shape)}.mat-step-header.cdk-keyboard-focused,.mat-step-header.cdk-program-focused{background-color:var(--mat-stepper-header-focus-state-layer-color);border-radius:var(--mat-stepper-header-focus-state-layer-shape)}@media(hover: none){.mat-step-header:hover{background:none}}.cdk-high-contrast-active .mat-step-header{outline:solid 1px}.cdk-high-contrast-active .mat-step-header[aria-selected=true] .mat-step-label{text-decoration:underline}.cdk-high-contrast-active .mat-step-header[aria-disabled=true]{outline-color:GrayText}.cdk-high-contrast-active .mat-step-header[aria-disabled=true] .mat-step-label,.cdk-high-contrast-active .mat-step-header[aria-disabled=true] .mat-step-icon,.cdk-high-contrast-active .mat-step-header[aria-disabled=true] .mat-step-optional{color:GrayText}.mat-step-optional{font-size:12px;color:var(--mat-stepper-header-optional-label-text-color)}.mat-step-sub-label-error{font-size:12px;font-weight:normal}.mat-step-icon{border-radius:50%;height:24px;width:24px;flex-shrink:0;position:relative;color:var(--mat-stepper-header-icon-foreground-color);background-color:var(--mat-stepper-header-icon-background-color)}.mat-step-icon-content{position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);display:flex}.mat-step-icon .mat-icon{font-size:16px;height:16px;width:16px}.mat-step-icon-state-error{background-color:var(--mat-stepper-header-error-state-icon-background-color);color:var(--mat-stepper-header-error-state-icon-foreground-color)}.mat-step-icon-state-error .mat-icon{font-size:24px;height:24px;width:24px}.mat-step-label{display:inline-block;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;min-width:50px;vertical-align:middle;font-family:var(--mat-stepper-header-label-text-font);font-size:var(--mat-stepper-header-label-text-size);font-weight:var(--mat-stepper-header-label-text-weight);color:var(--mat-stepper-header-label-text-color)}.mat-step-label.mat-step-label-active{color:var(--mat-stepper-header-selected-state-label-text-color)}.mat-step-label.mat-step-label-error{color:var(--mat-stepper-header-error-state-label-text-color);font-size:var(--mat-stepper-header-error-state-label-text-size)}.mat-step-label.mat-step-label-selected{font-size:var(--mat-stepper-header-selected-state-label-text-size);font-weight:var(--mat-stepper-header-selected-state-label-text-weight)}.mat-step-text-label{text-overflow:ellipsis;overflow:hidden}.mat-step-header .mat-step-header-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-step-icon-selected{background-color:var(--mat-stepper-header-selected-state-icon-background-color);color:var(--mat-stepper-header-selected-state-icon-foreground-color)}.mat-step-icon-state-done{background-color:var(--mat-stepper-header-done-state-icon-background-color);color:var(--mat-stepper-header-done-state-icon-foreground-color)}.mat-step-icon-state-edit{background-color:var(--mat-stepper-header-edit-state-icon-background-color);color:var(--mat-stepper-header-edit-state-icon-foreground-color)}']
    }]
  }], () => [{
    type: MatStepperIntl
  }, {
    type: FocusMonitor
  }, {
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }], {
    state: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    errorMessage: [{
      type: Input
    }],
    iconOverrides: [{
      type: Input
    }],
    index: [{
      type: Input
    }],
    selected: [{
      type: Input
    }],
    active: [{
      type: Input
    }],
    optional: [{
      type: Input
    }],
    disableRipple: [{
      type: Input
    }],
    color: [{
      type: Input
    }]
  });
})();
var DEFAULT_HORIZONTAL_ANIMATION_DURATION = "500ms";
var DEFAULT_VERTICAL_ANIMATION_DURATION = "225ms";
var matStepperAnimations = {
  /** Animation that transitions the step along the X axis in a horizontal stepper. */
  horizontalStepTransition: trigger("horizontalStepTransition", [
    state("previous", style({
      transform: "translate3d(-100%, 0, 0)",
      visibility: "hidden"
    })),
    // Transition to `inherit`, rather than `visible`,
    // because visibility on a child element the one from the parent,
    // making this element focusable inside of a `hidden` element.
    state("current", style({
      transform: "none",
      visibility: "inherit"
    })),
    state("next", style({
      transform: "translate3d(100%, 0, 0)",
      visibility: "hidden"
    })),
    transition("* => *", group([animate("{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)"), query("@*", animateChild(), {
      optional: true
    })]), {
      params: {
        "animationDuration": DEFAULT_HORIZONTAL_ANIMATION_DURATION
      }
    })
  ]),
  /** Animation that transitions the step along the Y axis in a vertical stepper. */
  verticalStepTransition: trigger("verticalStepTransition", [
    state("previous", style({
      height: "0px",
      visibility: "hidden"
    })),
    state("next", style({
      height: "0px",
      visibility: "hidden"
    })),
    // Transition to `inherit`, rather than `visible`,
    // because visibility on a child element the one from the parent,
    // making this element focusable inside of a `hidden` element.
    state("current", style({
      height: "*",
      visibility: "inherit"
    })),
    transition("* <=> current", group([animate("{{animationDuration}} cubic-bezier(0.4, 0.0, 0.2, 1)"), query("@*", animateChild(), {
      optional: true
    })]), {
      params: {
        "animationDuration": DEFAULT_VERTICAL_ANIMATION_DURATION
      }
    })
  ])
};
var MatStepperIcon = class _MatStepperIcon {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static {
    this.ɵfac = function MatStepperIcon_Factory(t) {
      return new (t || _MatStepperIcon)(ɵɵdirectiveInject(TemplateRef));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _MatStepperIcon,
      selectors: [["ng-template", "matStepperIcon", ""]],
      inputs: {
        name: [InputFlags.None, "matStepperIcon", "name"]
      },
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatStepperIcon, [{
    type: Directive,
    args: [{
      selector: "ng-template[matStepperIcon]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }], {
    name: [{
      type: Input,
      args: ["matStepperIcon"]
    }]
  });
})();
var MatStepContent = class _MatStepContent {
  constructor(_template) {
    this._template = _template;
  }
  static {
    this.ɵfac = function MatStepContent_Factory(t) {
      return new (t || _MatStepContent)(ɵɵdirectiveInject(TemplateRef));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _MatStepContent,
      selectors: [["ng-template", "matStepContent", ""]],
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatStepContent, [{
    type: Directive,
    args: [{
      selector: "ng-template[matStepContent]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var MatStep = class _MatStep extends CdkStep {
  constructor(stepper, _errorStateMatcher, _viewContainerRef, stepperOptions) {
    super(stepper, stepperOptions);
    this._errorStateMatcher = _errorStateMatcher;
    this._viewContainerRef = _viewContainerRef;
    this._isSelected = Subscription.EMPTY;
    this.stepLabel = void 0;
  }
  ngAfterContentInit() {
    this._isSelected = this._stepper.steps.changes.pipe(switchMap(() => {
      return this._stepper.selectionChange.pipe(map((event) => event.selectedStep === this), startWith(this._stepper.selected === this));
    })).subscribe((isSelected) => {
      if (isSelected && this._lazyContent && !this._portal) {
        this._portal = new TemplatePortal(this._lazyContent._template, this._viewContainerRef);
      }
    });
  }
  ngOnDestroy() {
    this._isSelected.unsubscribe();
  }
  /** Custom error state matcher that additionally checks for validity of interacted form. */
  isErrorState(control, form) {
    const originalErrorState = this._errorStateMatcher.isErrorState(control, form);
    const customErrorState = !!(control && control.invalid && this.interacted);
    return originalErrorState || customErrorState;
  }
  static {
    this.ɵfac = function MatStep_Factory(t) {
      return new (t || _MatStep)(ɵɵdirectiveInject(forwardRef(() => MatStepper)), ɵɵdirectiveInject(ErrorStateMatcher, 4), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(STEPPER_GLOBAL_OPTIONS, 8));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _MatStep,
      selectors: [["mat-step"]],
      contentQueries: function MatStep_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          ɵɵcontentQuery(dirIndex, MatStepLabel, 5);
          ɵɵcontentQuery(dirIndex, MatStepContent, 5);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.stepLabel = _t.first);
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._lazyContent = _t.first);
        }
      },
      hostAttrs: ["hidden", ""],
      inputs: {
        color: "color"
      },
      exportAs: ["matStep"],
      standalone: true,
      features: [ɵɵProvidersFeature([{
        provide: ErrorStateMatcher,
        useExisting: _MatStep
      }, {
        provide: CdkStep,
        useExisting: _MatStep
      }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
      ngContentSelectors: _c05,
      decls: 1,
      vars: 0,
      consts: [[3, "cdkPortalOutlet"]],
      template: function MatStep_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef();
          ɵɵtemplate(0, MatStep_ng_template_0_Template, 2, 1, "ng-template");
        }
      },
      dependencies: [CdkPortalOutlet],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatStep, [{
    type: Component,
    args: [{
      selector: "mat-step",
      providers: [{
        provide: ErrorStateMatcher,
        useExisting: MatStep
      }, {
        provide: CdkStep,
        useExisting: MatStep
      }],
      encapsulation: ViewEncapsulation$1.None,
      exportAs: "matStep",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: true,
      imports: [CdkPortalOutlet],
      host: {
        "hidden": ""
        // Hide the steps so they don't affect the layout.
      },
      template: '<ng-template>\n  <ng-content></ng-content>\n  <ng-template [cdkPortalOutlet]="_portal"></ng-template>\n</ng-template>\n'
    }]
  }], () => [{
    type: MatStepper,
    decorators: [{
      type: Inject,
      args: [forwardRef(() => MatStepper)]
    }]
  }, {
    type: ErrorStateMatcher,
    decorators: [{
      type: SkipSelf
    }]
  }, {
    type: ViewContainerRef
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [STEPPER_GLOBAL_OPTIONS]
    }]
  }], {
    stepLabel: [{
      type: ContentChild,
      args: [MatStepLabel]
    }],
    color: [{
      type: Input
    }],
    _lazyContent: [{
      type: ContentChild,
      args: [MatStepContent, {
        static: false
      }]
    }]
  });
})();
var MatStepper = class _MatStepper extends CdkStepper {
  /** Duration for the animation. Will be normalized to milliseconds if no units are set. */
  get animationDuration() {
    return this._animationDuration;
  }
  set animationDuration(value) {
    this._animationDuration = /^\d+$/.test(value) ? value + "ms" : value;
  }
  constructor(dir, changeDetectorRef, elementRef) {
    super(dir, changeDetectorRef, elementRef);
    this._stepHeader = void 0;
    this._steps = void 0;
    this.steps = new QueryList();
    this.animationDone = new EventEmitter();
    this.labelPosition = "end";
    this.headerPosition = "top";
    this._iconOverrides = {};
    this._animationDone = new Subject();
    this._animationDuration = "";
    this._isServer = !inject(Platform).isBrowser;
    const nodeName = elementRef.nativeElement.nodeName.toLowerCase();
    this.orientation = nodeName === "mat-vertical-stepper" ? "vertical" : "horizontal";
  }
  ngAfterContentInit() {
    super.ngAfterContentInit();
    this._icons.forEach(({
      name,
      templateRef
    }) => this._iconOverrides[name] = templateRef);
    this.steps.changes.pipe(takeUntil(this._destroyed)).subscribe(() => {
      this._stateChanged();
    });
    this._animationDone.pipe(
      // This needs a `distinctUntilChanged` in order to avoid emitting the same event twice due
      // to a bug in animations where the `.done` callback gets invoked twice on some browsers.
      // See https://github.com/angular/angular/issues/24084
      distinctUntilChanged((x, y) => x.fromState === y.fromState && x.toState === y.toState),
      takeUntil(this._destroyed)
    ).subscribe((event) => {
      if (event.toState === "current") {
        this.animationDone.emit();
      }
    });
  }
  _stepIsNavigable(index, step) {
    return step.completed || this.selectedIndex === index || !this.linear;
  }
  _getAnimationDuration() {
    if (this.animationDuration) {
      return this.animationDuration;
    }
    return this.orientation === "horizontal" ? DEFAULT_HORIZONTAL_ANIMATION_DURATION : DEFAULT_VERTICAL_ANIMATION_DURATION;
  }
  static {
    this.ɵfac = function MatStepper_Factory(t) {
      return new (t || _MatStepper)(ɵɵdirectiveInject(Directionality, 8), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _MatStepper,
      selectors: [["mat-stepper"], ["mat-vertical-stepper"], ["mat-horizontal-stepper"], ["", "matStepper", ""]],
      contentQueries: function MatStepper_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          ɵɵcontentQuery(dirIndex, MatStep, 5);
          ɵɵcontentQuery(dirIndex, MatStepperIcon, 5);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._steps = _t);
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._icons = _t);
        }
      },
      viewQuery: function MatStepper_Query(rf, ctx) {
        if (rf & 1) {
          ɵɵviewQuery(MatStepHeader, 5);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._stepHeader = _t);
        }
      },
      hostAttrs: ["role", "tablist"],
      hostVars: 11,
      hostBindings: function MatStepper_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵattribute("aria-orientation", ctx.orientation);
          ɵɵclassProp("mat-stepper-horizontal", ctx.orientation === "horizontal")("mat-stepper-vertical", ctx.orientation === "vertical")("mat-stepper-label-position-end", ctx.orientation === "horizontal" && ctx.labelPosition == "end")("mat-stepper-label-position-bottom", ctx.orientation === "horizontal" && ctx.labelPosition == "bottom")("mat-stepper-header-position-bottom", ctx.headerPosition === "bottom");
        }
      },
      inputs: {
        disableRipple: "disableRipple",
        color: "color",
        labelPosition: "labelPosition",
        headerPosition: "headerPosition",
        animationDuration: "animationDuration"
      },
      outputs: {
        animationDone: "animationDone"
      },
      exportAs: ["matStepper", "matVerticalStepper", "matHorizontalStepper"],
      standalone: true,
      features: [ɵɵProvidersFeature([{
        provide: CdkStepper,
        useExisting: _MatStepper
      }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
      ngContentSelectors: _c05,
      decls: 5,
      vars: 2,
      consts: [["stepTemplate", ""], [1, "mat-horizontal-stepper-wrapper"], [1, "mat-horizontal-stepper-header-container"], [1, "mat-horizontal-content-container"], ["role", "tabpanel", 1, "mat-horizontal-stepper-content", 3, "id", "mat-horizontal-stepper-content-inactive"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "mat-stepper-horizontal-line"], ["role", "tabpanel", 1, "mat-horizontal-stepper-content", 3, "id"], [3, "ngTemplateOutlet"], [1, "mat-step"], [1, "mat-vertical-content-container"], ["role", "tabpanel", 1, "mat-vertical-stepper-content", 3, "id"], [1, "mat-vertical-content"], [3, "click", "keydown", "tabIndex", "id", "index", "state", "label", "selected", "active", "optional", "errorMessage", "iconOverrides", "disableRipple", "color"]],
      template: function MatStepper_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef();
          ɵɵtemplate(0, MatStepper_Conditional_0_Template, 1, 0)(1, MatStepper_Case_1_Template, 7, 0)(2, MatStepper_Case_2_Template, 2, 0)(3, MatStepper_ng_template_3_Template, 1, 23, "ng-template", null, 0, ɵɵtemplateRefExtractor);
        }
        if (rf & 2) {
          let tmp_2_0;
          ɵɵconditional(0, ctx._isServer ? 0 : -1);
          ɵɵadvance();
          ɵɵconditional(1, (tmp_2_0 = ctx.orientation) === "horizontal" ? 1 : tmp_2_0 === "vertical" ? 2 : -1);
        }
      },
      dependencies: [NgTemplateOutlet, MatStepHeader],
      styles: ['.mat-stepper-vertical,.mat-stepper-horizontal{display:block;font-family:var(--mat-stepper-container-text-font);background:var(--mat-stepper-container-color)}.mat-horizontal-stepper-header-container{white-space:nowrap;display:flex;align-items:center}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header-container{align-items:flex-start}.mat-stepper-header-position-bottom .mat-horizontal-stepper-header-container{order:1}.mat-stepper-horizontal-line{border-top-width:1px;border-top-style:solid;flex:auto;height:0;margin:0 -16px;min-width:32px;border-top-color:var(--mat-stepper-line-color)}.mat-stepper-label-position-bottom .mat-stepper-horizontal-line{margin:0;min-width:0;position:relative;top:calc(calc((var(--mat-stepper-header-height) - 24px) / 2) + 12px)}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::before,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::before,.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::after{border-top-width:1px;border-top-style:solid;content:"";display:inline-block;height:0;position:absolute;width:calc(50% - 20px)}.mat-horizontal-stepper-header{display:flex;height:72px;overflow:hidden;align-items:center;padding:0 24px;height:var(--mat-stepper-header-height)}.mat-horizontal-stepper-header .mat-step-icon{margin-right:8px;flex:none}[dir=rtl] .mat-horizontal-stepper-header .mat-step-icon{margin-right:0;margin-left:8px}.mat-horizontal-stepper-header::before,.mat-horizontal-stepper-header::after{border-top-color:var(--mat-stepper-line-color)}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header{padding:calc((var(--mat-stepper-header-height) - 24px) / 2) 24px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header::before,.mat-stepper-label-position-bottom .mat-horizontal-stepper-header::after{top:calc(calc((var(--mat-stepper-header-height) - 24px) / 2) + 12px)}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header{box-sizing:border-box;flex-direction:column;height:auto}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::after{right:0}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::before,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::before{left:0}[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:last-child::before,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:first-child::after{display:none}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header .mat-step-icon{margin-right:0;margin-left:0}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header .mat-step-label{padding:16px 0 0 0;text-align:center;width:100%}.mat-vertical-stepper-header{display:flex;align-items:center;height:24px;padding:calc((var(--mat-stepper-header-height) - 24px) / 2) 24px}.mat-vertical-stepper-header .mat-step-icon{margin-right:12px}[dir=rtl] .mat-vertical-stepper-header .mat-step-icon{margin-right:0;margin-left:12px}.mat-horizontal-stepper-wrapper{display:flex;flex-direction:column}.mat-horizontal-stepper-content{outline:0}.mat-horizontal-stepper-content.mat-horizontal-stepper-content-inactive{height:0;overflow:hidden}.mat-horizontal-stepper-content:not(.mat-horizontal-stepper-content-inactive){visibility:inherit !important}.mat-horizontal-content-container{overflow:hidden;padding:0 24px 24px 24px}.cdk-high-contrast-active .mat-horizontal-content-container{outline:solid 1px}.mat-stepper-header-position-bottom .mat-horizontal-content-container{padding:24px 24px 0 24px}.mat-vertical-content-container{margin-left:36px;border:0;position:relative}.cdk-high-contrast-active .mat-vertical-content-container{outline:solid 1px}[dir=rtl] .mat-vertical-content-container{margin-left:0;margin-right:36px}.mat-stepper-vertical-line::before{content:"";position:absolute;left:0;border-left-width:1px;border-left-style:solid;border-left-color:var(--mat-stepper-line-color);top:calc(8px - calc((var(--mat-stepper-header-height) - 24px) / 2));bottom:calc(8px - calc((var(--mat-stepper-header-height) - 24px) / 2))}[dir=rtl] .mat-stepper-vertical-line::before{left:auto;right:0}.mat-vertical-stepper-content{overflow:hidden;outline:0}.mat-vertical-stepper-content:not(.mat-vertical-stepper-content-inactive){visibility:inherit !important}.mat-vertical-content{padding:0 24px 24px 24px}.mat-step:last-child .mat-vertical-content-container{border:none}'],
      encapsulation: 2,
      data: {
        animation: [matStepperAnimations.horizontalStepTransition, matStepperAnimations.verticalStepTransition]
      },
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatStepper, [{
    type: Component,
    args: [{
      selector: "mat-stepper, mat-vertical-stepper, mat-horizontal-stepper, [matStepper]",
      exportAs: "matStepper, matVerticalStepper, matHorizontalStepper",
      host: {
        "[class.mat-stepper-horizontal]": 'orientation === "horizontal"',
        "[class.mat-stepper-vertical]": 'orientation === "vertical"',
        "[class.mat-stepper-label-position-end]": 'orientation === "horizontal" && labelPosition == "end"',
        "[class.mat-stepper-label-position-bottom]": 'orientation === "horizontal" && labelPosition == "bottom"',
        "[class.mat-stepper-header-position-bottom]": 'headerPosition === "bottom"',
        "[attr.aria-orientation]": "orientation",
        "role": "tablist"
      },
      animations: [matStepperAnimations.horizontalStepTransition, matStepperAnimations.verticalStepTransition],
      providers: [{
        provide: CdkStepper,
        useExisting: MatStepper
      }],
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: true,
      imports: [NgTemplateOutlet, MatStepHeader],
      template: `<!--
  We need to project the content somewhere to avoid hydration errors. Some observations:
  1. This is only necessary on the server.
  2. We get a hydration error if there aren't any nodes after the \`ng-content\`.
  3. We get a hydration error if \`ng-content\` is wrapped in another element.
-->
@if (_isServer) {
  <ng-content/>
}

@switch (orientation) {
  @case ('horizontal') {
    <div class="mat-horizontal-stepper-wrapper">
      <div class="mat-horizontal-stepper-header-container">
        @for (step of steps; track step; let i = $index, isLast = $last) {
          <ng-container
            [ngTemplateOutlet]="stepTemplate"
            [ngTemplateOutletContext]="{step: step, i: i}"></ng-container>
          @if (!isLast) {
            <div class="mat-stepper-horizontal-line"></div>
          }
        }
      </div>

      <div class="mat-horizontal-content-container">
        @for (step of steps; track step; let i = $index) {
          <div class="mat-horizontal-stepper-content" role="tabpanel"
               [@horizontalStepTransition]="{
                  'value': _getAnimationDirection(i),
                  'params': {'animationDuration': _getAnimationDuration()}
                }"
               (@horizontalStepTransition.done)="_animationDone.next($event)"
               [id]="_getStepContentId(i)"
               [attr.aria-labelledby]="_getStepLabelId(i)"
               [class.mat-horizontal-stepper-content-inactive]="selectedIndex !== i">
            <ng-container [ngTemplateOutlet]="step.content"></ng-container>
          </div>
        }
      </div>
    </div>
  }

  @case ('vertical') {
    @for (step of steps; track step; let i = $index, isLast = $last) {
      <div class="mat-step">
        <ng-container
          [ngTemplateOutlet]="stepTemplate"
          [ngTemplateOutletContext]="{step: step, i: i}"></ng-container>
        <div class="mat-vertical-content-container" [class.mat-stepper-vertical-line]="!isLast">
          <div class="mat-vertical-stepper-content" role="tabpanel"
               [@verticalStepTransition]="{
                  'value': _getAnimationDirection(i),
                  'params': {'animationDuration': _getAnimationDuration()}
                }"
               (@verticalStepTransition.done)="_animationDone.next($event)"
               [id]="_getStepContentId(i)"
               [attr.aria-labelledby]="_getStepLabelId(i)"
               [class.mat-vertical-stepper-content-inactive]="selectedIndex !== i">
            <div class="mat-vertical-content">
              <ng-container [ngTemplateOutlet]="step.content"></ng-container>
            </div>
          </div>
        </div>
      </div>
    }
  }
}

<!-- Common step templating -->
<ng-template let-step="step" let-i="i" #stepTemplate>
  <mat-step-header
    [class.mat-horizontal-stepper-header]="orientation === 'horizontal'"
    [class.mat-vertical-stepper-header]="orientation === 'vertical'"
    (click)="step.select()"
    (keydown)="_onKeydown($event)"
    [tabIndex]="_getFocusIndex() === i ? 0 : -1"
    [id]="_getStepLabelId(i)"
    [attr.aria-posinset]="i + 1"
    [attr.aria-setsize]="steps.length"
    [attr.aria-controls]="_getStepContentId(i)"
    [attr.aria-selected]="selectedIndex == i"
    [attr.aria-label]="step.ariaLabel || null"
    [attr.aria-labelledby]="(!step.ariaLabel && step.ariaLabelledby) ? step.ariaLabelledby : null"
    [attr.aria-disabled]="_stepIsNavigable(i, step) ? null : true"
    [index]="i"
    [state]="_getIndicatorType(i, step.state)"
    [label]="step.stepLabel || step.label"
    [selected]="selectedIndex === i"
    [active]="_stepIsNavigable(i, step)"
    [optional]="step.optional"
    [errorMessage]="step.errorMessage"
    [iconOverrides]="_iconOverrides"
    [disableRipple]="disableRipple || !_stepIsNavigable(i, step)"
    [color]="step.color || color"></mat-step-header>
</ng-template>
`,
      styles: ['.mat-stepper-vertical,.mat-stepper-horizontal{display:block;font-family:var(--mat-stepper-container-text-font);background:var(--mat-stepper-container-color)}.mat-horizontal-stepper-header-container{white-space:nowrap;display:flex;align-items:center}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header-container{align-items:flex-start}.mat-stepper-header-position-bottom .mat-horizontal-stepper-header-container{order:1}.mat-stepper-horizontal-line{border-top-width:1px;border-top-style:solid;flex:auto;height:0;margin:0 -16px;min-width:32px;border-top-color:var(--mat-stepper-line-color)}.mat-stepper-label-position-bottom .mat-stepper-horizontal-line{margin:0;min-width:0;position:relative;top:calc(calc((var(--mat-stepper-header-height) - 24px) / 2) + 12px)}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::before,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::before,.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::after{border-top-width:1px;border-top-style:solid;content:"";display:inline-block;height:0;position:absolute;width:calc(50% - 20px)}.mat-horizontal-stepper-header{display:flex;height:72px;overflow:hidden;align-items:center;padding:0 24px;height:var(--mat-stepper-header-height)}.mat-horizontal-stepper-header .mat-step-icon{margin-right:8px;flex:none}[dir=rtl] .mat-horizontal-stepper-header .mat-step-icon{margin-right:0;margin-left:8px}.mat-horizontal-stepper-header::before,.mat-horizontal-stepper-header::after{border-top-color:var(--mat-stepper-line-color)}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header{padding:calc((var(--mat-stepper-header-height) - 24px) / 2) 24px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header::before,.mat-stepper-label-position-bottom .mat-horizontal-stepper-header::after{top:calc(calc((var(--mat-stepper-header-height) - 24px) / 2) + 12px)}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header{box-sizing:border-box;flex-direction:column;height:auto}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::after{right:0}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::before,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::before{left:0}[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:last-child::before,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:first-child::after{display:none}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header .mat-step-icon{margin-right:0;margin-left:0}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header .mat-step-label{padding:16px 0 0 0;text-align:center;width:100%}.mat-vertical-stepper-header{display:flex;align-items:center;height:24px;padding:calc((var(--mat-stepper-header-height) - 24px) / 2) 24px}.mat-vertical-stepper-header .mat-step-icon{margin-right:12px}[dir=rtl] .mat-vertical-stepper-header .mat-step-icon{margin-right:0;margin-left:12px}.mat-horizontal-stepper-wrapper{display:flex;flex-direction:column}.mat-horizontal-stepper-content{outline:0}.mat-horizontal-stepper-content.mat-horizontal-stepper-content-inactive{height:0;overflow:hidden}.mat-horizontal-stepper-content:not(.mat-horizontal-stepper-content-inactive){visibility:inherit !important}.mat-horizontal-content-container{overflow:hidden;padding:0 24px 24px 24px}.cdk-high-contrast-active .mat-horizontal-content-container{outline:solid 1px}.mat-stepper-header-position-bottom .mat-horizontal-content-container{padding:24px 24px 0 24px}.mat-vertical-content-container{margin-left:36px;border:0;position:relative}.cdk-high-contrast-active .mat-vertical-content-container{outline:solid 1px}[dir=rtl] .mat-vertical-content-container{margin-left:0;margin-right:36px}.mat-stepper-vertical-line::before{content:"";position:absolute;left:0;border-left-width:1px;border-left-style:solid;border-left-color:var(--mat-stepper-line-color);top:calc(8px - calc((var(--mat-stepper-header-height) - 24px) / 2));bottom:calc(8px - calc((var(--mat-stepper-header-height) - 24px) / 2))}[dir=rtl] .mat-stepper-vertical-line::before{left:auto;right:0}.mat-vertical-stepper-content{overflow:hidden;outline:0}.mat-vertical-stepper-content:not(.mat-vertical-stepper-content-inactive){visibility:inherit !important}.mat-vertical-content{padding:0 24px 24px 24px}.mat-step:last-child .mat-vertical-content-container{border:none}']
    }]
  }], () => [{
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }, {
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }], {
    _stepHeader: [{
      type: ViewChildren,
      args: [MatStepHeader]
    }],
    _steps: [{
      type: ContentChildren,
      args: [MatStep, {
        descendants: true
      }]
    }],
    _icons: [{
      type: ContentChildren,
      args: [MatStepperIcon, {
        descendants: true
      }]
    }],
    animationDone: [{
      type: Output
    }],
    disableRipple: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    labelPosition: [{
      type: Input
    }],
    headerPosition: [{
      type: Input
    }],
    animationDuration: [{
      type: Input
    }]
  });
})();
var MatStepperNext = class _MatStepperNext extends CdkStepperNext {
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵMatStepperNext_BaseFactory;
      return function MatStepperNext_Factory(t) {
        return (ɵMatStepperNext_BaseFactory || (ɵMatStepperNext_BaseFactory = ɵɵgetInheritedFactory(_MatStepperNext)))(t || _MatStepperNext);
      };
    })();
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _MatStepperNext,
      selectors: [["button", "matStepperNext", ""]],
      hostAttrs: [1, "mat-stepper-next"],
      hostVars: 1,
      hostBindings: function MatStepperNext_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵhostProperty("type", ctx.type);
        }
      },
      standalone: true,
      features: [ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatStepperNext, [{
    type: Directive,
    args: [{
      selector: "button[matStepperNext]",
      host: {
        "class": "mat-stepper-next",
        "[type]": "type"
      },
      standalone: true
    }]
  }], null, null);
})();
var MatStepperPrevious = class _MatStepperPrevious extends CdkStepperPrevious {
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵMatStepperPrevious_BaseFactory;
      return function MatStepperPrevious_Factory(t) {
        return (ɵMatStepperPrevious_BaseFactory || (ɵMatStepperPrevious_BaseFactory = ɵɵgetInheritedFactory(_MatStepperPrevious)))(t || _MatStepperPrevious);
      };
    })();
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _MatStepperPrevious,
      selectors: [["button", "matStepperPrevious", ""]],
      hostAttrs: [1, "mat-stepper-previous"],
      hostVars: 1,
      hostBindings: function MatStepperPrevious_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵhostProperty("type", ctx.type);
        }
      },
      standalone: true,
      features: [ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatStepperPrevious, [{
    type: Directive,
    args: [{
      selector: "button[matStepperPrevious]",
      host: {
        "class": "mat-stepper-previous",
        "[type]": "type"
      },
      standalone: true
    }]
  }], null, null);
})();
var MatStepperModule = class _MatStepperModule {
  static {
    this.ɵfac = function MatStepperModule_Factory(t) {
      return new (t || _MatStepperModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _MatStepperModule,
      imports: [MatCommonModule, CommonModule, PortalModule, CdkStepperModule, MatIconModule, MatRippleModule, MatStep, MatStepLabel, MatStepper, MatStepperNext, MatStepperPrevious, MatStepHeader, MatStepperIcon, MatStepContent],
      exports: [MatCommonModule, MatStep, MatStepLabel, MatStepper, MatStepperNext, MatStepperPrevious, MatStepHeader, MatStepperIcon, MatStepContent]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      providers: [MAT_STEPPER_INTL_PROVIDER, ErrorStateMatcher],
      imports: [MatCommonModule, CommonModule, PortalModule, CdkStepperModule, MatIconModule, MatRippleModule, MatStepper, MatStepHeader, MatCommonModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatStepperModule, [{
    type: NgModule,
    args: [{
      imports: [MatCommonModule, CommonModule, PortalModule, CdkStepperModule, MatIconModule, MatRippleModule, MatStep, MatStepLabel, MatStepper, MatStepperNext, MatStepperPrevious, MatStepHeader, MatStepperIcon, MatStepContent],
      exports: [MatCommonModule, MatStep, MatStepLabel, MatStepper, MatStepperNext, MatStepperPrevious, MatStepHeader, MatStepperIcon, MatStepContent],
      providers: [MAT_STEPPER_INTL_PROVIDER, ErrorStateMatcher]
    }]
  }], null, null);
})();

// node_modules/@angular/material/fesm2022/button-toggle.mjs
var _c06 = ["button"];
var _c112 = ["*"];
function MatButtonToggle_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "mat-pseudo-checkbox", 3);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("disabled", ctx_r1.disabled);
  }
}
function MatButtonToggle_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "mat-pseudo-checkbox", 3);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("disabled", ctx_r1.disabled);
  }
}
var MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS = new InjectionToken("MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS", {
  providedIn: "root",
  factory: MAT_BUTTON_TOGGLE_GROUP_DEFAULT_OPTIONS_FACTORY
});
function MAT_BUTTON_TOGGLE_GROUP_DEFAULT_OPTIONS_FACTORY() {
  return {
    hideSingleSelectionIndicator: false,
    hideMultipleSelectionIndicator: false
  };
}
var MAT_BUTTON_TOGGLE_GROUP = new InjectionToken("MatButtonToggleGroup");
var MAT_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => MatButtonToggleGroup),
  multi: true
};
var uniqueIdCounter = 0;
var MatButtonToggleChange = class {
  constructor(source, value) {
    this.source = source;
    this.value = value;
  }
};
var MatButtonToggleGroup = class _MatButtonToggleGroup {
  /** `name` attribute for the underlying `input` element. */
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
    this._markButtonsForCheck();
  }
  /** Value of the toggle group. */
  get value() {
    const selected = this._selectionModel ? this._selectionModel.selected : [];
    if (this.multiple) {
      return selected.map((toggle) => toggle.value);
    }
    return selected[0] ? selected[0].value : void 0;
  }
  set value(newValue) {
    this._setSelectionByValue(newValue);
    this.valueChange.emit(this.value);
  }
  /** Selected button toggles in the group. */
  get selected() {
    const selected = this._selectionModel ? this._selectionModel.selected : [];
    return this.multiple ? selected : selected[0] || null;
  }
  /** Whether multiple button toggles can be selected. */
  get multiple() {
    return this._multiple;
  }
  set multiple(value) {
    this._multiple = value;
    this._markButtonsForCheck();
  }
  /** Whether multiple button toggle group is disabled. */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
    this._markButtonsForCheck();
  }
  /** Whether checkmark indicator for single-selection button toggle groups is hidden. */
  get hideSingleSelectionIndicator() {
    return this._hideSingleSelectionIndicator;
  }
  set hideSingleSelectionIndicator(value) {
    this._hideSingleSelectionIndicator = value;
    this._markButtonsForCheck();
  }
  /** Whether checkmark indicator for multiple-selection button toggle groups is hidden. */
  get hideMultipleSelectionIndicator() {
    return this._hideMultipleSelectionIndicator;
  }
  set hideMultipleSelectionIndicator(value) {
    this._hideMultipleSelectionIndicator = value;
    this._markButtonsForCheck();
  }
  constructor(_changeDetector, defaultOptions2) {
    this._changeDetector = _changeDetector;
    this._multiple = false;
    this._disabled = false;
    this._controlValueAccessorChangeFn = () => {
    };
    this._onTouched = () => {
    };
    this._name = `mat-button-toggle-group-${uniqueIdCounter++}`;
    this.valueChange = new EventEmitter();
    this.change = new EventEmitter();
    this.appearance = defaultOptions2 && defaultOptions2.appearance ? defaultOptions2.appearance : "standard";
    this.hideSingleSelectionIndicator = defaultOptions2?.hideSingleSelectionIndicator ?? false;
    this.hideMultipleSelectionIndicator = defaultOptions2?.hideMultipleSelectionIndicator ?? false;
  }
  ngOnInit() {
    this._selectionModel = new SelectionModel(this.multiple, void 0, false);
  }
  ngAfterContentInit() {
    this._selectionModel.select(...this._buttonToggles.filter((toggle) => toggle.checked));
  }
  /**
   * Sets the model value. Implemented as part of ControlValueAccessor.
   * @param value Value to be set to the model.
   */
  writeValue(value) {
    this.value = value;
    this._changeDetector.markForCheck();
  }
  // Implemented as part of ControlValueAccessor.
  registerOnChange(fn) {
    this._controlValueAccessorChangeFn = fn;
  }
  // Implemented as part of ControlValueAccessor.
  registerOnTouched(fn) {
    this._onTouched = fn;
  }
  // Implemented as part of ControlValueAccessor.
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  /** Dispatch change event with current selection and group value. */
  _emitChangeEvent(toggle) {
    const event = new MatButtonToggleChange(toggle, this.value);
    this._rawValue = event.value;
    this._controlValueAccessorChangeFn(event.value);
    this.change.emit(event);
  }
  /**
   * Syncs a button toggle's selected state with the model value.
   * @param toggle Toggle to be synced.
   * @param select Whether the toggle should be selected.
   * @param isUserInput Whether the change was a result of a user interaction.
   * @param deferEvents Whether to defer emitting the change events.
   */
  _syncButtonToggle(toggle, select, isUserInput = false, deferEvents = false) {
    if (!this.multiple && this.selected && !toggle.checked) {
      this.selected.checked = false;
    }
    if (this._selectionModel) {
      if (select) {
        this._selectionModel.select(toggle);
      } else {
        this._selectionModel.deselect(toggle);
      }
    } else {
      deferEvents = true;
    }
    if (deferEvents) {
      Promise.resolve().then(() => this._updateModelValue(toggle, isUserInput));
    } else {
      this._updateModelValue(toggle, isUserInput);
    }
  }
  /** Checks whether a button toggle is selected. */
  _isSelected(toggle) {
    return this._selectionModel && this._selectionModel.isSelected(toggle);
  }
  /** Determines whether a button toggle should be checked on init. */
  _isPrechecked(toggle) {
    if (typeof this._rawValue === "undefined") {
      return false;
    }
    if (this.multiple && Array.isArray(this._rawValue)) {
      return this._rawValue.some((value) => toggle.value != null && value === toggle.value);
    }
    return toggle.value === this._rawValue;
  }
  /** Updates the selection state of the toggles in the group based on a value. */
  _setSelectionByValue(value) {
    this._rawValue = value;
    if (!this._buttonToggles) {
      return;
    }
    if (this.multiple && value) {
      if (!Array.isArray(value) && (typeof ngDevMode === "undefined" || ngDevMode)) {
        throw Error("Value must be an array in multiple-selection mode.");
      }
      this._clearSelection();
      value.forEach((currentValue) => this._selectValue(currentValue));
    } else {
      this._clearSelection();
      this._selectValue(value);
    }
  }
  /** Clears the selected toggles. */
  _clearSelection() {
    this._selectionModel.clear();
    this._buttonToggles.forEach((toggle) => toggle.checked = false);
  }
  /** Selects a value if there's a toggle that corresponds to it. */
  _selectValue(value) {
    const correspondingOption = this._buttonToggles.find((toggle) => {
      return toggle.value != null && toggle.value === value;
    });
    if (correspondingOption) {
      correspondingOption.checked = true;
      this._selectionModel.select(correspondingOption);
    }
  }
  /** Syncs up the group's value with the model and emits the change event. */
  _updateModelValue(toggle, isUserInput) {
    if (isUserInput) {
      this._emitChangeEvent(toggle);
    }
    this.valueChange.emit(this.value);
  }
  /** Marks all of the child button toggles to be checked. */
  _markButtonsForCheck() {
    this._buttonToggles?.forEach((toggle) => toggle._markForCheck());
  }
  static {
    this.ɵfac = function MatButtonToggleGroup_Factory(t) {
      return new (t || _MatButtonToggleGroup)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS, 8));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _MatButtonToggleGroup,
      selectors: [["mat-button-toggle-group"]],
      contentQueries: function MatButtonToggleGroup_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          ɵɵcontentQuery(dirIndex, MatButtonToggle, 5);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._buttonToggles = _t);
        }
      },
      hostAttrs: ["role", "group", 1, "mat-button-toggle-group"],
      hostVars: 5,
      hostBindings: function MatButtonToggleGroup_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵattribute("aria-disabled", ctx.disabled);
          ɵɵclassProp("mat-button-toggle-vertical", ctx.vertical)("mat-button-toggle-group-appearance-standard", ctx.appearance === "standard");
        }
      },
      inputs: {
        appearance: "appearance",
        name: "name",
        vertical: [InputFlags.HasDecoratorInputTransform, "vertical", "vertical", booleanAttribute],
        value: "value",
        multiple: [InputFlags.HasDecoratorInputTransform, "multiple", "multiple", booleanAttribute],
        disabled: [InputFlags.HasDecoratorInputTransform, "disabled", "disabled", booleanAttribute],
        hideSingleSelectionIndicator: [InputFlags.HasDecoratorInputTransform, "hideSingleSelectionIndicator", "hideSingleSelectionIndicator", booleanAttribute],
        hideMultipleSelectionIndicator: [InputFlags.HasDecoratorInputTransform, "hideMultipleSelectionIndicator", "hideMultipleSelectionIndicator", booleanAttribute]
      },
      outputs: {
        valueChange: "valueChange",
        change: "change"
      },
      exportAs: ["matButtonToggleGroup"],
      standalone: true,
      features: [ɵɵProvidersFeature([MAT_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR, {
        provide: MAT_BUTTON_TOGGLE_GROUP,
        useExisting: _MatButtonToggleGroup
      }]), ɵɵInputTransformsFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatButtonToggleGroup, [{
    type: Directive,
    args: [{
      selector: "mat-button-toggle-group",
      providers: [MAT_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR, {
        provide: MAT_BUTTON_TOGGLE_GROUP,
        useExisting: MatButtonToggleGroup
      }],
      host: {
        "role": "group",
        "class": "mat-button-toggle-group",
        "[attr.aria-disabled]": "disabled",
        "[class.mat-button-toggle-vertical]": "vertical",
        "[class.mat-button-toggle-group-appearance-standard]": 'appearance === "standard"'
      },
      exportAs: "matButtonToggleGroup",
      standalone: true
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS]
    }]
  }], {
    _buttonToggles: [{
      type: ContentChildren,
      args: [forwardRef(() => MatButtonToggle), {
        // Note that this would technically pick up toggles
        // from nested groups, but that's not a case that we support.
        descendants: true
      }]
    }],
    appearance: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    vertical: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    value: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    multiple: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    disabled: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    change: [{
      type: Output
    }],
    hideSingleSelectionIndicator: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    hideMultipleSelectionIndicator: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }]
  });
})();
var MatButtonToggle = class _MatButtonToggle {
  /** Unique ID for the underlying `button` element. */
  get buttonId() {
    return `${this.id}-button`;
  }
  /** The appearance style of the button. */
  get appearance() {
    return this.buttonToggleGroup ? this.buttonToggleGroup.appearance : this._appearance;
  }
  set appearance(value) {
    this._appearance = value;
  }
  /** Whether the button is checked. */
  get checked() {
    return this.buttonToggleGroup ? this.buttonToggleGroup._isSelected(this) : this._checked;
  }
  set checked(value) {
    if (value !== this._checked) {
      this._checked = value;
      if (this.buttonToggleGroup) {
        this.buttonToggleGroup._syncButtonToggle(this, this._checked);
      }
      this._changeDetectorRef.markForCheck();
    }
  }
  /** Whether the button is disabled. */
  get disabled() {
    return this._disabled || this.buttonToggleGroup && this.buttonToggleGroup.disabled;
  }
  set disabled(value) {
    this._disabled = value;
  }
  constructor(toggleGroup, _changeDetectorRef, _elementRef, _focusMonitor, defaultTabIndex, defaultOptions2) {
    this._changeDetectorRef = _changeDetectorRef;
    this._elementRef = _elementRef;
    this._focusMonitor = _focusMonitor;
    this._checked = false;
    this.ariaLabelledby = null;
    this._disabled = false;
    this.change = new EventEmitter();
    const parsedTabIndex = Number(defaultTabIndex);
    this.tabIndex = parsedTabIndex || parsedTabIndex === 0 ? parsedTabIndex : null;
    this.buttonToggleGroup = toggleGroup;
    this.appearance = defaultOptions2 && defaultOptions2.appearance ? defaultOptions2.appearance : "standard";
  }
  ngOnInit() {
    const group2 = this.buttonToggleGroup;
    this.id = this.id || `mat-button-toggle-${uniqueIdCounter++}`;
    if (group2) {
      if (group2._isPrechecked(this)) {
        this.checked = true;
      } else if (group2._isSelected(this) !== this._checked) {
        group2._syncButtonToggle(this, this._checked);
      }
    }
  }
  ngAfterViewInit() {
    this._focusMonitor.monitor(this._elementRef, true);
  }
  ngOnDestroy() {
    const group2 = this.buttonToggleGroup;
    this._focusMonitor.stopMonitoring(this._elementRef);
    if (group2 && group2._isSelected(this)) {
      group2._syncButtonToggle(this, false, false, true);
    }
  }
  /** Focuses the button. */
  focus(options) {
    this._buttonElement.nativeElement.focus(options);
  }
  /** Checks the button toggle due to an interaction with the underlying native button. */
  _onButtonClick() {
    const newChecked = this._isSingleSelector() ? true : !this._checked;
    if (newChecked !== this._checked) {
      this._checked = newChecked;
      if (this.buttonToggleGroup) {
        this.buttonToggleGroup._syncButtonToggle(this, this._checked, true);
        this.buttonToggleGroup._onTouched();
      }
    }
    this.change.emit(new MatButtonToggleChange(this, this.value));
  }
  /**
   * Marks the button toggle as needing checking for change detection.
   * This method is exposed because the parent button toggle group will directly
   * update bound properties of the radio button.
   */
  _markForCheck() {
    this._changeDetectorRef.markForCheck();
  }
  /** Gets the name that should be assigned to the inner DOM node. */
  _getButtonName() {
    if (this._isSingleSelector()) {
      return this.buttonToggleGroup.name;
    }
    return this.name || null;
  }
  /** Whether the toggle is in single selection mode. */
  _isSingleSelector() {
    return this.buttonToggleGroup && !this.buttonToggleGroup.multiple;
  }
  static {
    this.ɵfac = function MatButtonToggle_Factory(t) {
      return new (t || _MatButtonToggle)(ɵɵdirectiveInject(MAT_BUTTON_TOGGLE_GROUP, 8), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(FocusMonitor), ɵɵinjectAttribute("tabindex"), ɵɵdirectiveInject(MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS, 8));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _MatButtonToggle,
      selectors: [["mat-button-toggle"]],
      viewQuery: function MatButtonToggle_Query(rf, ctx) {
        if (rf & 1) {
          ɵɵviewQuery(_c06, 5);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._buttonElement = _t.first);
        }
      },
      hostAttrs: ["role", "presentation", 1, "mat-button-toggle"],
      hostVars: 12,
      hostBindings: function MatButtonToggle_HostBindings(rf, ctx) {
        if (rf & 1) {
          ɵɵlistener("focus", function MatButtonToggle_focus_HostBindingHandler() {
            return ctx.focus();
          });
        }
        if (rf & 2) {
          ɵɵattribute("aria-label", null)("aria-labelledby", null)("id", ctx.id)("name", null);
          ɵɵclassProp("mat-button-toggle-standalone", !ctx.buttonToggleGroup)("mat-button-toggle-checked", ctx.checked)("mat-button-toggle-disabled", ctx.disabled)("mat-button-toggle-appearance-standard", ctx.appearance === "standard");
        }
      },
      inputs: {
        ariaLabel: [InputFlags.None, "aria-label", "ariaLabel"],
        ariaLabelledby: [InputFlags.None, "aria-labelledby", "ariaLabelledby"],
        id: "id",
        name: "name",
        value: "value",
        tabIndex: "tabIndex",
        disableRipple: [InputFlags.HasDecoratorInputTransform, "disableRipple", "disableRipple", booleanAttribute],
        appearance: "appearance",
        checked: [InputFlags.HasDecoratorInputTransform, "checked", "checked", booleanAttribute],
        disabled: [InputFlags.HasDecoratorInputTransform, "disabled", "disabled", booleanAttribute]
      },
      outputs: {
        change: "change"
      },
      exportAs: ["matButtonToggle"],
      standalone: true,
      features: [ɵɵInputTransformsFeature, ɵɵStandaloneFeature],
      ngContentSelectors: _c112,
      decls: 8,
      vars: 11,
      consts: [["button", ""], ["type", "button", 1, "mat-button-toggle-button", "mat-focus-indicator", 3, "click", "id", "disabled"], [1, "mat-button-toggle-label-content"], ["state", "checked", "aria-hidden", "true", "appearance", "minimal", 1, "mat-mdc-option-pseudo-checkbox", 3, "disabled"], [1, "mat-button-toggle-focus-overlay"], ["matRipple", "", 1, "mat-button-toggle-ripple", 3, "matRippleTrigger", "matRippleDisabled"]],
      template: function MatButtonToggle_Template(rf, ctx) {
        if (rf & 1) {
          const _r1 = ɵɵgetCurrentView();
          ɵɵprojectionDef();
          ɵɵelementStart(0, "button", 1, 0);
          ɵɵlistener("click", function MatButtonToggle_Template_button_click_0_listener() {
            ɵɵrestoreView(_r1);
            return ɵɵresetView(ctx._onButtonClick());
          });
          ɵɵelementStart(2, "span", 2);
          ɵɵtemplate(3, MatButtonToggle_Conditional_3_Template, 1, 1, "mat-pseudo-checkbox", 3)(4, MatButtonToggle_Conditional_4_Template, 1, 1, "mat-pseudo-checkbox", 3);
          ɵɵprojection(5);
          ɵɵelementEnd()();
          ɵɵelement(6, "span", 4)(7, "span", 5);
        }
        if (rf & 2) {
          const button_r3 = ɵɵreference(1);
          ɵɵproperty("id", ctx.buttonId)("disabled", ctx.disabled || null);
          ɵɵattribute("tabindex", ctx.disabled ? -1 : ctx.tabIndex)("aria-pressed", ctx.checked)("name", ctx._getButtonName())("aria-label", ctx.ariaLabel)("aria-labelledby", ctx.ariaLabelledby);
          ɵɵadvance(3);
          ɵɵconditional(3, ctx.buttonToggleGroup && ctx.checked && !ctx.buttonToggleGroup.multiple && !ctx.buttonToggleGroup.hideSingleSelectionIndicator ? 3 : -1);
          ɵɵadvance();
          ɵɵconditional(4, ctx.buttonToggleGroup && ctx.checked && ctx.buttonToggleGroup.multiple && !ctx.buttonToggleGroup.hideMultipleSelectionIndicator ? 4 : -1);
          ɵɵadvance(3);
          ɵɵproperty("matRippleTrigger", button_r3)("matRippleDisabled", ctx.disableRipple || ctx.disabled);
        }
      },
      dependencies: [MatRipple, MatPseudoCheckbox],
      styles: [".mat-button-toggle-standalone,.mat-button-toggle-group{position:relative;display:inline-flex;flex-direction:row;white-space:nowrap;overflow:hidden;-webkit-tap-highlight-color:rgba(0,0,0,0);transform:translateZ(0);border-radius:var(--mat-legacy-button-toggle-shape)}.mat-button-toggle-standalone:not([class*=mat-elevation-z]),.mat-button-toggle-group:not([class*=mat-elevation-z]){box-shadow:0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12)}.cdk-high-contrast-active .mat-button-toggle-standalone,.cdk-high-contrast-active .mat-button-toggle-group{outline:solid 1px}.mat-button-toggle-standalone.mat-button-toggle-appearance-standard,.mat-button-toggle-group-appearance-standard{border-radius:var(--mat-standard-button-toggle-shape);border:solid 1px var(--mat-standard-button-toggle-divider-color)}.mat-button-toggle-standalone.mat-button-toggle-appearance-standard .mat-pseudo-checkbox,.mat-button-toggle-group-appearance-standard .mat-pseudo-checkbox{--mat-minimal-pseudo-checkbox-selected-checkmark-color: var( --mat-standard-button-toggle-selected-state-text-color )}.mat-button-toggle-standalone.mat-button-toggle-appearance-standard:not([class*=mat-elevation-z]),.mat-button-toggle-group-appearance-standard:not([class*=mat-elevation-z]){box-shadow:none}.cdk-high-contrast-active .mat-button-toggle-standalone.mat-button-toggle-appearance-standard,.cdk-high-contrast-active .mat-button-toggle-group-appearance-standard{outline:0}.mat-button-toggle-vertical{flex-direction:column}.mat-button-toggle-vertical .mat-button-toggle-label-content{display:block}.mat-button-toggle{white-space:nowrap;position:relative;color:var(--mat-legacy-button-toggle-text-color);font-family:var(--mat-legacy-button-toggle-label-text-font);font-size:var(--mat-legacy-button-toggle-label-text-size);line-height:var(--mat-legacy-button-toggle-label-text-line-height);font-weight:var(--mat-legacy-button-toggle-label-text-weight);letter-spacing:var(--mat-legacy-button-toggle-label-text-tracking);--mat-minimal-pseudo-checkbox-selected-checkmark-color: var( --mat-legacy-button-toggle-selected-state-text-color )}.mat-button-toggle.cdk-keyboard-focused .mat-button-toggle-focus-overlay{opacity:var(--mat-legacy-button-toggle-focus-state-layer-opacity)}.mat-button-toggle .mat-icon svg{vertical-align:top}.mat-button-toggle .mat-pseudo-checkbox{margin-right:12px}[dir=rtl] .mat-button-toggle .mat-pseudo-checkbox{margin-right:0;margin-left:12px}.mat-button-toggle-checked{color:var(--mat-legacy-button-toggle-selected-state-text-color);background-color:var(--mat-legacy-button-toggle-selected-state-background-color)}.mat-button-toggle-disabled{color:var(--mat-legacy-button-toggle-disabled-state-text-color);background-color:var(--mat-legacy-button-toggle-disabled-state-background-color);--mat-minimal-pseudo-checkbox-disabled-selected-checkmark-color: var( --mat-legacy-button-toggle-disabled-state-text-color )}.mat-button-toggle-disabled.mat-button-toggle-checked{background-color:var(--mat-legacy-button-toggle-disabled-selected-state-background-color)}.mat-button-toggle-appearance-standard{color:var(--mat-standard-button-toggle-text-color);background-color:var(--mat-standard-button-toggle-background-color);font-family:var(--mat-standard-button-toggle-label-text-font);font-size:var(--mat-standard-button-toggle-label-text-size);line-height:var(--mat-standard-button-toggle-label-text-line-height);font-weight:var(--mat-standard-button-toggle-label-text-weight);letter-spacing:var(--mat-standard-button-toggle-label-text-tracking)}.mat-button-toggle-group-appearance-standard .mat-button-toggle-appearance-standard+.mat-button-toggle-appearance-standard{border-left:solid 1px var(--mat-standard-button-toggle-divider-color)}[dir=rtl] .mat-button-toggle-group-appearance-standard .mat-button-toggle-appearance-standard+.mat-button-toggle-appearance-standard{border-left:none;border-right:solid 1px var(--mat-standard-button-toggle-divider-color)}.mat-button-toggle-group-appearance-standard.mat-button-toggle-vertical .mat-button-toggle-appearance-standard+.mat-button-toggle-appearance-standard{border-left:none;border-right:none;border-top:solid 1px var(--mat-standard-button-toggle-divider-color)}.mat-button-toggle-appearance-standard.mat-button-toggle-checked{color:var(--mat-standard-button-toggle-selected-state-text-color);background-color:var(--mat-standard-button-toggle-selected-state-background-color)}.mat-button-toggle-appearance-standard.mat-button-toggle-disabled{color:var(--mat-standard-button-toggle-disabled-state-text-color);background-color:var(--mat-standard-button-toggle-disabled-state-background-color)}.mat-button-toggle-appearance-standard.mat-button-toggle-disabled .mat-pseudo-checkbox{--mat-minimal-pseudo-checkbox-disabled-selected-checkmark-color: var( --mat-standard-button-toggle-disabled-selected-state-text-color )}.mat-button-toggle-appearance-standard.mat-button-toggle-disabled.mat-button-toggle-checked{color:var(--mat-standard-button-toggle-disabled-selected-state-text-color);background-color:var(--mat-standard-button-toggle-disabled-selected-state-background-color)}.mat-button-toggle-appearance-standard .mat-button-toggle-focus-overlay{background-color:var(--mat-standard-button-toggle-state-layer-color)}.mat-button-toggle-appearance-standard:not(.mat-button-toggle-disabled):hover .mat-button-toggle-focus-overlay{opacity:var(--mat-standard-button-toggle-hover-state-layer-opacity)}.mat-button-toggle-appearance-standard.cdk-keyboard-focused:not(.mat-button-toggle-disabled) .mat-button-toggle-focus-overlay{opacity:var(--mat-standard-button-toggle-focus-state-layer-opacity)}@media(hover: none){.mat-button-toggle-appearance-standard:not(.mat-button-toggle-disabled):hover .mat-button-toggle-focus-overlay{display:none}}.mat-button-toggle-label-content{-webkit-user-select:none;user-select:none;display:inline-block;padding:0 16px;line-height:var(--mat-legacy-button-toggle-height);position:relative}.mat-button-toggle-appearance-standard .mat-button-toggle-label-content{padding:0 12px;line-height:var(--mat-standard-button-toggle-height)}.mat-button-toggle-label-content>*{vertical-align:middle}.mat-button-toggle-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:inherit;pointer-events:none;opacity:0;background-color:var(--mat-legacy-button-toggle-state-layer-color)}.cdk-high-contrast-active .mat-button-toggle-checked .mat-button-toggle-focus-overlay{border-bottom:solid 500px;opacity:.5;height:0}.cdk-high-contrast-active .mat-button-toggle-checked:hover .mat-button-toggle-focus-overlay{opacity:.6}.cdk-high-contrast-active .mat-button-toggle-checked.mat-button-toggle-appearance-standard .mat-button-toggle-focus-overlay{border-bottom:solid 500px}.mat-button-toggle .mat-button-toggle-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-button-toggle-button{border:0;background:none;color:inherit;padding:0;margin:0;font:inherit;outline:none;width:100%;cursor:pointer}.mat-button-toggle-disabled .mat-button-toggle-button{cursor:default}.mat-button-toggle-button::-moz-focus-inner{border:0}.mat-button-toggle-standalone.mat-button-toggle-appearance-standard{--mat-focus-indicator-border-radius:var(--mat-standard-button-toggle-shape)}.mat-button-toggle-group-appearance-standard .mat-button-toggle:last-of-type .mat-button-toggle-button::before{border-top-right-radius:var(--mat-standard-button-toggle-shape);border-bottom-right-radius:var(--mat-standard-button-toggle-shape)}.mat-button-toggle-group-appearance-standard .mat-button-toggle:first-of-type .mat-button-toggle-button::before{border-top-left-radius:var(--mat-standard-button-toggle-shape);border-bottom-left-radius:var(--mat-standard-button-toggle-shape)}"],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatButtonToggle, [{
    type: Component,
    args: [{
      selector: "mat-button-toggle",
      encapsulation: ViewEncapsulation$1.None,
      exportAs: "matButtonToggle",
      changeDetection: ChangeDetectionStrategy.OnPush,
      host: {
        "[class.mat-button-toggle-standalone]": "!buttonToggleGroup",
        "[class.mat-button-toggle-checked]": "checked",
        "[class.mat-button-toggle-disabled]": "disabled",
        "[class.mat-button-toggle-appearance-standard]": 'appearance === "standard"',
        "class": "mat-button-toggle",
        "[attr.aria-label]": "null",
        "[attr.aria-labelledby]": "null",
        "[attr.id]": "id",
        "[attr.name]": "null",
        "(focus)": "focus()",
        "role": "presentation"
      },
      standalone: true,
      imports: [MatRipple, MatPseudoCheckbox],
      template: '<button #button class="mat-button-toggle-button mat-focus-indicator"\n        type="button"\n        [id]="buttonId"\n        [attr.tabindex]="disabled ? -1 : tabIndex"\n        [attr.aria-pressed]="checked"\n        [disabled]="disabled || null"\n        [attr.name]="_getButtonName()"\n        [attr.aria-label]="ariaLabel"\n        [attr.aria-labelledby]="ariaLabelledby"\n        (click)="_onButtonClick()">\n  <span class="mat-button-toggle-label-content">\n    <!-- Render checkmark at the beginning for single-selection. -->\n    @if (buttonToggleGroup && checked && !buttonToggleGroup.multiple && !buttonToggleGroup.hideSingleSelectionIndicator) {\n      <mat-pseudo-checkbox\n          class="mat-mdc-option-pseudo-checkbox"\n          [disabled]="disabled"\n          state="checked"\n          aria-hidden="true"\n          appearance="minimal"></mat-pseudo-checkbox>\n    }\n    <!-- Render checkmark at the beginning for multiple-selection. -->\n    @if (buttonToggleGroup && checked && buttonToggleGroup.multiple && !buttonToggleGroup.hideMultipleSelectionIndicator) {\n      <mat-pseudo-checkbox\n          class="mat-mdc-option-pseudo-checkbox"\n          [disabled]="disabled"\n          state="checked"\n          aria-hidden="true"\n          appearance="minimal"></mat-pseudo-checkbox>\n    }\n    <ng-content></ng-content>\n  </span>\n</button>\n\n<span class="mat-button-toggle-focus-overlay"></span>\n<span class="mat-button-toggle-ripple" matRipple\n     [matRippleTrigger]="button"\n     [matRippleDisabled]="this.disableRipple || this.disabled">\n</span>\n',
      styles: [".mat-button-toggle-standalone,.mat-button-toggle-group{position:relative;display:inline-flex;flex-direction:row;white-space:nowrap;overflow:hidden;-webkit-tap-highlight-color:rgba(0,0,0,0);transform:translateZ(0);border-radius:var(--mat-legacy-button-toggle-shape)}.mat-button-toggle-standalone:not([class*=mat-elevation-z]),.mat-button-toggle-group:not([class*=mat-elevation-z]){box-shadow:0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12)}.cdk-high-contrast-active .mat-button-toggle-standalone,.cdk-high-contrast-active .mat-button-toggle-group{outline:solid 1px}.mat-button-toggle-standalone.mat-button-toggle-appearance-standard,.mat-button-toggle-group-appearance-standard{border-radius:var(--mat-standard-button-toggle-shape);border:solid 1px var(--mat-standard-button-toggle-divider-color)}.mat-button-toggle-standalone.mat-button-toggle-appearance-standard .mat-pseudo-checkbox,.mat-button-toggle-group-appearance-standard .mat-pseudo-checkbox{--mat-minimal-pseudo-checkbox-selected-checkmark-color: var( --mat-standard-button-toggle-selected-state-text-color )}.mat-button-toggle-standalone.mat-button-toggle-appearance-standard:not([class*=mat-elevation-z]),.mat-button-toggle-group-appearance-standard:not([class*=mat-elevation-z]){box-shadow:none}.cdk-high-contrast-active .mat-button-toggle-standalone.mat-button-toggle-appearance-standard,.cdk-high-contrast-active .mat-button-toggle-group-appearance-standard{outline:0}.mat-button-toggle-vertical{flex-direction:column}.mat-button-toggle-vertical .mat-button-toggle-label-content{display:block}.mat-button-toggle{white-space:nowrap;position:relative;color:var(--mat-legacy-button-toggle-text-color);font-family:var(--mat-legacy-button-toggle-label-text-font);font-size:var(--mat-legacy-button-toggle-label-text-size);line-height:var(--mat-legacy-button-toggle-label-text-line-height);font-weight:var(--mat-legacy-button-toggle-label-text-weight);letter-spacing:var(--mat-legacy-button-toggle-label-text-tracking);--mat-minimal-pseudo-checkbox-selected-checkmark-color: var( --mat-legacy-button-toggle-selected-state-text-color )}.mat-button-toggle.cdk-keyboard-focused .mat-button-toggle-focus-overlay{opacity:var(--mat-legacy-button-toggle-focus-state-layer-opacity)}.mat-button-toggle .mat-icon svg{vertical-align:top}.mat-button-toggle .mat-pseudo-checkbox{margin-right:12px}[dir=rtl] .mat-button-toggle .mat-pseudo-checkbox{margin-right:0;margin-left:12px}.mat-button-toggle-checked{color:var(--mat-legacy-button-toggle-selected-state-text-color);background-color:var(--mat-legacy-button-toggle-selected-state-background-color)}.mat-button-toggle-disabled{color:var(--mat-legacy-button-toggle-disabled-state-text-color);background-color:var(--mat-legacy-button-toggle-disabled-state-background-color);--mat-minimal-pseudo-checkbox-disabled-selected-checkmark-color: var( --mat-legacy-button-toggle-disabled-state-text-color )}.mat-button-toggle-disabled.mat-button-toggle-checked{background-color:var(--mat-legacy-button-toggle-disabled-selected-state-background-color)}.mat-button-toggle-appearance-standard{color:var(--mat-standard-button-toggle-text-color);background-color:var(--mat-standard-button-toggle-background-color);font-family:var(--mat-standard-button-toggle-label-text-font);font-size:var(--mat-standard-button-toggle-label-text-size);line-height:var(--mat-standard-button-toggle-label-text-line-height);font-weight:var(--mat-standard-button-toggle-label-text-weight);letter-spacing:var(--mat-standard-button-toggle-label-text-tracking)}.mat-button-toggle-group-appearance-standard .mat-button-toggle-appearance-standard+.mat-button-toggle-appearance-standard{border-left:solid 1px var(--mat-standard-button-toggle-divider-color)}[dir=rtl] .mat-button-toggle-group-appearance-standard .mat-button-toggle-appearance-standard+.mat-button-toggle-appearance-standard{border-left:none;border-right:solid 1px var(--mat-standard-button-toggle-divider-color)}.mat-button-toggle-group-appearance-standard.mat-button-toggle-vertical .mat-button-toggle-appearance-standard+.mat-button-toggle-appearance-standard{border-left:none;border-right:none;border-top:solid 1px var(--mat-standard-button-toggle-divider-color)}.mat-button-toggle-appearance-standard.mat-button-toggle-checked{color:var(--mat-standard-button-toggle-selected-state-text-color);background-color:var(--mat-standard-button-toggle-selected-state-background-color)}.mat-button-toggle-appearance-standard.mat-button-toggle-disabled{color:var(--mat-standard-button-toggle-disabled-state-text-color);background-color:var(--mat-standard-button-toggle-disabled-state-background-color)}.mat-button-toggle-appearance-standard.mat-button-toggle-disabled .mat-pseudo-checkbox{--mat-minimal-pseudo-checkbox-disabled-selected-checkmark-color: var( --mat-standard-button-toggle-disabled-selected-state-text-color )}.mat-button-toggle-appearance-standard.mat-button-toggle-disabled.mat-button-toggle-checked{color:var(--mat-standard-button-toggle-disabled-selected-state-text-color);background-color:var(--mat-standard-button-toggle-disabled-selected-state-background-color)}.mat-button-toggle-appearance-standard .mat-button-toggle-focus-overlay{background-color:var(--mat-standard-button-toggle-state-layer-color)}.mat-button-toggle-appearance-standard:not(.mat-button-toggle-disabled):hover .mat-button-toggle-focus-overlay{opacity:var(--mat-standard-button-toggle-hover-state-layer-opacity)}.mat-button-toggle-appearance-standard.cdk-keyboard-focused:not(.mat-button-toggle-disabled) .mat-button-toggle-focus-overlay{opacity:var(--mat-standard-button-toggle-focus-state-layer-opacity)}@media(hover: none){.mat-button-toggle-appearance-standard:not(.mat-button-toggle-disabled):hover .mat-button-toggle-focus-overlay{display:none}}.mat-button-toggle-label-content{-webkit-user-select:none;user-select:none;display:inline-block;padding:0 16px;line-height:var(--mat-legacy-button-toggle-height);position:relative}.mat-button-toggle-appearance-standard .mat-button-toggle-label-content{padding:0 12px;line-height:var(--mat-standard-button-toggle-height)}.mat-button-toggle-label-content>*{vertical-align:middle}.mat-button-toggle-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:inherit;pointer-events:none;opacity:0;background-color:var(--mat-legacy-button-toggle-state-layer-color)}.cdk-high-contrast-active .mat-button-toggle-checked .mat-button-toggle-focus-overlay{border-bottom:solid 500px;opacity:.5;height:0}.cdk-high-contrast-active .mat-button-toggle-checked:hover .mat-button-toggle-focus-overlay{opacity:.6}.cdk-high-contrast-active .mat-button-toggle-checked.mat-button-toggle-appearance-standard .mat-button-toggle-focus-overlay{border-bottom:solid 500px}.mat-button-toggle .mat-button-toggle-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-button-toggle-button{border:0;background:none;color:inherit;padding:0;margin:0;font:inherit;outline:none;width:100%;cursor:pointer}.mat-button-toggle-disabled .mat-button-toggle-button{cursor:default}.mat-button-toggle-button::-moz-focus-inner{border:0}.mat-button-toggle-standalone.mat-button-toggle-appearance-standard{--mat-focus-indicator-border-radius:var(--mat-standard-button-toggle-shape)}.mat-button-toggle-group-appearance-standard .mat-button-toggle:last-of-type .mat-button-toggle-button::before{border-top-right-radius:var(--mat-standard-button-toggle-shape);border-bottom-right-radius:var(--mat-standard-button-toggle-shape)}.mat-button-toggle-group-appearance-standard .mat-button-toggle:first-of-type .mat-button-toggle-button::before{border-top-left-radius:var(--mat-standard-button-toggle-shape);border-bottom-left-radius:var(--mat-standard-button-toggle-shape)}"]
    }]
  }], () => [{
    type: MatButtonToggleGroup,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [MAT_BUTTON_TOGGLE_GROUP]
    }]
  }, {
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }, {
    type: FocusMonitor
  }, {
    type: void 0,
    decorators: [{
      type: Attribute,
      args: ["tabindex"]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS]
    }]
  }], {
    ariaLabel: [{
      type: Input,
      args: ["aria-label"]
    }],
    ariaLabelledby: [{
      type: Input,
      args: ["aria-labelledby"]
    }],
    _buttonElement: [{
      type: ViewChild,
      args: ["button"]
    }],
    id: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    disableRipple: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    appearance: [{
      type: Input
    }],
    checked: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    disabled: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    change: [{
      type: Output
    }]
  });
})();
var MatButtonToggleModule = class _MatButtonToggleModule {
  static {
    this.ɵfac = function MatButtonToggleModule_Factory(t) {
      return new (t || _MatButtonToggleModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _MatButtonToggleModule,
      imports: [MatCommonModule, MatRippleModule, MatButtonToggleGroup, MatButtonToggle],
      exports: [MatCommonModule, MatButtonToggleGroup, MatButtonToggle]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [MatCommonModule, MatRippleModule, MatButtonToggle, MatCommonModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatButtonToggleModule, [{
    type: NgModule,
    args: [{
      imports: [MatCommonModule, MatRippleModule, MatButtonToggleGroup, MatButtonToggle],
      exports: [MatCommonModule, MatButtonToggleGroup, MatButtonToggle]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/tree.mjs
var BaseTreeControl = class {
  constructor() {
    this.expansionModel = new SelectionModel(true);
  }
  /** Toggles one single data node's expanded/collapsed state. */
  toggle(dataNode) {
    this.expansionModel.toggle(this._trackByValue(dataNode));
  }
  /** Expands one single data node. */
  expand(dataNode) {
    this.expansionModel.select(this._trackByValue(dataNode));
  }
  /** Collapses one single data node. */
  collapse(dataNode) {
    this.expansionModel.deselect(this._trackByValue(dataNode));
  }
  /** Whether a given data node is expanded or not. Returns true if the data node is expanded. */
  isExpanded(dataNode) {
    return this.expansionModel.isSelected(this._trackByValue(dataNode));
  }
  /** Toggles a subtree rooted at `node` recursively. */
  toggleDescendants(dataNode) {
    this.expansionModel.isSelected(this._trackByValue(dataNode)) ? this.collapseDescendants(dataNode) : this.expandDescendants(dataNode);
  }
  /** Collapse all dataNodes in the tree. */
  collapseAll() {
    this.expansionModel.clear();
  }
  /** Expands a subtree rooted at given data node recursively. */
  expandDescendants(dataNode) {
    let toBeProcessed = [dataNode];
    toBeProcessed.push(...this.getDescendants(dataNode));
    this.expansionModel.select(...toBeProcessed.map((value) => this._trackByValue(value)));
  }
  /** Collapses a subtree rooted at given data node recursively. */
  collapseDescendants(dataNode) {
    let toBeProcessed = [dataNode];
    toBeProcessed.push(...this.getDescendants(dataNode));
    this.expansionModel.deselect(...toBeProcessed.map((value) => this._trackByValue(value)));
  }
  _trackByValue(value) {
    return this.trackBy ? this.trackBy(value) : value;
  }
};
var FlatTreeControl = class extends BaseTreeControl {
  /** Construct with flat tree data node functions getLevel and isExpandable. */
  constructor(getLevel, isExpandable, options) {
    super();
    this.getLevel = getLevel;
    this.isExpandable = isExpandable;
    this.options = options;
    if (this.options) {
      this.trackBy = this.options.trackBy;
    }
  }
  /**
   * Gets a list of the data node's subtree of descendent data nodes.
   *
   * To make this working, the `dataNodes` of the TreeControl must be flattened tree nodes
   * with correct levels.
   */
  getDescendants(dataNode) {
    const startIndex = this.dataNodes.indexOf(dataNode);
    const results = [];
    for (let i = startIndex + 1; i < this.dataNodes.length && this.getLevel(dataNode) < this.getLevel(this.dataNodes[i]); i++) {
      results.push(this.dataNodes[i]);
    }
    return results;
  }
  /**
   * Expands all data nodes in the tree.
   *
   * To make this working, the `dataNodes` variable of the TreeControl must be set to all flattened
   * data nodes of the tree.
   */
  expandAll() {
    this.expansionModel.select(...this.dataNodes.map((node) => this._trackByValue(node)));
  }
};
var CDK_TREE_NODE_OUTLET_NODE = new InjectionToken("CDK_TREE_NODE_OUTLET_NODE");
var CdkTreeNodeOutlet = class _CdkTreeNodeOutlet {
  constructor(viewContainer, _node) {
    this.viewContainer = viewContainer;
    this._node = _node;
  }
  static {
    this.ɵfac = function CdkTreeNodeOutlet_Factory(t) {
      return new (t || _CdkTreeNodeOutlet)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(CDK_TREE_NODE_OUTLET_NODE, 8));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _CdkTreeNodeOutlet,
      selectors: [["", "cdkTreeNodeOutlet", ""]],
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTreeNodeOutlet, [{
    type: Directive,
    args: [{
      selector: "[cdkTreeNodeOutlet]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [CDK_TREE_NODE_OUTLET_NODE]
    }, {
      type: Optional
    }]
  }], null);
})();
var CdkTreeNodeOutletContext = class {
  constructor(data) {
    this.$implicit = data;
  }
};
var CdkTreeNodeDef = class _CdkTreeNodeDef {
  /** @docs-private */
  constructor(template) {
    this.template = template;
  }
  static {
    this.ɵfac = function CdkTreeNodeDef_Factory(t) {
      return new (t || _CdkTreeNodeDef)(ɵɵdirectiveInject(TemplateRef));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _CdkTreeNodeDef,
      selectors: [["", "cdkTreeNodeDef", ""]],
      inputs: {
        when: [InputFlags.None, "cdkTreeNodeDefWhen", "when"]
      },
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTreeNodeDef, [{
    type: Directive,
    args: [{
      selector: "[cdkTreeNodeDef]",
      inputs: [{
        name: "when",
        alias: "cdkTreeNodeDefWhen"
      }],
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
function getTreeNoValidDataSourceError() {
  return Error(`A valid data source must be provided.`);
}
function getTreeMultipleDefaultNodeDefsError() {
  return Error(`There can only be one default row without a when predicate function.`);
}
function getTreeMissingMatchingNodeDefError() {
  return Error(`Could not find a matching node definition for the provided node data.`);
}
function getTreeControlMissingError() {
  return Error(`Could not find a tree control for the tree.`);
}
function getTreeControlFunctionsMissingError() {
  return Error(`Could not find functions for nested/flat tree in tree control.`);
}
var CdkTree = class _CdkTree {
  /**
   * Provides a stream containing the latest data array to render. Influenced by the tree's
   * stream of view window (what dataNodes are currently on screen).
   * Data source can be an observable of data array, or a data array to render.
   */
  get dataSource() {
    return this._dataSource;
  }
  set dataSource(dataSource) {
    if (this._dataSource !== dataSource) {
      this._switchDataSource(dataSource);
    }
  }
  constructor(_differs, _changeDetectorRef) {
    this._differs = _differs;
    this._changeDetectorRef = _changeDetectorRef;
    this._onDestroy = new Subject();
    this._levels = /* @__PURE__ */ new Map();
    this.viewChange = new BehaviorSubject({
      start: 0,
      end: Number.MAX_VALUE
    });
  }
  ngOnInit() {
    this._dataDiffer = this._differs.find([]).create(this.trackBy);
    if (!this.treeControl && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getTreeControlMissingError();
    }
  }
  ngOnDestroy() {
    this._nodeOutlet.viewContainer.clear();
    this.viewChange.complete();
    this._onDestroy.next();
    this._onDestroy.complete();
    if (this._dataSource && typeof this._dataSource.disconnect === "function") {
      this.dataSource.disconnect(this);
    }
    if (this._dataSubscription) {
      this._dataSubscription.unsubscribe();
      this._dataSubscription = null;
    }
  }
  ngAfterContentChecked() {
    const defaultNodeDefs = this._nodeDefs.filter((def) => !def.when);
    if (defaultNodeDefs.length > 1 && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getTreeMultipleDefaultNodeDefsError();
    }
    this._defaultNodeDef = defaultNodeDefs[0];
    if (this.dataSource && this._nodeDefs && !this._dataSubscription) {
      this._observeRenderChanges();
    }
  }
  // TODO(tinayuangao): Work on keyboard traversal and actions, make sure it's working for RTL
  //     and nested trees.
  /**
   * Switch to the provided data source by resetting the data and unsubscribing from the current
   * render change subscription if one exists. If the data source is null, interpret this by
   * clearing the node outlet. Otherwise start listening for new data.
   */
  _switchDataSource(dataSource) {
    if (this._dataSource && typeof this._dataSource.disconnect === "function") {
      this.dataSource.disconnect(this);
    }
    if (this._dataSubscription) {
      this._dataSubscription.unsubscribe();
      this._dataSubscription = null;
    }
    if (!dataSource) {
      this._nodeOutlet.viewContainer.clear();
    }
    this._dataSource = dataSource;
    if (this._nodeDefs) {
      this._observeRenderChanges();
    }
  }
  /** Set up a subscription for the data provided by the data source. */
  _observeRenderChanges() {
    let dataStream;
    if (isDataSource(this._dataSource)) {
      dataStream = this._dataSource.connect(this);
    } else if (isObservable(this._dataSource)) {
      dataStream = this._dataSource;
    } else if (Array.isArray(this._dataSource)) {
      dataStream = of(this._dataSource);
    }
    if (dataStream) {
      this._dataSubscription = dataStream.pipe(takeUntil(this._onDestroy)).subscribe((data) => this.renderNodeChanges(data));
    } else if (typeof ngDevMode === "undefined" || ngDevMode) {
      throw getTreeNoValidDataSourceError();
    }
  }
  /** Check for changes made in the data and render each change (node added/removed/moved). */
  renderNodeChanges(data, dataDiffer = this._dataDiffer, viewContainer = this._nodeOutlet.viewContainer, parentData) {
    const changes = dataDiffer.diff(data);
    if (!changes) {
      return;
    }
    changes.forEachOperation((item, adjustedPreviousIndex, currentIndex) => {
      if (item.previousIndex == null) {
        this.insertNode(data[currentIndex], currentIndex, viewContainer, parentData);
      } else if (currentIndex == null) {
        viewContainer.remove(adjustedPreviousIndex);
        this._levels.delete(item.item);
      } else {
        const view = viewContainer.get(adjustedPreviousIndex);
        viewContainer.move(view, currentIndex);
      }
    });
    this._changeDetectorRef.detectChanges();
  }
  /**
   * Finds the matching node definition that should be used for this node data. If there is only
   * one node definition, it is returned. Otherwise, find the node definition that has a when
   * predicate that returns true with the data. If none return true, return the default node
   * definition.
   */
  _getNodeDef(data, i) {
    if (this._nodeDefs.length === 1) {
      return this._nodeDefs.first;
    }
    const nodeDef = this._nodeDefs.find((def) => def.when && def.when(i, data)) || this._defaultNodeDef;
    if (!nodeDef && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getTreeMissingMatchingNodeDefError();
    }
    return nodeDef;
  }
  /**
   * Create the embedded view for the data node template and place it in the correct index location
   * within the data node view container.
   */
  insertNode(nodeData, index, viewContainer, parentData) {
    const node = this._getNodeDef(nodeData, index);
    const context = new CdkTreeNodeOutletContext(nodeData);
    if (this.treeControl.getLevel) {
      context.level = this.treeControl.getLevel(nodeData);
    } else if (typeof parentData !== "undefined" && this._levels.has(parentData)) {
      context.level = this._levels.get(parentData) + 1;
    } else {
      context.level = 0;
    }
    this._levels.set(nodeData, context.level);
    const container = viewContainer ? viewContainer : this._nodeOutlet.viewContainer;
    container.createEmbeddedView(node.template, context, index);
    if (CdkTreeNode.mostRecentTreeNode) {
      CdkTreeNode.mostRecentTreeNode.data = nodeData;
    }
  }
  static {
    this.ɵfac = function CdkTree_Factory(t) {
      return new (t || _CdkTree)(ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(ChangeDetectorRef));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _CdkTree,
      selectors: [["cdk-tree"]],
      contentQueries: function CdkTree_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          ɵɵcontentQuery(dirIndex, CdkTreeNodeDef, 5);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._nodeDefs = _t);
        }
      },
      viewQuery: function CdkTree_Query(rf, ctx) {
        if (rf & 1) {
          ɵɵviewQuery(CdkTreeNodeOutlet, 7);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._nodeOutlet = _t.first);
        }
      },
      hostAttrs: ["role", "tree", 1, "cdk-tree"],
      inputs: {
        dataSource: "dataSource",
        treeControl: "treeControl",
        trackBy: "trackBy"
      },
      exportAs: ["cdkTree"],
      standalone: true,
      features: [ɵɵStandaloneFeature],
      decls: 1,
      vars: 0,
      consts: [["cdkTreeNodeOutlet", ""]],
      template: function CdkTree_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementContainer(0, 0);
        }
      },
      dependencies: [CdkTreeNodeOutlet],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTree, [{
    type: Component,
    args: [{
      selector: "cdk-tree",
      exportAs: "cdkTree",
      template: `<ng-container cdkTreeNodeOutlet></ng-container>`,
      host: {
        "class": "cdk-tree",
        "role": "tree"
      },
      encapsulation: ViewEncapsulation$1.None,
      // The "OnPush" status for the `CdkTree` component is effectively a noop, so we are removing it.
      // The view for `CdkTree` consists entirely of templates declared in other views. As they are
      // declared elsewhere, they are checked when their declaration points are checked.
      // tslint:disable-next-line:validate-decorators
      changeDetection: ChangeDetectionStrategy.Default,
      standalone: true,
      imports: [CdkTreeNodeOutlet]
    }]
  }], () => [{
    type: IterableDiffers
  }, {
    type: ChangeDetectorRef
  }], {
    dataSource: [{
      type: Input
    }],
    treeControl: [{
      type: Input
    }],
    trackBy: [{
      type: Input
    }],
    _nodeOutlet: [{
      type: ViewChild,
      args: [CdkTreeNodeOutlet, {
        static: true
      }]
    }],
    _nodeDefs: [{
      type: ContentChildren,
      args: [CdkTreeNodeDef, {
        // We need to use `descendants: true`, because Ivy will no longer match
        // indirect descendants if it's left as false.
        descendants: true
      }]
    }]
  });
})();
var CdkTreeNode = class _CdkTreeNode {
  /**
   * The role of the tree node.
   * @deprecated The correct role is 'treeitem', 'group' should not be used. This input will be
   *   removed in a future version.
   * @breaking-change 12.0.0 Remove this input
   */
  get role() {
    return "treeitem";
  }
  set role(_role) {
    this._elementRef.nativeElement.setAttribute("role", _role);
  }
  static {
    this.mostRecentTreeNode = null;
  }
  /** The tree node's data. */
  get data() {
    return this._data;
  }
  set data(value) {
    if (value !== this._data) {
      this._data = value;
      this._setRoleFromData();
      this._dataChanges.next();
    }
  }
  get isExpanded() {
    return this._tree.treeControl.isExpanded(this._data);
  }
  get level() {
    return this._tree.treeControl.getLevel ? this._tree.treeControl.getLevel(this._data) : this._parentNodeAriaLevel;
  }
  constructor(_elementRef, _tree) {
    this._elementRef = _elementRef;
    this._tree = _tree;
    this._destroyed = new Subject();
    this._dataChanges = new Subject();
    _CdkTreeNode.mostRecentTreeNode = this;
    this.role = "treeitem";
  }
  ngOnInit() {
    this._parentNodeAriaLevel = getParentNodeAriaLevel(this._elementRef.nativeElement);
    this._elementRef.nativeElement.setAttribute("aria-level", `${this.level + 1}`);
  }
  ngOnDestroy() {
    if (_CdkTreeNode.mostRecentTreeNode === this) {
      _CdkTreeNode.mostRecentTreeNode = null;
    }
    this._dataChanges.complete();
    this._destroyed.next();
    this._destroyed.complete();
  }
  /** Focuses the menu item. Implements for FocusableOption. */
  focus() {
    this._elementRef.nativeElement.focus();
  }
  // TODO: role should eventually just be set in the component host
  _setRoleFromData() {
    if (!this._tree.treeControl.isExpandable && !this._tree.treeControl.getChildren && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getTreeControlFunctionsMissingError();
    }
    this.role = "treeitem";
  }
  static {
    this.ɵfac = function CdkTreeNode_Factory(t) {
      return new (t || _CdkTreeNode)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(CdkTree));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _CdkTreeNode,
      selectors: [["cdk-tree-node"]],
      hostAttrs: [1, "cdk-tree-node"],
      hostVars: 1,
      hostBindings: function CdkTreeNode_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵattribute("aria-expanded", ctx.isExpanded);
        }
      },
      inputs: {
        role: "role"
      },
      exportAs: ["cdkTreeNode"],
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTreeNode, [{
    type: Directive,
    args: [{
      selector: "cdk-tree-node",
      exportAs: "cdkTreeNode",
      host: {
        "class": "cdk-tree-node",
        "[attr.aria-expanded]": "isExpanded"
      },
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: CdkTree
  }], {
    role: [{
      type: Input
    }]
  });
})();
function getParentNodeAriaLevel(nodeElement) {
  let parent = nodeElement.parentElement;
  while (parent && !isNodeElement(parent)) {
    parent = parent.parentElement;
  }
  if (!parent) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      throw Error("Incorrect tree structure containing detached node.");
    } else {
      return -1;
    }
  } else if (parent.classList.contains("cdk-nested-tree-node")) {
    return numberAttribute(parent.getAttribute("aria-level"));
  } else {
    return 0;
  }
}
function isNodeElement(element) {
  const classList = element.classList;
  return !!(classList?.contains("cdk-nested-tree-node") || classList?.contains("cdk-tree"));
}
var CdkNestedTreeNode = class _CdkNestedTreeNode extends CdkTreeNode {
  constructor(elementRef, tree, _differs) {
    super(elementRef, tree);
    this._differs = _differs;
  }
  ngAfterContentInit() {
    this._dataDiffer = this._differs.find([]).create(this._tree.trackBy);
    if (!this._tree.treeControl.getChildren && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getTreeControlFunctionsMissingError();
    }
    const childrenNodes = this._tree.treeControl.getChildren(this.data);
    if (Array.isArray(childrenNodes)) {
      this.updateChildrenNodes(childrenNodes);
    } else if (isObservable(childrenNodes)) {
      childrenNodes.pipe(takeUntil(this._destroyed)).subscribe((result) => this.updateChildrenNodes(result));
    }
    this.nodeOutlet.changes.pipe(takeUntil(this._destroyed)).subscribe(() => this.updateChildrenNodes());
  }
  // This is a workaround for https://github.com/angular/angular/issues/23091
  // In aot mode, the lifecycle hooks from parent class are not called.
  ngOnInit() {
    super.ngOnInit();
  }
  ngOnDestroy() {
    this._clear();
    super.ngOnDestroy();
  }
  /** Add children dataNodes to the NodeOutlet */
  updateChildrenNodes(children) {
    const outlet = this._getNodeOutlet();
    if (children) {
      this._children = children;
    }
    if (outlet && this._children) {
      const viewContainer = outlet.viewContainer;
      this._tree.renderNodeChanges(this._children, this._dataDiffer, viewContainer, this._data);
    } else {
      this._dataDiffer.diff([]);
    }
  }
  /** Clear the children dataNodes. */
  _clear() {
    const outlet = this._getNodeOutlet();
    if (outlet) {
      outlet.viewContainer.clear();
      this._dataDiffer.diff([]);
    }
  }
  /** Gets the outlet for the current node. */
  _getNodeOutlet() {
    const outlets = this.nodeOutlet;
    return outlets && outlets.find((outlet) => !outlet._node || outlet._node === this);
  }
  static {
    this.ɵfac = function CdkNestedTreeNode_Factory(t) {
      return new (t || _CdkNestedTreeNode)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(CdkTree), ɵɵdirectiveInject(IterableDiffers));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _CdkNestedTreeNode,
      selectors: [["cdk-nested-tree-node"]],
      contentQueries: function CdkNestedTreeNode_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          ɵɵcontentQuery(dirIndex, CdkTreeNodeOutlet, 5);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.nodeOutlet = _t);
        }
      },
      hostAttrs: [1, "cdk-nested-tree-node"],
      exportAs: ["cdkNestedTreeNode"],
      standalone: true,
      features: [ɵɵProvidersFeature([{
        provide: CdkTreeNode,
        useExisting: _CdkNestedTreeNode
      }, {
        provide: CDK_TREE_NODE_OUTLET_NODE,
        useExisting: _CdkNestedTreeNode
      }]), ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkNestedTreeNode, [{
    type: Directive,
    args: [{
      selector: "cdk-nested-tree-node",
      exportAs: "cdkNestedTreeNode",
      providers: [{
        provide: CdkTreeNode,
        useExisting: CdkNestedTreeNode
      }, {
        provide: CDK_TREE_NODE_OUTLET_NODE,
        useExisting: CdkNestedTreeNode
      }],
      host: {
        "class": "cdk-nested-tree-node"
      },
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: CdkTree
  }, {
    type: IterableDiffers
  }], {
    nodeOutlet: [{
      type: ContentChildren,
      args: [CdkTreeNodeOutlet, {
        // We need to use `descendants: true`, because Ivy will no longer match
        // indirect descendants if it's left as false.
        descendants: true
      }]
    }]
  });
})();
var cssUnitPattern = /([A-Za-z%]+)$/;
var CdkTreeNodePadding = class _CdkTreeNodePadding {
  /** The level of depth of the tree node. The padding will be `level * indent` pixels. */
  get level() {
    return this._level;
  }
  set level(value) {
    this._setLevelInput(value);
  }
  /**
   * The indent for each level. Can be a number or a CSS string.
   * Default number 40px from material design menu sub-menu spec.
   */
  get indent() {
    return this._indent;
  }
  set indent(indent) {
    this._setIndentInput(indent);
  }
  constructor(_treeNode, _tree, _element, _dir) {
    this._treeNode = _treeNode;
    this._tree = _tree;
    this._element = _element;
    this._dir = _dir;
    this._destroyed = new Subject();
    this.indentUnits = "px";
    this._indent = 40;
    this._setPadding();
    if (_dir) {
      _dir.change.pipe(takeUntil(this._destroyed)).subscribe(() => this._setPadding(true));
    }
    _treeNode._dataChanges.subscribe(() => this._setPadding());
  }
  ngOnDestroy() {
    this._destroyed.next();
    this._destroyed.complete();
  }
  /** The padding indent value for the tree node. Returns a string with px numbers if not null. */
  _paddingIndent() {
    const nodeLevel = this._treeNode.data && this._tree.treeControl.getLevel ? this._tree.treeControl.getLevel(this._treeNode.data) : null;
    const level = this._level == null ? nodeLevel : this._level;
    return typeof level === "number" ? `${level * this._indent}${this.indentUnits}` : null;
  }
  _setPadding(forceChange = false) {
    const padding = this._paddingIndent();
    if (padding !== this._currentPadding || forceChange) {
      const element = this._element.nativeElement;
      const paddingProp = this._dir && this._dir.value === "rtl" ? "paddingRight" : "paddingLeft";
      const resetProp = paddingProp === "paddingLeft" ? "paddingRight" : "paddingLeft";
      element.style[paddingProp] = padding || "";
      element.style[resetProp] = "";
      this._currentPadding = padding;
    }
  }
  /**
   * This has been extracted to a util because of TS 4 and VE.
   * View Engine doesn't support property rename inheritance.
   * TS 4.0 doesn't allow properties to override accessors or vice-versa.
   * @docs-private
   */
  _setLevelInput(value) {
    this._level = isNaN(value) ? null : value;
    this._setPadding();
  }
  /**
   * This has been extracted to a util because of TS 4 and VE.
   * View Engine doesn't support property rename inheritance.
   * TS 4.0 doesn't allow properties to override accessors or vice-versa.
   * @docs-private
   */
  _setIndentInput(indent) {
    let value = indent;
    let units = "px";
    if (typeof indent === "string") {
      const parts = indent.split(cssUnitPattern);
      value = parts[0];
      units = parts[1] || units;
    }
    this.indentUnits = units;
    this._indent = numberAttribute(value);
    this._setPadding();
  }
  static {
    this.ɵfac = function CdkTreeNodePadding_Factory(t) {
      return new (t || _CdkTreeNodePadding)(ɵɵdirectiveInject(CdkTreeNode), ɵɵdirectiveInject(CdkTree), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Directionality, 8));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _CdkTreeNodePadding,
      selectors: [["", "cdkTreeNodePadding", ""]],
      inputs: {
        level: [InputFlags.HasDecoratorInputTransform, "cdkTreeNodePadding", "level", numberAttribute],
        indent: [InputFlags.None, "cdkTreeNodePaddingIndent", "indent"]
      },
      standalone: true,
      features: [ɵɵInputTransformsFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTreeNodePadding, [{
    type: Directive,
    args: [{
      selector: "[cdkTreeNodePadding]",
      standalone: true
    }]
  }], () => [{
    type: CdkTreeNode
  }, {
    type: CdkTree
  }, {
    type: ElementRef
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], {
    level: [{
      type: Input,
      args: [{
        alias: "cdkTreeNodePadding",
        transform: numberAttribute
      }]
    }],
    indent: [{
      type: Input,
      args: ["cdkTreeNodePaddingIndent"]
    }]
  });
})();
var CdkTreeNodeToggle = class _CdkTreeNodeToggle {
  constructor(_tree, _treeNode) {
    this._tree = _tree;
    this._treeNode = _treeNode;
    this.recursive = false;
  }
  _toggle(event) {
    this.recursive ? this._tree.treeControl.toggleDescendants(this._treeNode.data) : this._tree.treeControl.toggle(this._treeNode.data);
    event.stopPropagation();
  }
  static {
    this.ɵfac = function CdkTreeNodeToggle_Factory(t) {
      return new (t || _CdkTreeNodeToggle)(ɵɵdirectiveInject(CdkTree), ɵɵdirectiveInject(CdkTreeNode));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _CdkTreeNodeToggle,
      selectors: [["", "cdkTreeNodeToggle", ""]],
      hostBindings: function CdkTreeNodeToggle_HostBindings(rf, ctx) {
        if (rf & 1) {
          ɵɵlistener("click", function CdkTreeNodeToggle_click_HostBindingHandler($event) {
            return ctx._toggle($event);
          });
        }
      },
      inputs: {
        recursive: [InputFlags.HasDecoratorInputTransform, "cdkTreeNodeToggleRecursive", "recursive", booleanAttribute]
      },
      standalone: true,
      features: [ɵɵInputTransformsFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTreeNodeToggle, [{
    type: Directive,
    args: [{
      selector: "[cdkTreeNodeToggle]",
      host: {
        "(click)": "_toggle($event)"
      },
      standalone: true
    }]
  }], () => [{
    type: CdkTree
  }, {
    type: CdkTreeNode
  }], {
    recursive: [{
      type: Input,
      args: [{
        alias: "cdkTreeNodeToggleRecursive",
        transform: booleanAttribute
      }]
    }]
  });
})();
var EXPORTED_DECLARATIONS = [CdkNestedTreeNode, CdkTreeNodeDef, CdkTreeNodePadding, CdkTreeNodeToggle, CdkTree, CdkTreeNode, CdkTreeNodeOutlet];
var CdkTreeModule = class _CdkTreeModule {
  static {
    this.ɵfac = function CdkTreeModule_Factory(t) {
      return new (t || _CdkTreeModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _CdkTreeModule,
      imports: [CdkNestedTreeNode, CdkTreeNodeDef, CdkTreeNodePadding, CdkTreeNodeToggle, CdkTree, CdkTreeNode, CdkTreeNodeOutlet],
      exports: [CdkNestedTreeNode, CdkTreeNodeDef, CdkTreeNodePadding, CdkTreeNodeToggle, CdkTree, CdkTreeNode, CdkTreeNodeOutlet]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({});
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTreeModule, [{
    type: NgModule,
    args: [{
      imports: EXPORTED_DECLARATIONS,
      exports: EXPORTED_DECLARATIONS
    }]
  }], null, null);
})();

// node_modules/@angular/material/fesm2022/tree.mjs
var MatTreeNode = class _MatTreeNode extends CdkTreeNode {
  constructor(elementRef, tree, tabIndex) {
    super(elementRef, tree);
    this.disabled = false;
    this.tabIndex = Number(tabIndex) || 0;
  }
  // This is a workaround for https://github.com/angular/angular/issues/23091
  // In aot mode, the lifecycle hooks from parent class are not called.
  ngOnInit() {
    super.ngOnInit();
  }
  ngOnDestroy() {
    super.ngOnDestroy();
  }
  static {
    this.ɵfac = function MatTreeNode_Factory(t) {
      return new (t || _MatTreeNode)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(CdkTree), ɵɵinjectAttribute("tabindex"));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _MatTreeNode,
      selectors: [["mat-tree-node"]],
      hostAttrs: [1, "mat-tree-node"],
      inputs: {
        disabled: [InputFlags.HasDecoratorInputTransform, "disabled", "disabled", booleanAttribute],
        tabIndex: [InputFlags.HasDecoratorInputTransform, "tabIndex", "tabIndex", (value) => value == null ? 0 : numberAttribute(value)]
      },
      exportAs: ["matTreeNode"],
      standalone: true,
      features: [ɵɵProvidersFeature([{
        provide: CdkTreeNode,
        useExisting: _MatTreeNode
      }]), ɵɵInputTransformsFeature, ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTreeNode, [{
    type: Directive,
    args: [{
      selector: "mat-tree-node",
      exportAs: "matTreeNode",
      providers: [{
        provide: CdkTreeNode,
        useExisting: MatTreeNode
      }],
      host: {
        "class": "mat-tree-node"
      },
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: CdkTree
  }, {
    type: void 0,
    decorators: [{
      type: Attribute,
      args: ["tabindex"]
    }]
  }], {
    disabled: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    tabIndex: [{
      type: Input,
      args: [{
        transform: (value) => value == null ? 0 : numberAttribute(value)
      }]
    }]
  });
})();
var MatTreeNodeDef = class _MatTreeNodeDef extends CdkTreeNodeDef {
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵMatTreeNodeDef_BaseFactory;
      return function MatTreeNodeDef_Factory(t) {
        return (ɵMatTreeNodeDef_BaseFactory || (ɵMatTreeNodeDef_BaseFactory = ɵɵgetInheritedFactory(_MatTreeNodeDef)))(t || _MatTreeNodeDef);
      };
    })();
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _MatTreeNodeDef,
      selectors: [["", "matTreeNodeDef", ""]],
      inputs: {
        when: [InputFlags.None, "matTreeNodeDefWhen", "when"],
        data: [InputFlags.None, "matTreeNode", "data"]
      },
      standalone: true,
      features: [ɵɵProvidersFeature([{
        provide: CdkTreeNodeDef,
        useExisting: _MatTreeNodeDef
      }]), ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTreeNodeDef, [{
    type: Directive,
    args: [{
      selector: "[matTreeNodeDef]",
      inputs: [{
        name: "when",
        alias: "matTreeNodeDefWhen"
      }],
      providers: [{
        provide: CdkTreeNodeDef,
        useExisting: MatTreeNodeDef
      }],
      standalone: true
    }]
  }], null, {
    data: [{
      type: Input,
      args: ["matTreeNode"]
    }]
  });
})();
var MatNestedTreeNode = class _MatNestedTreeNode extends CdkNestedTreeNode {
  /** Tabindex for the node. */
  get tabIndex() {
    return this.disabled ? -1 : this._tabIndex;
  }
  set tabIndex(value) {
    this._tabIndex = value != null ? value : 0;
  }
  constructor(elementRef, tree, differs, tabIndex) {
    super(elementRef, tree, differs);
    this.disabled = false;
    this.tabIndex = Number(tabIndex) || 0;
  }
  // This is a workaround for https://github.com/angular/angular/issues/19145
  // In aot mode, the lifecycle hooks from parent class are not called.
  // TODO(tinayuangao): Remove when the angular issue #19145 is fixed
  ngOnInit() {
    super.ngOnInit();
  }
  ngAfterContentInit() {
    super.ngAfterContentInit();
  }
  ngOnDestroy() {
    super.ngOnDestroy();
  }
  static {
    this.ɵfac = function MatNestedTreeNode_Factory(t) {
      return new (t || _MatNestedTreeNode)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(CdkTree), ɵɵdirectiveInject(IterableDiffers), ɵɵinjectAttribute("tabindex"));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _MatNestedTreeNode,
      selectors: [["mat-nested-tree-node"]],
      hostAttrs: [1, "mat-nested-tree-node"],
      inputs: {
        node: [InputFlags.None, "matNestedTreeNode", "node"],
        disabled: [InputFlags.HasDecoratorInputTransform, "disabled", "disabled", booleanAttribute],
        tabIndex: "tabIndex"
      },
      exportAs: ["matNestedTreeNode"],
      standalone: true,
      features: [ɵɵProvidersFeature([{
        provide: CdkNestedTreeNode,
        useExisting: _MatNestedTreeNode
      }, {
        provide: CdkTreeNode,
        useExisting: _MatNestedTreeNode
      }, {
        provide: CDK_TREE_NODE_OUTLET_NODE,
        useExisting: _MatNestedTreeNode
      }]), ɵɵInputTransformsFeature, ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatNestedTreeNode, [{
    type: Directive,
    args: [{
      selector: "mat-nested-tree-node",
      exportAs: "matNestedTreeNode",
      providers: [{
        provide: CdkNestedTreeNode,
        useExisting: MatNestedTreeNode
      }, {
        provide: CdkTreeNode,
        useExisting: MatNestedTreeNode
      }, {
        provide: CDK_TREE_NODE_OUTLET_NODE,
        useExisting: MatNestedTreeNode
      }],
      host: {
        "class": "mat-nested-tree-node"
      },
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: CdkTree
  }, {
    type: IterableDiffers
  }, {
    type: void 0,
    decorators: [{
      type: Attribute,
      args: ["tabindex"]
    }]
  }], {
    node: [{
      type: Input,
      args: ["matNestedTreeNode"]
    }],
    disabled: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    tabIndex: [{
      type: Input
    }]
  });
})();
var MatTreeNodePadding = class _MatTreeNodePadding extends CdkTreeNodePadding {
  /** The level of depth of the tree node. The padding will be `level * indent` pixels. */
  get level() {
    return this._level;
  }
  set level(value) {
    this._setLevelInput(value);
  }
  /** The indent for each level. Default number 40px from material design menu sub-menu spec. */
  get indent() {
    return this._indent;
  }
  set indent(indent) {
    this._setIndentInput(indent);
  }
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵMatTreeNodePadding_BaseFactory;
      return function MatTreeNodePadding_Factory(t) {
        return (ɵMatTreeNodePadding_BaseFactory || (ɵMatTreeNodePadding_BaseFactory = ɵɵgetInheritedFactory(_MatTreeNodePadding)))(t || _MatTreeNodePadding);
      };
    })();
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _MatTreeNodePadding,
      selectors: [["", "matTreeNodePadding", ""]],
      inputs: {
        level: [InputFlags.HasDecoratorInputTransform, "matTreeNodePadding", "level", numberAttribute],
        indent: [InputFlags.None, "matTreeNodePaddingIndent", "indent"]
      },
      standalone: true,
      features: [ɵɵProvidersFeature([{
        provide: CdkTreeNodePadding,
        useExisting: _MatTreeNodePadding
      }]), ɵɵInputTransformsFeature, ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTreeNodePadding, [{
    type: Directive,
    args: [{
      selector: "[matTreeNodePadding]",
      providers: [{
        provide: CdkTreeNodePadding,
        useExisting: MatTreeNodePadding
      }],
      standalone: true
    }]
  }], null, {
    level: [{
      type: Input,
      args: [{
        alias: "matTreeNodePadding",
        transform: numberAttribute
      }]
    }],
    indent: [{
      type: Input,
      args: ["matTreeNodePaddingIndent"]
    }]
  });
})();
var MatTreeNodeOutlet = class _MatTreeNodeOutlet {
  constructor(viewContainer, _node) {
    this.viewContainer = viewContainer;
    this._node = _node;
  }
  static {
    this.ɵfac = function MatTreeNodeOutlet_Factory(t) {
      return new (t || _MatTreeNodeOutlet)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(CDK_TREE_NODE_OUTLET_NODE, 8));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _MatTreeNodeOutlet,
      selectors: [["", "matTreeNodeOutlet", ""]],
      standalone: true,
      features: [ɵɵProvidersFeature([{
        provide: CdkTreeNodeOutlet,
        useExisting: _MatTreeNodeOutlet
      }])]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTreeNodeOutlet, [{
    type: Directive,
    args: [{
      selector: "[matTreeNodeOutlet]",
      providers: [{
        provide: CdkTreeNodeOutlet,
        useExisting: MatTreeNodeOutlet
      }],
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [CDK_TREE_NODE_OUTLET_NODE]
    }, {
      type: Optional
    }]
  }], null);
})();
var MatTree = class _MatTree extends CdkTree {
  constructor() {
    super(...arguments);
    this._nodeOutlet = void 0;
  }
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵMatTree_BaseFactory;
      return function MatTree_Factory(t) {
        return (ɵMatTree_BaseFactory || (ɵMatTree_BaseFactory = ɵɵgetInheritedFactory(_MatTree)))(t || _MatTree);
      };
    })();
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _MatTree,
      selectors: [["mat-tree"]],
      viewQuery: function MatTree_Query(rf, ctx) {
        if (rf & 1) {
          ɵɵviewQuery(MatTreeNodeOutlet, 7);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._nodeOutlet = _t.first);
        }
      },
      hostAttrs: ["role", "tree", 1, "mat-tree"],
      exportAs: ["matTree"],
      standalone: true,
      features: [ɵɵProvidersFeature([{
        provide: CdkTree,
        useExisting: _MatTree
      }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
      decls: 1,
      vars: 0,
      consts: [["matTreeNodeOutlet", ""]],
      template: function MatTree_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementContainer(0, 0);
        }
      },
      dependencies: [MatTreeNodeOutlet],
      styles: [".mat-tree{display:block;background-color:var(--mat-tree-container-background-color)}.mat-tree-node,.mat-nested-tree-node{color:var(--mat-tree-node-text-color);font-family:var(--mat-tree-node-text-font);font-size:var(--mat-tree-node-text-size);font-weight:var(--mat-tree-node-text-weight)}.mat-tree-node{display:flex;align-items:center;flex:1;word-wrap:break-word;min-height:var(--mat-tree-node-min-height)}.mat-nested-tree-node{border-bottom-width:0}"],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTree, [{
    type: Component,
    args: [{
      selector: "mat-tree",
      exportAs: "matTree",
      template: `<ng-container matTreeNodeOutlet></ng-container>`,
      host: {
        "class": "mat-tree",
        "role": "tree"
      },
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.Default,
      providers: [{
        provide: CdkTree,
        useExisting: MatTree
      }],
      standalone: true,
      imports: [MatTreeNodeOutlet],
      styles: [".mat-tree{display:block;background-color:var(--mat-tree-container-background-color)}.mat-tree-node,.mat-nested-tree-node{color:var(--mat-tree-node-text-color);font-family:var(--mat-tree-node-text-font);font-size:var(--mat-tree-node-text-size);font-weight:var(--mat-tree-node-text-weight)}.mat-tree-node{display:flex;align-items:center;flex:1;word-wrap:break-word;min-height:var(--mat-tree-node-min-height)}.mat-nested-tree-node{border-bottom-width:0}"]
    }]
  }], null, {
    _nodeOutlet: [{
      type: ViewChild,
      args: [MatTreeNodeOutlet, {
        static: true
      }]
    }]
  });
})();
var MatTreeNodeToggle = class _MatTreeNodeToggle extends CdkTreeNodeToggle {
  static {
    this.ɵfac = /* @__PURE__ */ (() => {
      let ɵMatTreeNodeToggle_BaseFactory;
      return function MatTreeNodeToggle_Factory(t) {
        return (ɵMatTreeNodeToggle_BaseFactory || (ɵMatTreeNodeToggle_BaseFactory = ɵɵgetInheritedFactory(_MatTreeNodeToggle)))(t || _MatTreeNodeToggle);
      };
    })();
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _MatTreeNodeToggle,
      selectors: [["", "matTreeNodeToggle", ""]],
      inputs: {
        recursive: [InputFlags.None, "matTreeNodeToggleRecursive", "recursive"]
      },
      standalone: true,
      features: [ɵɵProvidersFeature([{
        provide: CdkTreeNodeToggle,
        useExisting: _MatTreeNodeToggle
      }]), ɵɵInheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTreeNodeToggle, [{
    type: Directive,
    args: [{
      selector: "[matTreeNodeToggle]",
      providers: [{
        provide: CdkTreeNodeToggle,
        useExisting: MatTreeNodeToggle
      }],
      inputs: [{
        name: "recursive",
        alias: "matTreeNodeToggleRecursive"
      }],
      standalone: true
    }]
  }], null, null);
})();
var MAT_TREE_DIRECTIVES = [MatNestedTreeNode, MatTreeNodeDef, MatTreeNodePadding, MatTreeNodeToggle, MatTree, MatTreeNode, MatTreeNodeOutlet];
var MatTreeModule = class _MatTreeModule {
  static {
    this.ɵfac = function MatTreeModule_Factory(t) {
      return new (t || _MatTreeModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _MatTreeModule,
      imports: [CdkTreeModule, MatCommonModule, MatNestedTreeNode, MatTreeNodeDef, MatTreeNodePadding, MatTreeNodeToggle, MatTree, MatTreeNode, MatTreeNodeOutlet],
      exports: [MatCommonModule, MatNestedTreeNode, MatTreeNodeDef, MatTreeNodePadding, MatTreeNodeToggle, MatTree, MatTreeNode, MatTreeNodeOutlet]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      imports: [CdkTreeModule, MatCommonModule, MatCommonModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTreeModule, [{
    type: NgModule,
    args: [{
      imports: [CdkTreeModule, MatCommonModule, ...MAT_TREE_DIRECTIVES],
      exports: [MatCommonModule, MAT_TREE_DIRECTIVES]
    }]
  }], null, null);
})();
var MatTreeFlattener = class {
  constructor(transformFunction, getLevel, isExpandable, getChildren) {
    this.transformFunction = transformFunction;
    this.getLevel = getLevel;
    this.isExpandable = isExpandable;
    this.getChildren = getChildren;
  }
  _flattenNode(node, level, resultNodes, parentMap) {
    const flatNode = this.transformFunction(node, level);
    resultNodes.push(flatNode);
    if (this.isExpandable(flatNode)) {
      const childrenNodes = this.getChildren(node);
      if (childrenNodes) {
        if (Array.isArray(childrenNodes)) {
          this._flattenChildren(childrenNodes, level, resultNodes, parentMap);
        } else {
          childrenNodes.pipe(take(1)).subscribe((children) => {
            this._flattenChildren(children, level, resultNodes, parentMap);
          });
        }
      }
    }
    return resultNodes;
  }
  _flattenChildren(children, level, resultNodes, parentMap) {
    children.forEach((child, index) => {
      let childParentMap = parentMap.slice();
      childParentMap.push(index != children.length - 1);
      this._flattenNode(child, level + 1, resultNodes, childParentMap);
    });
  }
  /**
   * Flatten a list of node type T to flattened version of node F.
   * Please note that type T may be nested, and the length of `structuredData` may be different
   * from that of returned list `F[]`.
   */
  flattenNodes(structuredData) {
    let resultNodes = [];
    structuredData.forEach((node) => this._flattenNode(node, 0, resultNodes, []));
    return resultNodes;
  }
  /**
   * Expand flattened node with current expansion status.
   * The returned list may have different length.
   */
  expandFlattenedNodes(nodes, treeControl) {
    let results = [];
    let currentExpand = [];
    currentExpand[0] = true;
    nodes.forEach((node) => {
      let expand = true;
      for (let i = 0; i <= this.getLevel(node); i++) {
        expand = expand && currentExpand[i];
      }
      if (expand) {
        results.push(node);
      }
      if (this.isExpandable(node)) {
        currentExpand[this.getLevel(node) + 1] = treeControl.isExpanded(node);
      }
    });
    return results;
  }
};
var MatTreeFlatDataSource = class extends DataSource {
  get data() {
    return this._data.value;
  }
  set data(value) {
    this._data.next(value);
    this._flattenedData.next(this._treeFlattener.flattenNodes(this.data));
    this._treeControl.dataNodes = this._flattenedData.value;
  }
  constructor(_treeControl, _treeFlattener, initialData) {
    super();
    this._treeControl = _treeControl;
    this._treeFlattener = _treeFlattener;
    this._flattenedData = new BehaviorSubject([]);
    this._expandedData = new BehaviorSubject([]);
    this._data = new BehaviorSubject([]);
    if (initialData) {
      this.data = initialData;
    }
  }
  connect(collectionViewer) {
    return merge(collectionViewer.viewChange, this._treeControl.expansionModel.changed, this._flattenedData).pipe(map(() => {
      this._expandedData.next(this._treeFlattener.expandFlattenedNodes(this._flattenedData.value, this._treeControl));
      return this._expandedData.value;
    }));
  }
  disconnect() {
  }
};

// node_modules/@lk/core/fesm2022/lk-core.mjs
function AppInputComponent_Conditional_0_mat_label_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-label");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.label);
  }
}
function AppInputComponent_Conditional_0_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-icon", 7);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵstyleProp("font-size", ctx_r1.prefixIconSize);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.prefixIconName);
  }
}
function AppInputComponent_Conditional_0_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-icon", 8);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵstyleProp("font-size", ctx_r1.suffixIconSize);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.suffixIconName);
  }
}
function AppInputComponent_Conditional_0_mat_error_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-error");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.errorMessage);
  }
}
function AppInputComponent_Conditional_0_mat_option_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-option", 9);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const option_r3 = ctx.$implicit;
    ɵɵproperty("value", option_r3);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", option_r3, " ");
  }
}
function AppInputComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mat-form-field", 1);
    ɵɵtemplate(1, AppInputComponent_Conditional_0_mat_label_1_Template, 2, 1, "mat-label", 2)(2, AppInputComponent_Conditional_0_Conditional_2_Template, 2, 3, "mat-icon", 3);
    ɵɵelementStart(3, "input", 4);
    ɵɵlistener("input", function AppInputComponent_Conditional_0_Template_input_input_3_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onInput($event));
    });
    ɵɵelementEnd();
    ɵɵtemplate(4, AppInputComponent_Conditional_0_Conditional_4_Template, 2, 3, "mat-icon", 5)(5, AppInputComponent_Conditional_0_mat_error_5_Template, 2, 1, "mat-error", 2);
    ɵɵelementStart(6, "mat-autocomplete", null, 0);
    ɵɵtemplate(8, AppInputComponent_Conditional_0_mat_option_8_Template, 2, 2, "mat-option", 6);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const auto_r4 = ɵɵreference(7);
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("appearance", ctx_r1.appearance);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.label);
    ɵɵadvance();
    ɵɵconditional(2, ctx_r1.prefixIconName ? 2 : -1);
    ɵɵadvance();
    ɵɵproperty("type", ctx_r1.type)("placeholder", ctx_r1.placeholder)("disabled", ctx_r1.disabled)("required", ctx_r1.required)("value", ctx_r1.value)("matAutocomplete", auto_r4);
    ɵɵadvance();
    ɵɵconditional(4, ctx_r1.suffixIconName ? 4 : -1);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.errorMessage);
    ɵɵadvance(3);
    ɵɵproperty("ngForOf", ctx_r1.searchOptions);
  }
}
function AppInputComponent_Conditional_1_mat_label_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-label");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.label);
  }
}
function AppInputComponent_Conditional_1_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-icon", 7);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵstyleProp("font-size", ctx_r1.prefixIconSize);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.prefixIconName);
  }
}
function AppInputComponent_Conditional_1_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "textarea", 12);
    ɵɵlistener("input", function AppInputComponent_Conditional_1_Conditional_3_Template_textarea_input_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onInput($event));
    });
    ɵɵtext(1, "      ");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("placeholder", ctx_r1.placeholder)("disabled", ctx_r1.disabled)("required", ctx_r1.required)("value", ctx_r1.value)("rows", ctx_r1.rows);
  }
}
function AppInputComponent_Conditional_1_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "input", 13);
    ɵɵlistener("input", function AppInputComponent_Conditional_1_Conditional_4_Template_input_input_0_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onInput($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("type", ctx_r1.type)("placeholder", ctx_r1.placeholder)("disabled", ctx_r1.disabled)("required", ctx_r1.required)("value", ctx_r1.value);
  }
}
function AppInputComponent_Conditional_1_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-icon", 8);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵstyleProp("font-size", ctx_r1.suffixIconSize);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.suffixIconName);
  }
}
function AppInputComponent_Conditional_1_mat_error_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-error");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.errorMessage);
  }
}
function AppInputComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-form-field", 10);
    ɵɵtemplate(1, AppInputComponent_Conditional_1_mat_label_1_Template, 2, 1, "mat-label", 2)(2, AppInputComponent_Conditional_1_Conditional_2_Template, 2, 3, "mat-icon", 3)(3, AppInputComponent_Conditional_1_Conditional_3_Template, 2, 5, "textarea", 11)(4, AppInputComponent_Conditional_1_Conditional_4_Template, 1, 5)(5, AppInputComponent_Conditional_1_Conditional_5_Template, 2, 3, "mat-icon", 5)(6, AppInputComponent_Conditional_1_mat_error_6_Template, 2, 1, "mat-error", 2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("appearance", ctx_r1.appearance);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.label);
    ɵɵadvance();
    ɵɵconditional(2, ctx_r1.prefixIconName ? 2 : -1);
    ɵɵadvance();
    ɵɵconditional(3, ctx_r1.multiline ? 3 : 4);
    ɵɵadvance(2);
    ɵɵconditional(5, ctx_r1.suffixIconName ? 5 : -1);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.errorMessage);
  }
}
var _forTrack0 = ($index, $item) => $item.value;
function AppSelectboxComponent_mat_label_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-label");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.label);
  }
}
function AppSelectboxComponent_For_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-option", 2);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const option_r2 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("value", ctx_r0.getValue(option_r2));
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.getDisplay(option_r2));
  }
}
var _c07 = (a0, a1) => ({
  "icon-blink": a0,
  "font-bold": a1
});
function IconComponent_Conditional_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "i", 2);
    ɵɵlistener("click", function IconComponent_Conditional_0_Conditional_1_Template_i_click_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onClick($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassMap("icomoon " + ctx_r1.icomoonClass + " " + ctx_r1.class);
    ɵɵstyleProp("font-size", ctx_r1.size, "px")("color", ctx_r1.color);
  }
}
function IconComponent_Conditional_0_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mat-icon", 3);
    ɵɵlistener("click", function IconComponent_Conditional_0_Conditional_2_Template_mat_icon_click_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onClick($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵstyleProp("font-size", ctx_r1.size, "px")("color", ctx_r1.color);
    ɵɵproperty("fontIcon", ctx_r1.fontIcon)("ngClass", "material-icon " + ctx_r1.class);
  }
}
function IconComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 0);
    ɵɵtemplate(1, IconComponent_Conditional_0_Conditional_1_Template, 1, 6, "i", 1)(2, IconComponent_Conditional_0_Conditional_2_Template, 1, 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵconditional(1, ctx_r1.iconType === "icomoon" ? 1 : 2);
  }
}
function IconComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 4);
    ɵɵlistener("click", function IconComponent_Conditional_1_Template_div_click_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onClick($event));
    });
    ɵɵelementStart(1, "span", 5);
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap(ɵɵpureFunction2(5, _c07, ctx_r1.isBlink, ctx_r1.fontBold));
    ɵɵadvance();
    ɵɵstyleProp("color", ctx_r1.color);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.counter);
  }
}
function IconComponent_Conditional_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "i", 2);
    ɵɵlistener("click", function IconComponent_Conditional_2_Conditional_0_Template_i_click_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onClick($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassMap("icomoon icon-" + ctx_r1.fontIcon + " " + ctx_r1.class);
    ɵɵstyleProp("font-size", ctx_r1.size, "px")("color", ctx_r1.color);
  }
}
function IconComponent_Conditional_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mat-icon", 6);
    ɵɵlistener("click", function IconComponent_Conditional_2_Conditional_1_Template_mat_icon_click_0_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onClick($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵstyleProp("font-size", ctx_r1.size, "px")("color", ctx_r1.color === "primary" ? "var(--primary-color)" : ctx_r1.color);
    ɵɵproperty("fontIcon", ctx_r1.fontIcon)("ngClass", "material-icon " + ctx_r1.class)("color", ctx_r1.color === "primary" ? "var(--primary-color)" : ctx_r1.color);
  }
}
function IconComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, IconComponent_Conditional_2_Conditional_0_Template, 1, 6, "i", 1)(1, IconComponent_Conditional_2_Conditional_1_Template, 1, 7);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵconditional(0, ctx_r1.iconType === "icomoon" ? 0 : 1);
  }
}
var _c113 = ["*"];
function AppButtonComponent_ng_template_0_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "app-icon", 9);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("fontIcon", ctx_r0.fontIcon);
  }
}
function AppButtonComponent_ng_template_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.text);
  }
}
function AppButtonComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, AppButtonComponent_ng_template_0_Conditional_0_Template, 1, 1, "app-icon", 9)(1, AppButtonComponent_ng_template_0_Conditional_1_Template, 2, 1, "span");
    ɵɵprojection(2);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵconditional(0, ctx_r0.appearance === "icon" ? 0 : -1);
    ɵɵadvance();
    ɵɵconditional(1, ctx_r0.text ? 1 : -1);
  }
}
function AppButtonComponent_button_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function AppButtonComponent_button_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 10);
    ɵɵlistener("click", function AppButtonComponent_button_3_Template_button_click_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onClick($event));
    });
    ɵɵtemplate(1, AppButtonComponent_button_3_ng_container_1_Template, 1, 0, "ng-container", 11);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    const btnContent_r3 = ɵɵreference(1);
    ɵɵproperty("color", ctx_r0.color)("type", ctx_r0.type)("disabled", ctx_r0.disabled)("ngClass", ctx_r0.class);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", btnContent_r3);
  }
}
function AppButtonComponent_button_4_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function AppButtonComponent_button_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 12);
    ɵɵlistener("click", function AppButtonComponent_button_4_Template_button_click_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onClick($event));
    });
    ɵɵtemplate(1, AppButtonComponent_button_4_ng_container_1_Template, 1, 0, "ng-container", 11);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    const btnContent_r3 = ɵɵreference(1);
    ɵɵproperty("color", ctx_r0.color)("type", ctx_r0.type)("disabled", ctx_r0.disabled)("ngClass", ctx_r0.class);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", btnContent_r3);
  }
}
function AppButtonComponent_button_5_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function AppButtonComponent_button_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 13);
    ɵɵlistener("click", function AppButtonComponent_button_5_Template_button_click_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onClick($event));
    });
    ɵɵtemplate(1, AppButtonComponent_button_5_ng_container_1_Template, 1, 0, "ng-container", 11);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    const btnContent_r3 = ɵɵreference(1);
    ɵɵproperty("color", ctx_r0.color)("type", ctx_r0.type)("disabled", ctx_r0.disabled)("ngClass", ctx_r0.class);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", btnContent_r3);
  }
}
function AppButtonComponent_button_6_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function AppButtonComponent_button_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 14);
    ɵɵlistener("click", function AppButtonComponent_button_6_Template_button_click_0_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onClick($event));
    });
    ɵɵtemplate(1, AppButtonComponent_button_6_ng_container_1_Template, 1, 0, "ng-container", 11);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    const btnContent_r3 = ɵɵreference(1);
    ɵɵproperty("color", ctx_r0.color)("type", ctx_r0.type)("disabled", ctx_r0.disabled)("ngClass", ctx_r0.class);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", btnContent_r3);
  }
}
function AppButtonComponent_button_7_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function AppButtonComponent_button_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 15);
    ɵɵlistener("click", function AppButtonComponent_button_7_Template_button_click_0_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onClick($event));
    });
    ɵɵtemplate(1, AppButtonComponent_button_7_ng_container_1_Template, 1, 0, "ng-container", 11);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    const btnContent_r3 = ɵɵreference(1);
    ɵɵproperty("color", ctx_r0.color)("type", ctx_r0.type)("disabled", ctx_r0.disabled)("ngClass", ctx_r0.class);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", btnContent_r3);
  }
}
function AppButtonComponent_button_8_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function AppButtonComponent_button_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 16);
    ɵɵlistener("click", function AppButtonComponent_button_8_Template_button_click_0_listener($event) {
      ɵɵrestoreView(_r8);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onClick($event));
    });
    ɵɵtemplate(1, AppButtonComponent_button_8_ng_container_1_Template, 1, 0, "ng-container", 11);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    const btnContent_r3 = ɵɵreference(1);
    ɵɵproperty("color", ctx_r0.color)("type", ctx_r0.type)("disabled", ctx_r0.disabled)("ngClass", ctx_r0.class);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", btnContent_r3);
  }
}
function AppButtonComponent_button_9_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function AppButtonComponent_button_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 17);
    ɵɵlistener("click", function AppButtonComponent_button_9_Template_button_click_0_listener($event) {
      ɵɵrestoreView(_r9);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onClick($event));
    });
    ɵɵtemplate(1, AppButtonComponent_button_9_ng_container_1_Template, 1, 0, "ng-container", 11);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    const btnContent_r3 = ɵɵreference(1);
    ɵɵproperty("color", ctx_r0.color)("type", ctx_r0.type)("disabled", ctx_r0.disabled)("ngClass", ctx_r0.class);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", btnContent_r3);
  }
}
function DatePickerComponent_mat_label_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-label");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.label);
  }
}
function DatePickerComponent_mat_error_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-error");
    ɵɵtext(1, " This field is required ");
    ɵɵelementEnd();
  }
}
function FilterComponent_div_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 24);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.getActiveFiltersCount(), " applied ");
  }
}
function FilterComponent_li_14_div_8_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 33);
    ɵɵlistener("click", function FilterComponent_li_14_div_8_button_1_Template_button_click_0_listener() {
      const filter_r5 = ɵɵrestoreView(_r4).$implicit;
      const field_r3 = ɵɵnextContext(2).$implicit;
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.removeFieldFilter(field_r3.value, filter_r5));
    });
    ɵɵtext(1);
    ɵɵelementStart(2, "span", 34);
    ɵɵtext(3, "×");
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const filter_r5 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.getFilterDisplayText(filter_r5), " ");
  }
}
function FilterComponent_li_14_div_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 31);
    ɵɵtemplate(1, FilterComponent_li_14_div_8_button_1_Template, 4, 1, "button", 32);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const field_r3 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.getFieldFilters(field_r3.value));
  }
}
function FilterComponent_li_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "li", 25)(1, "button", 26);
    ɵɵlistener("click", function FilterComponent_li_14_Template_button_click_1_listener() {
      const field_r3 = ɵɵrestoreView(_r2).$implicit;
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.selectField(field_r3));
    });
    ɵɵelementStart(2, "span", 27);
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵelementStart(4, "span", 28);
    ɵɵtext(5);
    ɵɵelementEnd();
    ɵɵelementStart(6, "span", 29);
    ɵɵtext(7, "›");
    ɵɵelementEnd()();
    ɵɵtemplate(8, FilterComponent_li_14_div_8_Template, 2, 1, "div", 30);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const field_r3 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵclassProp("active", ctx_r0.selectedField === field_r3.value);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.getFieldIcon(field_r3.inputType));
    ɵɵadvance(2);
    ɵɵtextInterpolate(field_r3.label);
    ɵɵadvance(3);
    ɵɵproperty("ngIf", ctx_r0.getFieldFilters(field_r3.value).length > 0);
  }
}
function FilterComponent_div_16_div_7_button_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 44);
    ɵɵlistener("click", function FilterComponent_div_16_div_7_button_4_Template_button_click_0_listener() {
      const value_r8 = ɵɵrestoreView(_r7).$implicit;
      const fieldName_r9 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.removeFieldFilter(fieldName_r9, value_r8));
    });
    ɵɵtext(1);
    ɵɵelementStart(2, "span", 45);
    ɵɵtext(3, "×");
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const value_r8 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.getFilterDisplayText(value_r8), " ");
  }
}
function FilterComponent_div_16_div_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 40)(1, "div", 41);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementStart(3, "div", 42);
    ɵɵtemplate(4, FilterComponent_div_16_div_7_button_4_Template, 4, 1, "button", 43);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const fieldName_r9 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.getFieldLabel(fieldName_r9));
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r0.getFieldFilters(fieldName_r9));
  }
}
function FilterComponent_div_16_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 35)(1, "div", 36)(2, "h3");
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵelementStart(4, "button", 37);
    ɵɵlistener("click", function FilterComponent_div_16_Template_button_click_4_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.clearAllFilters());
    });
    ɵɵtext(5, "Clear All");
    ɵɵelementEnd()();
    ɵɵelementStart(6, "div", 38);
    ɵɵtemplate(7, FilterComponent_div_16_div_7_Template, 5, 2, "div", 39);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(3);
    ɵɵtextInterpolate1("Active Filters (", ctx_r0.getActiveFiltersCount(), ")");
    ɵɵadvance(4);
    ɵɵproperty("ngForOf", ctx_r0.getActiveFilterFields());
  }
}
function FilterComponent_div_17_div_6_label_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "label", 54)(1, "input", 55);
    ɵɵlistener("change", function FilterComponent_div_17_div_6_label_4_Template_input_change_1_listener() {
      const option_r11 = ɵɵrestoreView(_r10).$implicit;
      const ctx_r0 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r0.toggleOption(ctx_r0.selectedFieldObj.value, option_r11));
    });
    ɵɵelementEnd();
    ɵɵelement(2, "span", 56);
    ɵɵelementStart(3, "span", 57);
    ɵɵtext(4);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const option_r11 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵclassProp("selected", ctx_r0.isOptionSelected(ctx_r0.selectedFieldObj.value, option_r11));
    ɵɵadvance();
    ɵɵproperty("checked", ctx_r0.isOptionSelected(ctx_r0.selectedFieldObj.value, option_r11));
    ɵɵadvance(3);
    ɵɵtextInterpolate(option_r11);
  }
}
function FilterComponent_div_17_div_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 50)(1, "div", 51);
    ɵɵtext(2, "Available Options");
    ɵɵelementEnd();
    ɵɵelementStart(3, "div", 52);
    ɵɵtemplate(4, FilterComponent_div_17_div_6_label_4_Template, 5, 4, "label", 53);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance(4);
    ɵɵproperty("ngForOf", ctx_r0.getValues(ctx_r0.selectedFieldObj.value));
  }
}
function FilterComponent_div_17_div_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 50)(1, "div", 51);
    ɵɵtext(2, "Select Value");
    ɵɵelementEnd();
    ɵɵelementStart(3, "div", 58)(4, "label", 59)(5, "input", 60);
    ɵɵlistener("change", function FilterComponent_div_17_div_7_Template_input_change_5_listener() {
      ɵɵrestoreView(_r12);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.setBooleanValue(ctx_r0.selectedFieldObj.value, true));
    });
    ɵɵelementEnd();
    ɵɵelement(6, "span", 61);
    ɵɵelementStart(7, "span", 57);
    ɵɵtext(8, "True");
    ɵɵelementEnd()();
    ɵɵelementStart(9, "label", 59)(10, "input", 60);
    ɵɵlistener("change", function FilterComponent_div_17_div_7_Template_input_change_10_listener() {
      ɵɵrestoreView(_r12);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.setBooleanValue(ctx_r0.selectedFieldObj.value, false));
    });
    ɵɵelementEnd();
    ɵɵelement(11, "span", 61);
    ɵɵelementStart(12, "span", 57);
    ɵɵtext(13, "False");
    ɵɵelementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance(4);
    ɵɵclassProp("selected", ctx_r0.isBooleanSelected(ctx_r0.selectedFieldObj.value, true));
    ɵɵadvance();
    ɵɵproperty("name", "boolean-" + ctx_r0.selectedFieldObj.value)("checked", ctx_r0.isBooleanSelected(ctx_r0.selectedFieldObj.value, true));
    ɵɵadvance(4);
    ɵɵclassProp("selected", ctx_r0.isBooleanSelected(ctx_r0.selectedFieldObj.value, false));
    ɵɵadvance();
    ɵɵproperty("name", "boolean-" + ctx_r0.selectedFieldObj.value)("checked", ctx_r0.isBooleanSelected(ctx_r0.selectedFieldObj.value, false));
  }
}
function FilterComponent_div_17_div_8_input_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r13 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "input", 69);
    ɵɵlistener("input", function FilterComponent_div_17_div_8_input_7_Template_input_input_0_listener($event) {
      ɵɵrestoreView(_r13);
      const ctx_r0 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r0.setRangeMinValue(ctx_r0.selectedFieldObj.value, $event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("id", "min-" + ctx_r0.selectedFieldObj.value)("value", ctx_r0.getRangeValue(ctx_r0.selectedFieldObj.value, "min"));
  }
}
function FilterComponent_div_17_div_8_input_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r14 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "input", 70);
    ɵɵlistener("input", function FilterComponent_div_17_div_8_input_8_Template_input_input_0_listener($event) {
      ɵɵrestoreView(_r14);
      const ctx_r0 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r0.setRangeMinValue(ctx_r0.selectedFieldObj.value, $event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("id", "min-" + ctx_r0.selectedFieldObj.value)("value", ctx_r0.getRangeValue(ctx_r0.selectedFieldObj.value, "min"));
  }
}
function FilterComponent_div_17_div_8_input_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r15 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "input", 71);
    ɵɵlistener("input", function FilterComponent_div_17_div_8_input_14_Template_input_input_0_listener($event) {
      ɵɵrestoreView(_r15);
      const ctx_r0 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r0.setRangeMaxValue(ctx_r0.selectedFieldObj.value, $event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("id", "max-" + ctx_r0.selectedFieldObj.value)("value", ctx_r0.getRangeValue(ctx_r0.selectedFieldObj.value, "max"));
  }
}
function FilterComponent_div_17_div_8_input_15_Template(rf, ctx) {
  if (rf & 1) {
    const _r16 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "input", 70);
    ɵɵlistener("input", function FilterComponent_div_17_div_8_input_15_Template_input_input_0_listener($event) {
      ɵɵrestoreView(_r16);
      const ctx_r0 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r0.setRangeMaxValue(ctx_r0.selectedFieldObj.value, $event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("id", "max-" + ctx_r0.selectedFieldObj.value)("value", ctx_r0.getRangeValue(ctx_r0.selectedFieldObj.value, "max"));
  }
}
function FilterComponent_div_17_div_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 50)(1, "div", 51);
    ɵɵtext(2, "Set Range");
    ɵɵelementEnd();
    ɵɵelementStart(3, "div", 62)(4, "div", 63)(5, "label", 64);
    ɵɵtext(6);
    ɵɵelementEnd();
    ɵɵtemplate(7, FilterComponent_div_17_div_8_input_7_Template, 1, 2, "input", 65)(8, FilterComponent_div_17_div_8_input_8_Template, 1, 2, "input", 66);
    ɵɵelementEnd();
    ɵɵelementStart(9, "div", 67);
    ɵɵtext(10, "to");
    ɵɵelementEnd();
    ɵɵelementStart(11, "div", 63)(12, "label", 64);
    ɵɵtext(13);
    ɵɵelementEnd();
    ɵɵtemplate(14, FilterComponent_div_17_div_8_input_14_Template, 1, 2, "input", 68)(15, FilterComponent_div_17_div_8_input_15_Template, 1, 2, "input", 66);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance(5);
    ɵɵproperty("for", "min-" + ctx_r0.selectedFieldObj.value);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.selectedFieldObj.inputType === "date" ? "From Date" : "Minimum Value", " ");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.selectedFieldObj.inputType === "number");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.selectedFieldObj.inputType === "date");
    ɵɵadvance(4);
    ɵɵproperty("for", "max-" + ctx_r0.selectedFieldObj.value);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.selectedFieldObj.inputType === "date" ? "To Date" : "Maximum Value", " ");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.selectedFieldObj.inputType === "number");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.selectedFieldObj.inputType === "date");
  }
}
function FilterComponent_div_17_div_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r17 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 50)(1, "div", 51);
    ɵɵtext(2, "Search Text");
    ɵɵelementEnd();
    ɵɵelementStart(3, "div", 72)(4, "label", 73);
    ɵɵtext(5);
    ɵɵelementEnd();
    ɵɵelementStart(6, "input", 74);
    ɵɵlistener("input", function FilterComponent_div_17_div_9_Template_input_input_6_listener($event) {
      ɵɵrestoreView(_r17);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.setTextValue(ctx_r0.selectedFieldObj.value, $event));
    });
    ɵɵelementEnd();
    ɵɵelementStart(7, "small", 75);
    ɵɵtext(8, "Search will match any part of the text");
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance(4);
    ɵɵproperty("for", "text-" + ctx_r0.selectedFieldObj.value);
    ɵɵadvance();
    ɵɵtextInterpolate1(" Enter search term for ", ctx_r0.selectedFieldObj.label.toLowerCase(), " ");
    ɵɵadvance();
    ɵɵproperty("id", "text-" + ctx_r0.selectedFieldObj.value)("value", ctx_r0.getTextValue(ctx_r0.selectedFieldObj.value));
  }
}
function FilterComponent_div_17_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 46)(1, "div", 47)(2, "h3");
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵelementStart(4, "p", 48);
    ɵɵtext(5);
    ɵɵelementEnd()();
    ɵɵtemplate(6, FilterComponent_div_17_div_6_Template, 5, 1, "div", 49)(7, FilterComponent_div_17_div_7_Template, 14, 8, "div", 49)(8, FilterComponent_div_17_div_8_Template, 16, 8, "div", 49)(9, FilterComponent_div_17_div_9_Template, 9, 4, "div", 49);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(3);
    ɵɵtextInterpolate(ctx_r0.selectedFieldObj.label);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.getFieldDescription(ctx_r0.selectedFieldObj));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.selectedFieldObj.inputType === "select");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.selectedFieldObj.inputType === "boolean");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.selectedFieldObj.inputType === "number" || ctx_r0.selectedFieldObj.inputType === "date");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.selectedFieldObj.inputType === "input");
  }
}
function FilterComponent_div_18_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 76)(1, "div", 77)(2, "div", 78);
    ɵɵtext(3, "🎯");
    ɵɵelementEnd();
    ɵɵelementStart(4, "h3");
    ɵɵtext(5, "Select a Filter");
    ɵɵelementEnd();
    ɵɵelementStart(6, "p");
    ɵɵtext(7, "Choose a field from the sidebar to configure your filters. You can apply multiple filters to narrow down your results.");
    ɵɵelementEnd()()();
  }
}
function FilterComponent_div_21_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 79)(1, "span", 80);
    ɵɵtext(2, "Results:");
    ɵɵelementEnd();
    ɵɵelementStart(3, "span", 81);
    ɵɵtext(4);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(4);
    ɵɵtextInterpolate(ctx_r0.getEstimatedResults());
  }
}
function FilterComponent_div_22_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 82);
    ɵɵtext(1, " No filters applied - showing all results ");
    ɵɵelementEnd();
  }
}
function FilterComponent_span_30_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 83);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1("(", ctx_r0.getActiveFiltersCount(), ")");
  }
}
function GridMenuRendererComponent_button_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 4);
    ɵɵlistener("click", function GridMenuRendererComponent_button_4_Template_button_click_0_listener() {
      const action_r3 = ɵɵrestoreView(_r2).$implicit;
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.onActionClick(action_r3, ctx_r3.params.data));
    });
    ɵɵelement(1, "app-icon", 5);
    ɵɵelementStart(2, "span");
    ɵɵtext(3);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const action_r3 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("fontIcon", action_r3.icon);
    ɵɵadvance(2);
    ɵɵtextInterpolate(action_r3.title);
  }
}
function ConfirmationDialogWrapperComponent_app_button_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "app-button", 9);
    ɵɵlistener("btnClick", function ConfirmationDialogWrapperComponent_app_button_10_Template_app_button_btnClick_0_listener($event) {
      const action_r2 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onFooterActionClick(action_r2.id, $event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const action_r2 = ctx.$implicit;
    ɵɵclassMap(action_r2.class || "");
    ɵɵproperty("text", action_r2.text)("color", action_r2.color || "primary")("appearance", action_r2.appearance || "flat")("type", "button");
  }
}
function DialogboxContentComponent_div_0_app_icon_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "app-icon", 8);
    ɵɵlistener("iconClick", function DialogboxContentComponent_div_0_app_icon_3_Template_app_icon_iconClick_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.close());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵproperty("size", 22);
  }
}
function DialogboxContentComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 5)(1, "div", 6);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵtemplate(3, DialogboxContentComponent_div_0_app_icon_3_Template, 1, 1, "app-icon", 7);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("confirmation-header", ctx_r1.isConfirmationDialog());
    ɵɵadvance();
    ɵɵclassProp("centered-title", ctx_r1.isConfirmationDialog());
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.data == null ? null : ctx_r1.data.title);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.isConfirmationDialog());
  }
}
function DialogboxContentComponent_ng_container_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function DialogboxContentComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, DialogboxContentComponent_ng_container_2_ng_container_1_Template, 1, 0, "ng-container", 9);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngComponentOutlet", ctx_r1.data.component)("ngComponentOutletInjector", ctx_r1.componentInjector);
  }
}
function DialogboxContentComponent_ng_container_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.data.content, " ");
  }
}
function DialogboxContentComponent_ng_container_3_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
function DialogboxContentComponent_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, DialogboxContentComponent_ng_container_3_ng_container_1_Template, 2, 1, "ng-container", 10)(2, DialogboxContentComponent_ng_container_3_ng_template_2_Template, 1, 0, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const projected_r3 = ɵɵreference(3);
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.data == null ? null : ctx_r1.data.content)("ngIfElse", projected_r3);
  }
}
function DialogboxContentComponent_div_4_app_button_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "app-button", 14);
    ɵɵlistener("btnClick", function DialogboxContentComponent_div_4_app_button_2_Template_app_button_btnClick_0_listener($event) {
      const action_r5 = ɵɵrestoreView(_r4).$implicit;
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onFooterActionClick(action_r5.id, $event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const action_r5 = ctx.$implicit;
    ɵɵclassMap(action_r5.class || "");
    ɵɵproperty("text", action_r5.text)("color", action_r5.color || "primary")("appearance", action_r5.appearance || "raised")("disabled", action_r5.disabled || false)("fontIcon", action_r5.fontIcon || "");
  }
}
function DialogboxContentComponent_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 11)(1, "div", 12);
    ɵɵtemplate(2, DialogboxContentComponent_div_4_app_button_2_Template, 1, 7, "app-button", 13);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r1.data.footerActions)("ngForTrackBy", ctx_r1.trackByActionId);
  }
}
var _c211 = ".custom-dialog-panel .mat-dialog-container{border-radius:16px;padding:0;min-width:400px;max-width:90vw;box-shadow:0 8px 32px #0000002e;background:#fff;position:relative;margin:auto}  .cdk-overlay-pane.custom-dialog-panel{display:flex!important;align-items:center!important;justify-content:center!important}.dialogbox-header[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:space-between;padding:.8em .7em .7em;height:3em;border-bottom:1px solid #f0f0f0;font-size:1.2rem;font-weight:600;background:#fff;border-top-left-radius:16px;border-top-right-radius:16px}.dialogbox-header.confirmation-header[_ngcontent-%COMP%]{justify-content:center;padding:20px 24px}.dialogbox-title[_ngcontent-%COMP%]{flex:1;color:#222;font-size:1.15rem;font-weight:600}.dialogbox-title.centered-title[_ngcontent-%COMP%]{flex:none;text-align:center;color:#1f2937}.close-icon[_ngcontent-%COMP%]{cursor:pointer;color:#888;transition:color .2s;margin-left:16px}.close-icon[_ngcontent-%COMP%]:hover{color:#18b6b2}.dialogbox-content[_ngcontent-%COMP%]{padding:1em;height:calc(100% - 6.5em);background:var(--surface-color);border-bottom-left-radius:16px;border-bottom-right-radius:16px;max-height:75vh;overflow:scroll}.dialogbox-content.no-header[_ngcontent-%COMP%]{padding-top:16px;padding-bottom:16px;border-top-left-radius:16px;border-top-right-radius:16px}.dialogbox-content.has-footer[_ngcontent-%COMP%]{border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom:1px solid #f0f0f0}.dialogbox-content[_ngcontent-%COMP%]   app-filter[_ngcontent-%COMP%]{display:block;width:100%;height:600px;max-height:70vh}.dialogbox-content[_ngcontent-%COMP%]   app-filter[_ngcontent-%COMP%]   .filter-container[_ngcontent-%COMP%]{height:100%;max-height:100%}.dialogbox-footer[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:flex-end;padding:1em 1.2em;height:3.5em;background:#fff;border-bottom-left-radius:16px;border-bottom-right-radius:16px;border-top:1px solid #f0f0f0;gap:0}.dialogbox-footer[_ngcontent-%COMP%]:has( + .dialogbox-content.no-header)[_ngcontent-%COMP%], .no-header[_ngcontent-%COMP%] ~ .dialogbox-footer[_ngcontent-%COMP%]{padding-top:12px;padding-bottom:12px}.dialogbox-footer[_ngcontent-%COMP%]   .footer-actions[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:flex-end;gap:0;width:100%}.dialogbox-footer[_ngcontent-%COMP%]   .footer-actions[_ngcontent-%COMP%]   app-button[_ngcontent-%COMP%]{position:relative;margin:0}.dialogbox-footer[_ngcontent-%COMP%]   .footer-actions[_ngcontent-%COMP%]   app-button[_ngcontent-%COMP%]:not(:last-child){margin-right:0;padding-right:12px}.dialogbox-footer[_ngcontent-%COMP%]   .footer-actions[_ngcontent-%COMP%]   app-button[_ngcontent-%COMP%]:not(:first-child){padding-left:12px;border-left:1px solid #e5e7eb}";
var _c34 = (a0) => ({
  $implicit: a0
});
function GridComponent_div_1_div_4_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 20)(1, "span", 21);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementStart(3, "span", 22);
    ɵɵtext(4);
    ɵɵelementEnd();
    ɵɵelementStart(5, "button", 23);
    ɵɵlistener("click", function GridComponent_div_1_div_4_div_1_Template_button_click_5_listener() {
      const chip_r3 = ɵɵrestoreView(_r2).$implicit;
      const ctx_r3 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r3.removeFilterChip(chip_r3.field));
    });
    ɵɵtext(6, "×");
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const chip_r3 = ctx.$implicit;
    ɵɵadvance(2);
    ɵɵtextInterpolate1("", chip_r3.label, ":");
    ɵɵadvance(2);
    ɵɵtextInterpolate(chip_r3.value);
  }
}
function GridComponent_div_1_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 18);
    ɵɵtemplate(1, GridComponent_div_1_div_4_div_1_Template, 7, 2, "div", 19);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r3.activeFilterChips);
  }
}
function GridComponent_div_1_ng_container_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function GridComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 7)(1, "div", 8)(2, "span", 9);
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵtemplate(4, GridComponent_div_1_div_4_Template, 2, 1, "div", 10);
    ɵɵelementEnd();
    ɵɵelementStart(5, "div", 11)(6, "div", 12)(7, "app-input", 13);
    ɵɵlistener("valueChange", function GridComponent_div_1_Template_app_input_valueChange_7_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.onSearchChange($event));
    });
    ɵɵelementEnd()()();
    ɵɵelementStart(8, "div", 14)(9, "div", 15);
    ɵɵtemplate(10, GridComponent_div_1_ng_container_10_Template, 1, 0, "ng-container", 16);
    ɵɵelementStart(11, "button", 17);
    ɵɵlistener("click", function GridComponent_div_1_Template_button_click_11_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.onFilterClick());
    });
    ɵɵelementStart(12, "mat-icon");
    ɵɵtext(13, "tune");
    ɵɵelementEnd()()()()();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵadvance(3);
    ɵɵtextInterpolate2("Displaying ", ctx_r3.displayedRows, " of ", ctx_r3.totalRows, "");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r3.activeFilterChips.length > 0);
    ɵɵadvance(3);
    ɵɵproperty("placeholder", ctx_r3.searchPlaceholder)("value", ctx_r3.searchText)("prefixIconName", "search")("search", true);
    ɵɵadvance(3);
    ɵɵproperty("ngTemplateOutlet", ctx_r3.rightTooltemplateRef);
    ɵɵadvance();
    ɵɵclassProp("active", ctx_r3.activeFiltersCount > 0);
  }
}
function GridComponent_ag_grid_angular_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "ag-grid-angular", 24);
    ɵɵlistener("gridReady", function GridComponent_ag_grid_angular_4_Template_ag_grid_angular_gridReady_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.onGridReady($event));
    })("modelUpdated", function GridComponent_ag_grid_angular_4_Template_ag_grid_angular_modelUpdated_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.onModelUpdated($event));
    })("rowClicked", function GridComponent_ag_grid_angular_4_Template_ag_grid_angular_rowClicked_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.onRowClicked($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵclassMap(ctx_r3.class);
    ɵɵstyleProp("width", ctx_r3.width)("height", "100%");
    ɵɵclassProp("has-row-selection", ctx_r3.gridOptions.rowSelection);
    ɵɵproperty("rowData", ctx_r3.filteredRowData)("columnDefs", ctx_r3.processedColumnDefs)("gridOptions", ctx_r3.gridOptions)("domLayout", ctx_r3.domLayout)("animateRows", ctx_r3.animateRows);
  }
}
function GridComponent_div_5_ng_container_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function GridComponent_div_5_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, GridComponent_div_5_ng_container_1_ng_container_1_Template, 1, 0, "ng-container", 27);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r6 = ctx.$implicit;
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r3.cardTemplate)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c34, item_r6));
  }
}
function GridComponent_div_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 25);
    ɵɵtemplate(1, GridComponent_div_5_ng_container_1_Template, 2, 4, "ng-container", 26);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r3.filteredRowData);
  }
}
function GridComponent_div_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 28);
    ɵɵelement(1, "div", 29);
    ɵɵelementStart(2, "span");
    ɵɵtext(3, "Loading grid...");
    ɵɵelementEnd()();
  }
}
var _c42 = (a0, a1) => ({
  $implicit: a0,
  label: a1
});
function CheckboxComponent_Conditional_1_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function CheckboxComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, CheckboxComponent_Conditional_1_ng_container_0_Template, 1, 0, "ng-container", 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.labelTemplateRef)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c42, ctx_r0.label, ctx_r0.label));
  }
}
function CheckboxComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵtextInterpolate1(" ", ctx_r0.label, " ");
  }
}
function CalendarComponent_div_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 19)(1, "div", 20);
    ɵɵelement(2, "div", 21);
    ɵɵelementStart(3, "span", 22);
    ɵɵtext(4, "Available");
    ɵɵelementEnd()();
    ɵɵelementStart(5, "div", 20);
    ɵɵelement(6, "div", 23);
    ɵɵelementStart(7, "span", 22);
    ɵɵtext(8, "Booked");
    ɵɵelementEnd()()();
  }
}
function CalendarComponent_div_14_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 24);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const day_r1 = ctx.$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(day_r1);
  }
}
function CalendarComponent_div_16_div_1_div_3_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 32);
  }
  if (rf & 2) {
    const event_r5 = ctx.$implicit;
    const ctx_r3 = ɵɵnextContext(4);
    ɵɵclassMap("event-dot " + (event_r5.type || "other"));
    ɵɵstyleProp("background-color", ctx_r3.getEventColor(event_r5).primary);
  }
}
function CalendarComponent_div_16_div_1_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 30);
    ɵɵtemplate(1, CalendarComponent_div_16_div_1_div_3_div_1_Template, 1, 4, "div", 31);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const date_r3 = ɵɵnextContext().$implicit;
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r3.getEventsForDate(date_r3).slice(0, 3));
  }
}
function CalendarComponent_div_16_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 27);
    ɵɵlistener("click", function CalendarComponent_div_16_div_1_Template_div_click_0_listener() {
      const date_r3 = ɵɵrestoreView(_r2).$implicit;
      const ctx_r3 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r3.allowDateSelection ? ctx_r3.onDateSelected({
        date: date_r3
      }) : null);
    });
    ɵɵelementStart(1, "div", 28);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵtemplate(3, CalendarComponent_div_16_div_1_div_3_Template, 2, 1, "div", 29);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const date_r3 = ctx.$implicit;
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵclassProp("today", ctx_r3.isToday(date_r3))("selected", ctx_r3.isSelected(date_r3))("other-month", !ctx_r3.isCurrentMonth(date_r3))("clickable", ctx_r3.allowDateSelection);
    ɵɵadvance(2);
    ɵɵtextInterpolate(date_r3.getDate());
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r3.showEventIndicators && ctx_r3.getEventsForDate(date_r3).length > 0);
  }
}
function CalendarComponent_div_16_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 25);
    ɵɵtemplate(1, CalendarComponent_div_16_div_1_Template, 4, 10, "div", 26);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const week_r6 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("ngForOf", week_r6);
  }
}
function CalendarComponent_div_17_div_5_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 44);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const event_r8 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(event_r8.description);
  }
}
function CalendarComponent_div_17_div_5_span_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1, "All-day");
    ɵɵelementEnd();
  }
}
function CalendarComponent_div_17_div_5_span_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const event_r8 = ɵɵnextContext().$implicit;
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r3.formatEventTime(event_r8));
  }
}
function CalendarComponent_div_17_div_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 38);
    ɵɵlistener("click", function CalendarComponent_div_17_div_5_Template_div_click_0_listener() {
      const event_r8 = ɵɵrestoreView(_r7).$implicit;
      const ctx_r3 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r3.onEventClicked({
        event: {
          meta: {
            originalEvent: event_r8
          }
        }
      }));
    });
    ɵɵelementStart(1, "div", 39)(2, "div", 40);
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵtemplate(4, CalendarComponent_div_17_div_5_div_4_Template, 2, 1, "div", 41);
    ɵɵelementStart(5, "div", 42);
    ɵɵtemplate(6, CalendarComponent_div_17_div_5_span_6_Template, 2, 0, "span", 43)(7, CalendarComponent_div_17_div_5_span_7_Template, 2, 1, "span", 43);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const event_r8 = ctx.$implicit;
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵstyleProp("border-left-color", ctx_r3.getEventColor(event_r8).primary);
    ɵɵadvance(3);
    ɵɵtextInterpolate(event_r8.title);
    ɵɵadvance();
    ɵɵproperty("ngIf", event_r8.description);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", event_r8.allDay);
    ɵɵadvance();
    ɵɵproperty("ngIf", !event_r8.allDay);
  }
}
function CalendarComponent_div_17_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 33)(1, "div", 34)(2, "h3", 35);
    ɵɵtext(3);
    ɵɵelementEnd()();
    ɵɵelementStart(4, "div", 36);
    ɵɵtemplate(5, CalendarComponent_div_17_div_5_Template, 8, 6, "div", 37);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵadvance(3);
    ɵɵtextInterpolate(ctx_r3.formatSelectedDate());
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r3.getEventsForDate(ctx_r3.selectedDate));
  }
}
function CalendarComponent_div_18_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 45)(1, "p");
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate1("No events for ", ctx_r3.formatSelectedDate(), "");
  }
}
function CalendarComponent_div_19_div_4_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 44);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const event_r10 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(event_r10.description);
  }
}
function CalendarComponent_div_19_div_4_span_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1, "All-day");
    ɵɵelementEnd();
  }
}
function CalendarComponent_div_19_div_4_span_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const event_r10 = ɵɵnextContext().$implicit;
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r3.formatEventTime(event_r10));
  }
}
function CalendarComponent_div_19_div_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 38);
    ɵɵlistener("click", function CalendarComponent_div_19_div_4_Template_div_click_0_listener() {
      const event_r10 = ɵɵrestoreView(_r9).$implicit;
      const ctx_r3 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r3.onEventClicked({
        event: {
          meta: {
            originalEvent: event_r10
          }
        }
      }));
    });
    ɵɵelementStart(1, "div", 39)(2, "div", 40);
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵtemplate(4, CalendarComponent_div_19_div_4_div_4_Template, 2, 1, "div", 41);
    ɵɵelementStart(5, "div", 42);
    ɵɵtemplate(6, CalendarComponent_div_19_div_4_span_6_Template, 2, 0, "span", 43)(7, CalendarComponent_div_19_div_4_span_7_Template, 2, 1, "span", 43);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const event_r10 = ctx.$implicit;
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵstyleProp("border-left-color", ctx_r3.getEventColor(event_r10).primary);
    ɵɵadvance(3);
    ɵɵtextInterpolate(event_r10.title);
    ɵɵadvance();
    ɵɵproperty("ngIf", event_r10.description);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", event_r10.allDay);
    ɵɵadvance();
    ɵɵproperty("ngIf", !event_r10.allDay);
  }
}
function CalendarComponent_div_19_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 46)(1, "div", 34)(2, "h3", 35);
    ɵɵtext(3);
    ɵɵelementEnd()();
    ɵɵtemplate(4, CalendarComponent_div_19_div_4_Template, 8, 6, "div", 37);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵadvance(3);
    ɵɵtextInterpolate(ctx_r3.formatSelectedDate());
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r3.getEventsForDate(ctx_r3.selectedDate));
  }
}
function CalendarComponent_div_20_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 47)(1, "p");
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate1("No events for ", ctx_r3.formatSelectedDate(), "");
  }
}
function UploadboxComponent_div_12_mat_card_4_mat_progress_bar_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "mat-progress-bar", 34);
  }
  if (rf & 2) {
    const file_r4 = ɵɵnextContext().$implicit;
    ɵɵproperty("value", file_r4.progress || 0);
  }
}
function UploadboxComponent_div_12_mat_card_4_span_18_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 35);
    ɵɵtext(1);
    ɵɵpipe(2, "number");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const file_r4 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind2(2, 1, file_r4.progress, "1.0-0"), "% ");
  }
}
function UploadboxComponent_div_12_mat_card_4_div_19_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 36);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const file_r4 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", file_r4.error, " ");
  }
}
function UploadboxComponent_div_12_mat_card_4_app_button_21_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "app-button", 37);
    ɵɵlistener("btnClick", function UploadboxComponent_div_12_mat_card_4_app_button_21_Template_app_button_btnClick_0_listener() {
      ɵɵrestoreView(_r5);
      const file_r4 = ɵɵnextContext().$implicit;
      const ctx_r5 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r5.previewFile(file_r4));
    });
    ɵɵelementEnd();
  }
}
function UploadboxComponent_div_12_mat_card_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mat-card", 16)(1, "div", 17)(2, "div", 18);
    ɵɵelement(3, "app-icon", 19);
    ɵɵelementEnd();
    ɵɵelementStart(4, "div", 20)(5, "div", 21);
    ɵɵtext(6);
    ɵɵelementEnd();
    ɵɵelementStart(7, "div", 22)(8, "span", 23);
    ɵɵtext(9);
    ɵɵelementEnd();
    ɵɵelementStart(10, "span", 24);
    ɵɵtext(11);
    ɵɵelementEnd()();
    ɵɵtemplate(12, UploadboxComponent_div_12_mat_card_4_mat_progress_bar_12_Template, 1, 1, "mat-progress-bar", 25);
    ɵɵelementStart(13, "div", 26);
    ɵɵelement(14, "span", 27);
    ɵɵelementStart(15, "span", 28);
    ɵɵtext(16);
    ɵɵpipe(17, "titlecase");
    ɵɵelementEnd();
    ɵɵtemplate(18, UploadboxComponent_div_12_mat_card_4_span_18_Template, 3, 4, "span", 29);
    ɵɵelementEnd();
    ɵɵtemplate(19, UploadboxComponent_div_12_mat_card_4_div_19_Template, 2, 1, "div", 30);
    ɵɵelementEnd();
    ɵɵelementStart(20, "div", 31);
    ɵɵtemplate(21, UploadboxComponent_div_12_mat_card_4_app_button_21_Template, 1, 0, "app-button", 32);
    ɵɵelementStart(22, "app-button", 33);
    ɵɵlistener("btnClick", function UploadboxComponent_div_12_mat_card_4_Template_app_button_btnClick_22_listener() {
      const file_r4 = ɵɵrestoreView(_r3).$implicit;
      const ctx_r5 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r5.removeFile(file_r4));
    });
    ɵɵelementEnd()()()();
  }
  if (rf & 2) {
    const file_r4 = ctx.$implicit;
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵclassProp("uploading", file_r4.status === "uploading")("completed", file_r4.status === "completed")("error", file_r4.status === "error");
    ɵɵadvance(3);
    ɵɵproperty("fontIcon", ctx_r5.getFileIcon(file_r4.type));
    ɵɵadvance(3);
    ɵɵtextInterpolate(file_r4.name);
    ɵɵadvance(3);
    ɵɵtextInterpolate(ctx_r5.formatFileSize(file_r4.size));
    ɵɵadvance(2);
    ɵɵtextInterpolate(file_r4.type);
    ɵɵadvance();
    ɵɵproperty("ngIf", file_r4.status === "uploading");
    ɵɵadvance(2);
    ɵɵstyleProp("background-color", ctx_r5.getFileStatusColor(file_r4.status));
    ɵɵadvance(2);
    ɵɵtextInterpolate(ɵɵpipeBind1(17, 17, file_r4.status));
    ɵɵadvance(2);
    ɵɵproperty("ngIf", file_r4.progress && file_r4.status === "uploading");
    ɵɵadvance();
    ɵɵproperty("ngIf", file_r4.error);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r5.showPreview && file_r4.url && file_r4.status === "completed");
  }
}
function UploadboxComponent_div_12_div_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 38)(1, "app-button", 39);
    ɵɵlistener("btnClick", function UploadboxComponent_div_12_div_5_Template_app_button_btnClick_1_listener() {
      ɵɵrestoreView(_r7);
      const ctx_r5 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r5.uploadAll());
    });
    ɵɵelement(2, "app-icon", 8);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("disabled", ctx_r5.isUploading);
    ɵɵadvance();
    ɵɵproperty("fontIcon", "cloud_upload");
  }
}
function UploadboxComponent_div_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 11)(1, "h4", 12);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementStart(3, "div", 13);
    ɵɵtemplate(4, UploadboxComponent_div_12_mat_card_4_Template, 23, 19, "mat-card", 14);
    ɵɵelementEnd();
    ɵɵtemplate(5, UploadboxComponent_div_12_div_5_Template, 3, 2, "div", 15);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate2("Uploaded Files (", ctx_r5.uploadedFiles.length, "/", ctx_r5.maxFiles, ")");
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r5.uploadedFiles);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r5.hasPendingFiles());
  }
}
var _c52 = ["pageBody"];
var _c62 = ["footer"];
var _c72 = [[["", "page-body", ""]], [["", "footer", ""]]];
var _c82 = ["[page-body]", "[footer]"];
function PageComponent_Conditional_2_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PageComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PageComponent_Conditional_2_ng_container_0_Template, 1, 0, "ng-container", 3);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.pageBodyTemplate);
  }
}
function PageComponent_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
function PageComponent_Conditional_4_Conditional_1_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PageComponent_Conditional_4_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PageComponent_Conditional_4_Conditional_1_ng_container_0_Template, 1, 0, "ng-container", 3);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.footerTemplate);
  }
}
function PageComponent_Conditional_4_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 1);
  }
}
function PageComponent_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 2);
    ɵɵtemplate(1, PageComponent_Conditional_4_Conditional_1_Template, 1, 1, "ng-container")(2, PageComponent_Conditional_4_Conditional_2_Template, 1, 0);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵattribute("footer", true);
    ɵɵadvance();
    ɵɵconditional(1, ctx_r0.footerTemplate ? 1 : 2);
  }
}
function GridListFiltersComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 2);
    ɵɵtext(1);
    ɵɵelementEnd();
    ɵɵelementStart(2, "app-button", 3);
    ɵɵlistener("btnClick", function GridListFiltersComponent_Conditional_2_Template_app_button_btnClick_2_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clearFilters());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.appliedFiltersCount);
    ɵɵadvance();
    ɵɵclassMap("clear-button");
  }
}
function LoaderComponent_Conditional_0_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "mat-spinner", 3);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("diameter", ctx_r0.diameter)("strokeWidth", ctx_r0.strokeWidth)("color", ctx_r0.color)("mode", ctx_r0.mode)("value", ctx_r0.value);
  }
}
function LoaderComponent_Conditional_0_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "mat-progress-bar", 5);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("mode", ctx_r0.mode)("value", ctx_r0.value)("color", ctx_r0.color);
  }
}
function LoaderComponent_Conditional_0_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "p", 4);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.message);
  }
}
function LoaderComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 1)(1, "div", 2);
    ɵɵtemplate(2, LoaderComponent_Conditional_0_Conditional_2_Template, 1, 5, "mat-spinner", 3)(3, LoaderComponent_Conditional_0_Conditional_3_Template, 1, 3)(4, LoaderComponent_Conditional_0_Conditional_4_Template, 2, 1, "p", 4);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("full-screen", ctx_r0.fullScreen);
    ɵɵadvance(2);
    ɵɵconditional(2, ctx_r0.type === "spinner" || ctx_r0.type === "circular" ? 2 : ctx_r0.type === "bar" ? 3 : -1);
    ɵɵadvance(2);
    ɵɵconditional(4, ctx_r0.message ? 4 : -1);
  }
}
function LoaderComponent_Conditional_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "mat-spinner", 3);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("diameter", ctx_r0.diameter)("strokeWidth", ctx_r0.strokeWidth)("color", ctx_r0.color)("mode", ctx_r0.mode)("value", ctx_r0.value);
  }
}
function LoaderComponent_Conditional_1_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "mat-progress-bar", 5);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("mode", ctx_r0.mode)("value", ctx_r0.value)("color", ctx_r0.color);
  }
}
function LoaderComponent_Conditional_1_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "p", 4);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.message);
  }
}
function LoaderComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6);
    ɵɵtemplate(1, LoaderComponent_Conditional_1_Conditional_1_Template, 1, 5, "mat-spinner", 3)(2, LoaderComponent_Conditional_1_Conditional_2_Template, 1, 3)(3, LoaderComponent_Conditional_1_Conditional_3_Template, 2, 1, "p", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵconditional(1, ctx_r0.type === "spinner" || ctx_r0.type === "circular" ? 1 : ctx_r0.type === "bar" ? 2 : -1);
    ɵɵadvance(2);
    ɵɵconditional(3, ctx_r0.message ? 3 : -1);
  }
}
function JsonReflectComponent_Conditional_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "app-button", 5);
    ɵɵlistener("btnClick", function JsonReflectComponent_Conditional_1_Conditional_1_Template_app_button_btnClick_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.toggleEdit());
    });
    ɵɵelementEnd();
  }
}
function JsonReflectComponent_Conditional_1_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "app-button", 6);
    ɵɵlistener("btnClick", function JsonReflectComponent_Conditional_1_Conditional_2_Template_app_button_btnClick_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onSave());
    });
    ɵɵelementEnd();
    ɵɵelementStart(1, "app-button", 7);
    ɵɵlistener("btnClick", function JsonReflectComponent_Conditional_1_Conditional_2_Template_app_button_btnClick_1_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onCancel());
    });
    ɵɵelementEnd();
    ɵɵelementStart(2, "app-button", 8);
    ɵɵlistener("btnClick", function JsonReflectComponent_Conditional_1_Conditional_2_Template_app_button_btnClick_2_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.formatJson());
    });
    ɵɵelementEnd();
  }
}
function JsonReflectComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 1);
    ɵɵtemplate(1, JsonReflectComponent_Conditional_1_Conditional_1_Template, 1, 0, "app-button", 4)(2, JsonReflectComponent_Conditional_1_Conditional_2_Template, 3, 0);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵconditional(1, !ctx_r1.isEditing ? 1 : 2);
  }
}
function JsonReflectComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 2);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.errorMessage);
  }
}
function JsonReflectComponent_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "textarea", 9);
    ɵɵtwoWayListener("ngModelChange", function JsonReflectComponent_Conditional_3_Template_textarea_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r1.jsonString, $event) || (ctx_r1.jsonString = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("input", function JsonReflectComponent_Conditional_3_Template_textarea_input_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onJsonChange());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵtwoWayProperty("ngModel", ctx_r1.jsonString);
  }
}
function JsonReflectComponent_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "pre", 10);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.jsonString);
  }
}
function PdfViewerComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 1)(1, "app-button", 3);
    ɵɵlistener("btnClick", function PdfViewerComponent_Conditional_1_Template_app_button_btnClick_1_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.downloadPdf());
    });
    ɵɵelementEnd();
    ɵɵelementStart(2, "app-button", 4);
    ɵɵlistener("btnClick", function PdfViewerComponent_Conditional_1_Template_app_button_btnClick_2_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.printPdf());
    });
    ɵɵelementEnd()();
  }
}
function PdfViewerComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "iframe", 5);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵstyleProp("height", ctx_r1.showToolbar ? "calc(" + ctx_r1.height + " - 48px)" : ctx_r1.height);
    ɵɵproperty("src", ctx_r1.safeSrc, ɵɵsanitizeResourceUrl);
  }
}
function PdfViewerComponent_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6)(1, "p");
    ɵɵtext(2, "No PDF to display");
    ɵɵelementEnd()();
  }
}
function QrCodeGeneratorComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 1)(1, "mat-form-field", 4)(2, "mat-label");
    ɵɵtext(3, "Enter data for QR code");
    ɵɵelementEnd();
    ɵɵelementStart(4, "input", 5);
    ɵɵtwoWayListener("ngModelChange", function QrCodeGeneratorComponent_Conditional_1_Template_input_ngModelChange_4_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r1.inputData, $event) || (ctx_r1.inputData = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("ngModelChange", function QrCodeGeneratorComponent_Conditional_1_Template_input_ngModelChange_4_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onInputChange());
    });
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(4);
    ɵɵtwoWayProperty("ngModel", ctx_r1.inputData);
  }
}
function QrCodeGeneratorComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 2);
    ɵɵelement(1, "img", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵstyleProp("width", ctx_r1.size, "px")("height", ctx_r1.size, "px");
    ɵɵproperty("src", ctx_r1.qrCodeDataUrl, ɵɵsanitizeUrl);
  }
}
function QrCodeGeneratorComponent_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 7)(1, "p");
    ɵɵtext(2, "Enter data to generate QR code");
    ɵɵelementEnd()();
  }
}
function QrCodeGeneratorComponent_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 3)(1, "app-button", 8);
    ɵɵlistener("btnClick", function QrCodeGeneratorComponent_Conditional_4_Template_app_button_btnClick_1_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.downloadQRCode());
    });
    ɵɵelementEnd()();
  }
}
function RichTextEditorComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 1)(1, "div", 3)(2, "app-button", 4);
    ɵɵlistener("btnClick", function RichTextEditorComponent_Conditional_1_Template_app_button_btnClick_2_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.formatText("bold"));
    });
    ɵɵelementEnd();
    ɵɵelementStart(3, "app-button", 5);
    ɵɵlistener("btnClick", function RichTextEditorComponent_Conditional_1_Template_app_button_btnClick_3_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.formatText("italic"));
    });
    ɵɵelementEnd();
    ɵɵelementStart(4, "app-button", 6);
    ɵɵlistener("btnClick", function RichTextEditorComponent_Conditional_1_Template_app_button_btnClick_4_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.formatText("underline"));
    });
    ɵɵelementEnd()();
    ɵɵelementStart(5, "div", 3)(6, "app-button", 7);
    ɵɵlistener("btnClick", function RichTextEditorComponent_Conditional_1_Template_app_button_btnClick_6_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.formatText("justifyLeft"));
    });
    ɵɵelementEnd();
    ɵɵelementStart(7, "app-button", 8);
    ɵɵlistener("btnClick", function RichTextEditorComponent_Conditional_1_Template_app_button_btnClick_7_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.formatText("justifyCenter"));
    });
    ɵɵelementEnd();
    ɵɵelementStart(8, "app-button", 9);
    ɵɵlistener("btnClick", function RichTextEditorComponent_Conditional_1_Template_app_button_btnClick_8_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.formatText("justifyRight"));
    });
    ɵɵelementEnd()();
    ɵɵelementStart(9, "div", 3)(10, "app-button", 10);
    ɵɵlistener("btnClick", function RichTextEditorComponent_Conditional_1_Template_app_button_btnClick_10_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.formatText("insertUnorderedList"));
    });
    ɵɵelementEnd();
    ɵɵelementStart(11, "app-button", 11);
    ɵɵlistener("btnClick", function RichTextEditorComponent_Conditional_1_Template_app_button_btnClick_11_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.formatText("insertOrderedList"));
    });
    ɵɵelementEnd()();
    ɵɵelementStart(12, "div", 3)(13, "app-button", 12);
    ɵɵlistener("btnClick", function RichTextEditorComponent_Conditional_1_Template_app_button_btnClick_13_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.insertLink());
    });
    ɵɵelementEnd();
    ɵɵelementStart(14, "app-button", 13);
    ɵɵlistener("btnClick", function RichTextEditorComponent_Conditional_1_Template_app_button_btnClick_14_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.insertImage());
    });
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    ɵɵadvance(2);
    ɵɵclassMap("toolbar-button");
    ɵɵproperty("fontIcon", "format_bold");
    ɵɵadvance();
    ɵɵclassMap("toolbar-button");
    ɵɵproperty("fontIcon", "format_italic");
    ɵɵadvance();
    ɵɵclassMap("toolbar-button");
    ɵɵproperty("fontIcon", "format_underlined");
    ɵɵadvance(2);
    ɵɵclassMap("toolbar-button");
    ɵɵproperty("fontIcon", "format_align_left");
    ɵɵadvance();
    ɵɵclassMap("toolbar-button");
    ɵɵproperty("fontIcon", "format_align_center");
    ɵɵadvance();
    ɵɵclassMap("toolbar-button");
    ɵɵproperty("fontIcon", "format_align_right");
    ɵɵadvance(2);
    ɵɵclassMap("toolbar-button");
    ɵɵproperty("fontIcon", "format_list_bulleted");
    ɵɵadvance();
    ɵɵclassMap("toolbar-button");
    ɵɵproperty("fontIcon", "format_list_numbered");
    ɵɵadvance(2);
    ɵɵclassMap("toolbar-button");
    ɵɵproperty("fontIcon", "link");
    ɵɵadvance();
    ɵɵclassMap("toolbar-button");
    ɵɵproperty("fontIcon", "image");
  }
}
function SliderComponent_Conditional_4_For_2_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 11);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const point_r1 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(point_r1.label);
  }
}
function SliderComponent_Conditional_4_For_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 9);
    ɵɵelement(1, "div", 10);
    ɵɵtemplate(2, SliderComponent_Conditional_4_For_2_Conditional_2_Template, 2, 1, "span", 11);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const point_r1 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵstyleProp("left", ctx_r1.getPointPosition(point_r1), "%")("bottom", ctx_r1.vertical ? ctx_r1.getPointPosition(point_r1) : 0, "%")("color", point_r1.color);
    ɵɵproperty("title", point_r1.label || point_r1.value.toString());
    ɵɵadvance(2);
    ɵɵconditional(2, point_r1.label ? 2 : -1);
  }
}
function SliderComponent_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 4);
    ɵɵrepeaterCreate(1, SliderComponent_Conditional_4_For_2_Template, 3, 8, "div", 8, ɵɵrepeaterTrackByIndex);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵrepeater(ctx_r1.points);
  }
}
function SliderComponent_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 6);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.value);
  }
}
function SliderComponent_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mat-form-field", 7)(1, "input", 12);
    ɵɵtwoWayListener("ngModelChange", function SliderComponent_Conditional_7_Template_input_ngModelChange_1_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r1.value, $event) || (ctx_r1.value = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("ngModelChange", function SliderComponent_Conditional_7_Template_input_ngModelChange_1_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onValueChange($event));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("min", ctx_r1.min)("max", ctx_r1.max)("step", ctx_r1.step);
    ɵɵtwoWayProperty("ngModel", ctx_r1.value);
    ɵɵproperty("disabled", ctx_r1.disabled);
  }
}
function ButtonCheckboxComponent_app_icon_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "app-icon", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("fontIcon", ctx_r0.icon)("color", ctx_r0.value ? "var(--primary-text-color)" : "")("size", 20);
  }
}
var _c92 = ["tabContent"];
function TabComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
function TabsComponent_mat_tab_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function TabsComponent_mat_tab_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-tab", 2);
    ɵɵtemplate(1, TabsComponent_mat_tab_1_ng_container_1_Template, 1, 0, "ng-container", 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const tab_r1 = ctx.$implicit;
    ɵɵproperty("label", tab_r1.label)("disabled", tab_r1.disabled);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", tab_r1.content);
  }
}
function ToggleButtonComponent_Conditional_0_For_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "app-icon", 3);
  }
  if (rf & 2) {
    const option_r3 = ɵɵnextContext().$implicit;
    ɵɵproperty("fontIcon", option_r3.icon);
  }
}
function ToggleButtonComponent_Conditional_0_For_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-button-toggle", 2);
    ɵɵtemplate(1, ToggleButtonComponent_Conditional_0_For_2_Conditional_1_Template, 1, 1, "app-icon", 3);
    ɵɵelementStart(2, "span");
    ɵɵtext(3);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const option_r3 = ctx.$implicit;
    ɵɵproperty("value", option_r3.value)("disabled", option_r3.disabled);
    ɵɵadvance();
    ɵɵconditional(1, option_r3.icon ? 1 : -1);
    ɵɵadvance(2);
    ɵɵtextInterpolate(option_r3.label);
  }
}
function ToggleButtonComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mat-button-toggle-group", 1);
    ɵɵlistener("change", function ToggleButtonComponent_Conditional_0_Template_mat_button_toggle_group_change_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onToggleChange($event.value));
    });
    ɵɵrepeaterCreate(1, ToggleButtonComponent_Conditional_0_For_2_Template, 4, 4, "mat-button-toggle", 2, _forTrack0);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("value", ctx_r1.selectedValues)("multiple", true)("appearance", ctx_r1.appearance)("vertical", ctx_r1.vertical);
    ɵɵadvance();
    ɵɵrepeater(ctx_r1.options);
  }
}
function ToggleButtonComponent_Conditional_1_For_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "app-button", 6);
    ɵɵlistener("btnClick", function ToggleButtonComponent_Conditional_1_For_2_Template_app_button_btnClick_0_listener() {
      const option_r5 = ɵɵrestoreView(_r4).$implicit;
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onClick(option_r5));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const option_r5 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassProp("selected", ctx_r1.isSelected(option_r5));
    ɵɵproperty("text", option_r5.label)("fontIcon", option_r5.icon || "")("color", option_r5.color || (ctx_r1.isSelected(option_r5) ? "primary" : "secondary"))("appearance", ctx_r1.isSelected(option_r5) ? "raised" : "flat")("disabled", option_r5.disabled || false);
  }
}
function ToggleButtonComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 4);
    ɵɵrepeaterCreate(1, ToggleButtonComponent_Conditional_1_For_2_Template, 1, 7, "app-button", 5, _forTrack0);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("vertical", ctx_r1.vertical);
    ɵɵadvance();
    ɵɵrepeater(ctx_r1.options);
  }
}
function TreeStructureComponent_mat_tree_node_1_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "app-icon", 5);
  }
  if (rf & 2) {
    const node_r2 = ɵɵnextContext().$implicit;
    ɵɵproperty("fontIcon", node_r2.icon);
  }
}
function TreeStructureComponent_mat_tree_node_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mat-tree-node", 3);
    ɵɵelement(1, "button", 4);
    ɵɵtemplate(2, TreeStructureComponent_mat_tree_node_1_Conditional_2_Template, 1, 1, "app-icon", 5);
    ɵɵelementStart(3, "span", 6);
    ɵɵlistener("click", function TreeStructureComponent_mat_tree_node_1_Template_span_click_3_listener() {
      const node_r2 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onNodeClick(node_r2));
    });
    ɵɵtext(4);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const node_r2 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵconditional(2, ctx_r2.showIcons && node_r2.icon ? 2 : -1);
    ɵɵadvance(2);
    ɵɵtextInterpolate(node_r2.name);
  }
}
function TreeStructureComponent_mat_tree_node_2_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "app-icon", 5);
  }
  if (rf & 2) {
    const node_r5 = ɵɵnextContext().$implicit;
    ɵɵproperty("fontIcon", node_r5.icon);
  }
}
function TreeStructureComponent_mat_tree_node_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mat-tree-node", 3)(1, "button", 7)(2, "mat-icon", 8);
    ɵɵtext(3);
    ɵɵelementEnd()();
    ɵɵtemplate(4, TreeStructureComponent_mat_tree_node_2_Conditional_4_Template, 1, 1, "app-icon", 5);
    ɵɵelementStart(5, "span", 6);
    ɵɵlistener("click", function TreeStructureComponent_mat_tree_node_2_Template_span_click_5_listener() {
      const node_r5 = ɵɵrestoreView(_r4).$implicit;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onNodeClick(node_r5));
    });
    ɵɵtext(6);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const node_r5 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵattribute("aria-label", "Toggle " + node_r5.name);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r2.treeControl.isExpanded(node_r5) ? "expand_more" : "chevron_right", " ");
    ɵɵadvance();
    ɵɵconditional(4, ctx_r2.showIcons && node_r5.icon ? 4 : -1);
    ɵɵadvance(2);
    ɵɵtextInterpolate(node_r5.name);
  }
}
function RadioButtonComponent_Conditional_1_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function RadioButtonComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, RadioButtonComponent_Conditional_1_ng_container_0_Template, 1, 0, "ng-container", 3);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.labelTemplateRef)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c42, ctx_r0.label, ctx_r0.label));
  }
}
function RadioButtonComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "label", 4);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.label);
  }
}
function RadioButtonComponent_For_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-radio-button", 2);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const option_r2 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("value", option_r2.value)("disabled", option_r2.disabled || ctx_r0.disabled);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", option_r2.label, " ");
  }
}
var _c102 = ["carouselItemTemplate"];
var _c114 = (a0, a1) => ({
  $implicit: a0,
  index: a1
});
function CarouselComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "app-button", 4);
    ɵɵlistener("btnClick", function CarouselComponent_Conditional_2_Template_app_button_btnClick_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.previous());
    });
    ɵɵelementEnd();
    ɵɵelementStart(1, "app-button", 4);
    ɵɵlistener("btnClick", function CarouselComponent_Conditional_2_Template_app_button_btnClick_1_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.next());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵclassMap("carousel-control prev");
    ɵɵproperty("fontIcon", "chevron_left");
    ɵɵadvance();
    ɵɵclassMap("carousel-control next");
    ɵɵproperty("fontIcon", "chevron_right");
  }
}
function CarouselComponent_Conditional_4_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function CarouselComponent_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, CarouselComponent_Conditional_4_ng_container_0_Template, 1, 0, "ng-container", 5);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.itemTemplate)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c114, ctx_r1.currentItem, ctx_r1.currentIndex));
  }
}
function CarouselComponent_Conditional_5_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "img", 7);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("src", ctx_r1.currentItem.image, ɵɵsanitizeUrl)("alt", ctx_r1.currentItem.title || "Carousel item");
  }
}
function CarouselComponent_Conditional_5_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 8);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.currentItem.title);
  }
}
function CarouselComponent_Conditional_5_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 9);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.currentItem.description);
  }
}
function CarouselComponent_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6);
    ɵɵtemplate(1, CarouselComponent_Conditional_5_Conditional_1_Template, 1, 2, "img", 7)(2, CarouselComponent_Conditional_5_Conditional_2_Template, 2, 1, "div", 8)(3, CarouselComponent_Conditional_5_Conditional_3_Template, 2, 1, "div", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵconditional(1, ctx_r1.currentItem.image ? 1 : -1);
    ɵɵadvance();
    ɵɵconditional(2, ctx_r1.currentItem.title ? 2 : -1);
    ɵɵadvance();
    ɵɵconditional(3, ctx_r1.currentItem.description ? 3 : -1);
  }
}
function CarouselComponent_Conditional_6_For_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "app-button", 11);
    ɵɵlistener("btnClick", function CarouselComponent_Conditional_6_For_2_Template_app_button_btnClick_0_listener() {
      const $index_r4 = ɵɵrestoreView(_r3).$index;
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.goTo($index_r4));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const $index_r4 = ctx.$index;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassMap("indicator" + (ctx_r1.currentIndex === $index_r4 ? " active" : ""));
    ɵɵattribute("aria-label", "Go to slide " + ($index_r4 + 1));
  }
}
function CarouselComponent_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 3);
    ɵɵrepeaterCreate(1, CarouselComponent_Conditional_6_For_2_Template, 1, 3, "app-button", 10, ɵɵrepeaterTrackByIndex);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵrepeater(ctx_r1.items);
  }
}
var _c123 = ["chartContainer"];
var CoreEventService = class _CoreEventService {
  constructor(injector) {
    this.injector = injector;
    this._menu = signal(null);
    this._authState = signal(null);
    this._breadcrumb = signal(null);
    this._notification = signal(null);
    this.menu = computed(() => this._menu());
    this.authState = computed(() => this._authState());
    this.breadcrumb = computed(() => this._breadcrumb());
    this.notification = computed(() => this._notification());
  }
  // Menu updaters
  setMenu(menu) {
    this._menu.set(menu);
  }
  clearMenu() {
    this._menu.set(null);
  }
  // Auth state updaters
  setAuth(state2) {
    this._authState.set(state2);
  }
  clearAuth() {
    this._authState.set(null);
  }
  // Breadcrumb updaters
  setBreadcrumb(breadcrumb) {
    if (breadcrumb === null) {
      this._breadcrumb.set(null);
    } else if (Array.isArray(breadcrumb)) {
      this._breadcrumb.set(breadcrumb);
    } else {
      this._breadcrumb.set([breadcrumb]);
    }
  }
  clearBreadcrumb() {
    this._breadcrumb.set(null);
  }
  // Notification updaters
  setNotification(notification) {
    this._notification.set(notification);
  }
  clearNotification() {
    this._notification.set(null);
  }
  // Convenience methods: run callback on signal changes (returns a destroy function)
  onMenuChange(cb) {
    return runInInjectionContext(this.injector, () => {
      const runner = effect(() => {
        cb(this._menu());
      });
      return () => runner.destroy();
    });
  }
  onAuthChange(cb) {
    return runInInjectionContext(this.injector, () => {
      const runner = effect(() => {
        cb(this._authState());
      });
      return () => runner.destroy();
    });
  }
  onBreadcrumbChange(cb) {
    return runInInjectionContext(this.injector, () => {
      const runner = effect(() => {
        cb(this._breadcrumb());
      });
      return () => runner.destroy();
    });
  }
  onNotificationChange(cb) {
    return runInInjectionContext(this.injector, () => {
      const runner = effect(() => {
        cb(this._notification());
      });
      return () => runner.destroy();
    });
  }
  static {
    this.ɵfac = function CoreEventService_Factory(t) {
      return new (t || _CoreEventService)(ɵɵinject(Injector));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _CoreEventService,
      factory: _CoreEventService.ɵfac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CoreEventService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: Injector
  }], null);
})();
var API_BASE_URL = new InjectionToken("API_BASE_URL");
var ApiConfigService = class _ApiConfigService {
  constructor(apiUrl) {
    this.apiUrl = apiUrl || "";
  }
  getApiUrl() {
    if (!this.apiUrl) {
      console.warn("API_BASE_URL not provided. Please provide API_BASE_URL token in your app configuration.");
    }
    return this.apiUrl;
  }
  static {
    this.ɵfac = function ApiConfigService_Factory(t) {
      return new (t || _ApiConfigService)(ɵɵinject(API_BASE_URL, 8));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _ApiConfigService,
      factory: _ApiConfigService.ɵfac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApiConfigService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [API_BASE_URL]
    }]
  }], null);
})();
var UserType;
(function(UserType2) {
  UserType2["HOSPITAL"] = "HOSPITAL";
  UserType2["DOCTOR"] = "DOCTOR";
  UserType2["PATIENT"] = "PATIENT";
})(UserType || (UserType = {}));
var AccountStatus;
(function(AccountStatus2) {
  AccountStatus2["ACTIVE"] = "ACTIVE";
  AccountStatus2["INACTIVE"] = "INACTIVE";
  AccountStatus2["SUSPENDED"] = "SUSPENDED";
  AccountStatus2["PENDING"] = "PENDING";
})(AccountStatus || (AccountStatus = {}));
var AuthService = class _AuthService {
  constructor(platformId) {
    this.platformId = platformId;
    this.http = inject(HttpClient);
    this.router = inject(Router);
    this.apiConfig = inject(ApiConfigService);
    this._authState = new BehaviorSubject({
      currentUser: null,
      isLoading: false,
      error: null,
      isAuthenticated: false
    });
    this.authState$ = this._authState.asObservable();
    this.currentUser$ = this.authState$.pipe(map((state2) => state2.currentUser));
    this.isAuthenticated$ = this.authState$.pipe(map((state2) => state2.isAuthenticated));
    this.isLoading$ = this.authState$.pipe(map((state2) => state2.isLoading));
    this.error$ = this.authState$.pipe(map((state2) => state2.error));
    this.TOKEN_KEY = "auth_token";
    this.REFRESH_TOKEN_KEY = "refresh_token";
    this.USER_KEY = "user_data";
    this.REMEMBER_ME_KEY = "remember_me";
    this.initializeAuthState();
  }
  /**
   * Initialize authentication state from stored data
   */
  initializeAuthState() {
    try {
      const token = this.getStoredToken();
      const user = this.getStoredUser();
      const rememberMe = this.getRememberMeStatus();
      if (token && user && this.isTokenValid(token)) {
        const currentUser = {
          user,
          token,
          tokenExpiresAt: this.getTokenExpiration(token),
          isAuthenticated: true,
          userType: user.userType
        };
        this.updateAuthState({
          currentUser,
          isLoading: false,
          error: null,
          isAuthenticated: true
        });
      } else if (token && user && !this.isTokenValid(token)) {
        const refreshToken = this.getStoredRefreshToken();
        if (refreshToken) {
          const currentUser = {
            user,
            token,
            tokenExpiresAt: this.getTokenExpiration(token),
            isAuthenticated: true,
            userType: user.userType
          };
          this.updateAuthState({
            currentUser,
            isLoading: true,
            error: null,
            isAuthenticated: true
          });
          this.refreshToken().subscribe({
            next: (success) => {
              if (!success) {
                this.clearStoredAuthData();
                this.updateAuthState({
                  currentUser: null,
                  isLoading: false,
                  error: null,
                  isAuthenticated: false
                });
              }
            },
            error: () => {
              this.clearStoredAuthData();
              this.updateAuthState({
                currentUser: null,
                isLoading: false,
                error: null,
                isAuthenticated: false
              });
            }
          });
        } else {
          const currentUser = {
            user,
            token,
            tokenExpiresAt: this.getTokenExpiration(token),
            isAuthenticated: true,
            userType: user.userType
          };
          this.updateAuthState({
            currentUser,
            isLoading: false,
            error: null,
            isAuthenticated: true
          });
        }
      } else {
        this.clearStoredAuthData();
        this.updateAuthState({
          currentUser: null,
          isLoading: false,
          error: null,
          isAuthenticated: false
        });
      }
    } catch (error) {
      console.error("Error initializing auth state:", error);
      this.clearStoredAuthData();
      this.updateAuthState({
        currentUser: null,
        isLoading: false,
        error: "Failed to restore authentication state",
        isAuthenticated: false
      });
    }
  }
  /**
   * Authenticate user with email and password
   */
  login(loginRequest, rememberMe = false) {
    this.updateAuthState({
      currentUser: null,
      isLoading: true,
      error: null,
      isAuthenticated: false
    });
    const httpOptions = {
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json",
        "X-Requested-With": "XMLHttpRequest"
      },
      withCredentials: false
    };
    const apiUrl = this.apiConfig.getApiUrl();
    console.log("Login request:", {
      url: `${apiUrl}/api/auth/login`,
      email: loginRequest.email,
      rememberMe
    });
    return this.http.post(`${apiUrl}/api/auth/login`, loginRequest, httpOptions).pipe(tap((response) => {
      console.log("Login response received");
      if (!response) {
        throw new Error("Empty response from server");
      }
      this.handleSuccessfulLogin(response, rememberMe);
    }), map(() => {
      const isAuth = this.isAuthenticated();
      if (!isAuth) {
        throw new Error("Authentication failed - user not authenticated after login");
      }
      return true;
    }), catchError((error) => {
      console.error("Login error:", error);
      if (error instanceof HttpErrorResponse) {
        if (error.status === 200 && error.message.includes("Http failure during parsing")) {
          const errorMessage3 = "Server returned invalid response format";
          this.updateAuthState({
            currentUser: null,
            isLoading: false,
            error: errorMessage3,
            isAuthenticated: false
          });
          return throwError(() => new Error(errorMessage3));
        }
        if (error.status === 0 || error.status === 502 || error.status === 503) {
          console.log("Backend server unavailable, attempting mock login...");
          return this.handleMockLogin(loginRequest, rememberMe);
        }
        const errorMessage2 = this.handleLoginError(error);
        this.updateAuthState({
          currentUser: null,
          isLoading: false,
          error: errorMessage2,
          isAuthenticated: false
        });
        return throwError(() => new Error(errorMessage2));
      }
      const errorMessage = error.message || "Login failed";
      this.updateAuthState({
        currentUser: null,
        isLoading: false,
        error: errorMessage,
        isAuthenticated: false
      });
      return throwError(() => error);
    }));
  }
  /**
   * Handle successful login response
   */
  handleSuccessfulLogin(response, rememberMe) {
    console.log("Processing login response:", response);
    try {
      const data = response.data || response;
      const token = data.accessToken || data.token || data.access_token || response.accessToken || response.token;
      if (!token) {
        throw new Error("No access token found in login response");
      }
      const refreshToken = data.refreshToken || data.refresh_token || response.refreshToken || response.refresh_token;
      console.log("Refresh token found:", !!refreshToken);
      const expiresIn = data.expiresIn || data.expires_in || response.expiresIn || 3600;
      const expiresInSeconds = typeof expiresIn === "number" ? expiresIn : parseInt(expiresIn, 10) || 3600;
      let user;
      if (data.user) {
        user = data.user;
      } else if (response.user) {
        user = response.user;
      } else {
        user = {
          id: data.userId || data.id || response.userId || response.id || "1",
          email: data.email || response.email || "",
          fullName: data.fullName || data.name || data.displayName || response.fullName || response.name || "User",
          userType: data.userType || data.user_type || response.userType || "HOSPITAL",
          profilePicture: data.profilePicture || data.profile_picture || response.profilePicture || "assets/avatars/default-avatar.jpg",
          phoneNumber: data.phoneNumber || data.phone_number || response.phoneNumber || "",
          role: data.role || response.role || "ADMIN",
          permissions: data.permissions || response.permissions || [],
          createdAt: data.createdAt || data.created_at || response.createdAt || (/* @__PURE__ */ new Date()).toISOString(),
          lastLoginAt: data.lastLoginAt || data.last_login_at || response.lastLoginAt || (/* @__PURE__ */ new Date()).toISOString(),
          status: data.status || data.active || response.status || response.active ? "ACTIVE" : "INACTIVE"
        };
      }
      if (!user.id || !user.email) {
        throw new Error("Invalid user data in login response");
      }
      const tokenExpiresAt = Date.now() + expiresInSeconds * 1e3;
      const currentUser = {
        user,
        token,
        tokenExpiresAt,
        isAuthenticated: true,
        userType: user.userType || "HOSPITAL"
      };
      console.log("Login successful - User:", user.email, "Type:", currentUser.userType);
      console.log("Token expires at:", new Date(tokenExpiresAt).toISOString());
      console.log("Refresh token stored:", !!refreshToken);
      this.storeAuthData(token, refreshToken, user, rememberMe);
      this.updateAuthState({
        currentUser,
        isLoading: false,
        error: null,
        isAuthenticated: true
      });
    } catch (error) {
      console.error("Error processing login response:", error);
      this.updateAuthState({
        currentUser: null,
        isLoading: false,
        error: error.message || "Failed to process login response",
        isAuthenticated: false
      });
      throw error;
    }
  }
  /**
   * Handle login errors and return appropriate error messages
   */
  handleLoginError(error) {
    console.error("Login error details:", {
      status: error.status,
      statusText: error.statusText,
      message: error.message,
      url: error.url,
      error: error.error
    });
    if (error.status === 0) {
      return "Unable to connect to the server. Please check if the backend server is running on port 8080.";
    }
    if (error.error instanceof ErrorEvent) {
      return "Network error occurred. Please check your internet connection and ensure the backend server is running.";
    }
    switch (error.status) {
      case 400:
        return "Invalid login credentials. Please check your email and password.";
      case 401:
        return "Invalid email or password. Please try again.";
      case 403:
        return "Account is suspended or inactive. Please contact support.";
      case 404:
        return "User account not found. Please check your email and user type.";
      case 429:
        return "Too many login attempts. Please try again later.";
      case 500:
        return "Server error. Please try again later.";
      case 502:
        return "Backend server is not responding. Please ensure the server is running on port 8080.";
      case 503:
        return "Service temporarily unavailable. Please try again later.";
      default:
        return `Server error (${error.status}). Please try again or contact support if the problem persists.`;
    }
  }
  /**
   * Handle mock login when backend is unavailable
   */
  handleMockLogin(loginRequest, rememberMe) {
    const mockCredentials = {
      [UserType.HOSPITAL]: {
        email: "u513107@gmail.com",
        password: "Shree@123"
      },
      [UserType.DOCTOR]: {
        email: "swapnil@gmail.com",
        password: "Swapnil@123"
      },
      [UserType.PATIENT]: {
        email: "patient@shreephysio.com",
        password: "Patient@123"
      }
    };
    const expectedByType = loginRequest.userType ? mockCredentials[loginRequest.userType] : void 0;
    const inferredType = !loginRequest.userType ? Object.keys(mockCredentials).find((t) => mockCredentials[t].email === loginRequest.email) : loginRequest.userType;
    const expectedCredentials = expectedByType || (inferredType ? mockCredentials[inferredType] : void 0);
    if (expectedCredentials && loginRequest.email === expectedCredentials.email && loginRequest.password === expectedCredentials.password) {
      const resolvedType = inferredType || loginRequest.userType || UserType.HOSPITAL;
      console.log("Mock login successful for:", resolvedType);
      const getUserInfo = (userType) => {
        switch (userType) {
          case UserType.DOCTOR:
            return {
              id: "DOC-12332",
              fullName: "Dr. Swapnil",
              phoneNumber: "8788802334"
            };
          case UserType.HOSPITAL:
            return {
              id: "ADMIN-001",
              fullName: "Hospital Admin",
              phoneNumber: "+91-22-12345678"
            };
          case UserType.PATIENT:
            return {
              id: "PAT-001",
              fullName: "John Doe",
              phoneNumber: "+91-9876543210"
            };
          default:
            return {
              id: "USER-001",
              fullName: "Demo User",
              phoneNumber: "+91-0000000000"
            };
        }
      };
      const userInfo = getUserInfo(resolvedType);
      const mockResponse = {
        success: true,
        message: "Login successful (Demo Mode)",
        data: {
          token: "mock-jwt-token-" + Date.now(),
          refreshToken: "mock-refresh-token-" + Date.now(),
          user: {
            id: userInfo.id,
            email: loginRequest.email,
            fullName: userInfo.fullName,
            userType: resolvedType,
            status: "ACTIVE",
            phoneNumber: userInfo.phoneNumber,
            profilePicture: "assets/avatars/default-avatar.jpg",
            createdAt: (/* @__PURE__ */ new Date()).toISOString(),
            lastLoginAt: (/* @__PURE__ */ new Date()).toISOString()
          }
        }
      };
      this.handleSuccessfulLogin(mockResponse, rememberMe);
      return of(true);
    } else {
      const errorMessage = "Invalid email or password. Please try again. (Demo Mode)";
      this.updateAuthState(__spreadProps(__spreadValues({}, this._authState.value), {
        isLoading: false,
        error: errorMessage
      }));
      return throwError(() => new Error(errorMessage));
    }
  }
  /**
   * Navigate user to appropriate dashboard after successful login
   */
  navigateAfterLogin(userType) {
    console.log("Navigating for user type:", userType);
    switch (userType) {
      case "HOSPITAL":
        console.log("Navigating to admin dashboard");
        this.router.navigate(["/admin-dashboard"]);
        break;
      case "DOCTOR":
        console.log("Navigating to doctor dashboard");
        this.router.navigate(["/dashboard"]);
        break;
      case "PATIENT":
        console.log("Navigating to patient dashboard");
        this.router.navigate(["/patient-dashboard"]);
        break;
      default:
        console.log("Default navigation to dashboard");
        this.router.navigate(["/dashboard"]);
    }
  }
  /**
   * Logout user and clear all authentication data
   */
  logout() {
    this.clearStoredAuthData();
    this.updateAuthState({
      currentUser: null,
      isLoading: false,
      error: null,
      isAuthenticated: false
    });
    this.router.navigate(["/login"]);
  }
  /**
   * Refresh authentication token
   */
  refreshToken() {
    const refreshToken = this.getStoredRefreshToken();
    if (!refreshToken) {
      console.warn("No refresh token available for token refresh");
      return of(false);
    }
    console.log("Attempting to refresh token...");
    const apiUrl = this.apiConfig.getApiUrl();
    return this.http.post(`${apiUrl}/api/auth/refresh`, {
      refreshToken
    }).pipe(tap((response) => {
      console.log("Token refresh successful");
      this.handleSuccessfulLogin(response, this.getRememberMeStatus());
    }), map(() => true), catchError((error) => {
      console.error("Token refresh failed:", error);
      if (error.status === 401 || error.status === 403) {
        console.log("Refresh token invalid, logging out");
        this.logout();
      }
      return of(false);
    }));
  }
  /**
   * Check if current token is valid
   */
  isTokenValid(token) {
    const tokenToCheck = token || this.getStoredToken();
    if (!tokenToCheck) {
      return false;
    }
    try {
      const expiration = this.getTokenExpiration(tokenToCheck);
      return Date.now() < expiration;
    } catch {
      return false;
    }
  }
  /**
   * Get token expiration time
   */
  getTokenExpiration(token) {
    try {
      const payload = JSON.parse(atob(token.split(".")[1]));
      return payload.exp * 1e3;
    } catch {
      return 0;
    }
  }
  /**
   * Get current user information
   */
  getCurrentUser() {
    return this._authState.value.currentUser?.user || null;
  }
  /**
   * Get current user type
   */
  getUserType() {
    return this._authState.value.currentUser?.user.userType || null;
  }
  /**
   * Check if user has specific permission
   */
  hasPermission(permission) {
    const user = this.getCurrentUser();
    return user?.permissions?.includes(permission) || false;
  }
  /**
   * Check if user is of specific type
   */
  isUserType(userType) {
    return this.getUserType() === userType;
  }
  /**
   * Check if user is hospital admin
   */
  isHospitalAdmin() {
    return this.isUserType(UserType.HOSPITAL);
  }
  /**
   * Check if user is doctor
   */
  isDoctor() {
    return this.isUserType(UserType.DOCTOR);
  }
  /**
   * Check if user is patient
   */
  isPatient() {
    return this.isUserType(UserType.PATIENT);
  }
  /**
   * Update authentication state
   */
  updateAuthState(newState) {
    const currentState = this._authState.value;
    const updatedState = __spreadValues(__spreadValues({}, currentState), newState);
    console.log("Updating auth state:", {
      currentState,
      newState,
      updatedState
    });
    this._authState.next(updatedState);
  }
  /**
   * Store authentication data in storage
   */
  storeAuthData(token, refreshToken, user, rememberMe) {
    if (!isPlatformBrowser(this.platformId)) {
      return;
    }
    try {
      if (!token || token === "dummy-token") {
        console.error("Invalid token provided for storage");
        throw new Error("Invalid token");
      }
      const existingRefreshToken = this.getStoredRefreshToken();
      const tokenToStore = refreshToken || existingRefreshToken;
      const storage = rememberMe ? localStorage : sessionStorage;
      storage.setItem(this.TOKEN_KEY, token);
      if (tokenToStore) {
        storage.setItem(this.REFRESH_TOKEN_KEY, tokenToStore);
        console.log("Refresh token stored in", rememberMe ? "localStorage" : "sessionStorage");
      } else {
        storage.removeItem(this.REFRESH_TOKEN_KEY);
        console.warn("No refresh token provided or found");
      }
      storage.setItem(this.USER_KEY, JSON.stringify(user));
      storage.setItem(this.REMEMBER_ME_KEY, rememberMe ? "true" : "false");
      console.log("Auth data stored successfully:", {
        hasToken: !!token,
        hasRefreshToken: !!tokenToStore,
        rememberMe,
        storage: rememberMe ? "localStorage" : "sessionStorage"
      });
    } catch (error) {
      console.error("Error storing auth data:", error);
      throw error;
    }
  }
  /**
   * Clear all stored authentication data
   */
  clearStoredAuthData() {
    if (!isPlatformBrowser(this.platformId)) {
      return;
    }
    try {
      localStorage.removeItem(this.TOKEN_KEY);
      localStorage.removeItem(this.REFRESH_TOKEN_KEY);
      localStorage.removeItem(this.USER_KEY);
      localStorage.removeItem(this.REMEMBER_ME_KEY);
      sessionStorage.removeItem(this.TOKEN_KEY);
      sessionStorage.removeItem(this.REFRESH_TOKEN_KEY);
      sessionStorage.removeItem(this.USER_KEY);
      sessionStorage.removeItem(this.REMEMBER_ME_KEY);
    } catch (error) {
      console.error("Error clearing auth data:", error);
    }
  }
  /**
   * Get stored authentication token
   */
  getStoredToken() {
    if (!isPlatformBrowser(this.platformId)) {
      return null;
    }
    try {
      return localStorage.getItem(this.TOKEN_KEY) || sessionStorage.getItem(this.TOKEN_KEY);
    } catch {
      return null;
    }
  }
  /**
   * Get stored refresh token
   */
  getStoredRefreshToken() {
    if (!isPlatformBrowser(this.platformId)) {
      return null;
    }
    try {
      return localStorage.getItem(this.REFRESH_TOKEN_KEY) || sessionStorage.getItem(this.REFRESH_TOKEN_KEY);
    } catch {
      return null;
    }
  }
  /**
   * Get stored user data
   */
  getStoredUser() {
    if (!isPlatformBrowser(this.platformId)) {
      return null;
    }
    try {
      const userData = localStorage.getItem(this.USER_KEY) || sessionStorage.getItem(this.USER_KEY);
      return userData ? JSON.parse(userData) : null;
    } catch {
      return null;
    }
  }
  /**
   * Get remember me status
   */
  getRememberMeStatus() {
    if (!isPlatformBrowser(this.platformId)) {
      return false;
    }
    try {
      return localStorage.getItem(this.REMEMBER_ME_KEY) === "true" || sessionStorage.getItem(this.REMEMBER_ME_KEY) === "true";
    } catch {
      return false;
    }
  }
  /**
   * Check if user is currently authenticated (synchronous method for guards)
   */
  isAuthenticated() {
    return this._authState.value.isAuthenticated;
  }
  /**
   * Get authentication headers for HTTP requests
   */
  getAuthHeaders() {
    const token = this.getStoredToken();
    return token ? {
      "Authorization": `Bearer ${token}`
    } : {};
  }
  static {
    this.ɵfac = function AuthService_Factory(t) {
      return new (t || _AuthService)(ɵɵinject(PLATFORM_ID));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _AuthService,
      factory: _AuthService.ɵfac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AuthService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: Object,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }], null);
})();
var Observe;
(function(Observe2) {
  Observe2["BODY"] = "body";
  Observe2["EVENTS"] = "events";
  Observe2["RESPONSE"] = "response";
})(Observe || (Observe = {}));
var ResponseType;
(function(ResponseType2) {
  ResponseType2["ARRAYBUFFER"] = "arraybuffer";
  ResponseType2["BLOB"] = "blob";
  ResponseType2["JSON"] = "json";
  ResponseType2["TEXT"] = "text";
})(ResponseType || (ResponseType = {}));
var HttpUtilService = class _HttpUtilService {
  /**
   * constructor
   */
  constructor() {
  }
  /**
   * Gets the upload progress
   * @param event - The HTTP event
   * @returns The upload progress
   */
  getUploadProgress(event) {
    switch (event.type) {
      case HttpEventType.UploadProgress:
        const progress = Math.round(100 * event.loaded / (event.total ?? 1));
        return {
          status: "progress",
          message: progress
        };
      case HttpEventType.Response:
        return event.body;
      default:
        return `Unhandled event: ${event.type}`;
    }
  }
  /**
   * Gets the download progress
   * @param event - The HTTP event
   * @returns The download progress
   */
  getDownloadProgress(event) {
    switch (event.type) {
      case HttpEventType.ResponseHeader:
        return {
          headers: event.headers,
          type: event.type
        };
      case HttpEventType.DownloadProgress:
        const progress = Math.round(100 * event.loaded / 100);
        return {
          status: "progress",
          message: progress
        };
      case HttpEventType.Response:
        return event.body;
      default:
        return `Unhandled event: ${event.type}`;
    }
  }
  /**
   * Saves a downloaded file
   * @param content - The content of the file
   * @param response - The response from the server
   * @param contentType - The content type of the file
   * @param filename - The name of the file
   * @returns The name of the file
   */
  saveDownloadedFile(content, response, contentType, filename) {
    const linkElement = document.createElement("a");
    try {
      let blob = null;
      let url = null;
      blob = new Blob([response], {
        type: contentType
      });
      if (!filename) {
        if (content?.includes("filename*=utf-8''")) {
          let tempData = content.split(";");
          let fName = "";
          tempData.forEach((item) => {
            if (item?.includes("filename*=utf-8''") && item.split("filename*=utf-8''").length > 0) {
              fName = decodeURI(item.split("filename*=utf-8''")[1]);
            }
          });
          filename = fName;
        } else {
          filename = content ? content.split("=")[1] : null;
          filename = filename ? filename.split(";")[0] : null;
          filename = filename ? filename.trim() : null;
          if (filename && filename.indexOf('"') > -1) {
            filename = filename.replace(/"/g, "");
          }
        }
        if (!content && !filename) {
          filename = "data";
        }
      }
      if (filename) {
        filename = decodeURIComponent(encodeURI(filename));
        url = window.URL.createObjectURL(blob);
        linkElement.setAttribute("href", url);
        linkElement.setAttribute("download", filename);
        const clickEvent = new MouseEvent("click", {
          view: window,
          bubbles: true,
          cancelable: false
        });
        linkElement.dispatchEvent(clickEvent);
        return filename;
      } else {
        return null;
      }
    } catch (ex) {
      return ex instanceof Error ? ex.message : "Unknown error";
    }
  }
  /**
   * Gets the download upload progress box
   * @param type - The type of the file
   * @param url - The URL of the file
   * @param fileName - The name of the file
   * @returns The download upload progress box
   */
  getDownloadUploadProgressBox(type, url, fileName) {
    const uldlData = {};
    uldlData.url = url;
    uldlData.type = type;
    uldlData.size = 0;
    uldlData.progress = 0;
    uldlData.fileName = fileName ? fileName : void 0;
    return uldlData;
  }
  /**
   * Gets the HTTP options
   * @param options - The HTTP options
   * @returns The HTTP options
   */
  getHttpOptions(options = {}) {
    const {
      headers = {},
      observe = Observe.BODY,
      reportProgress = false,
      responseType = ResponseType.JSON,
      // withCredentials = true,
      params = new HttpParams()
    } = options;
    return {
      headers: this.getHttpHeaders(headers),
      params,
      observe,
      reportProgress,
      responseType
      // withCredentials: withCredentials,
    };
  }
  /**
   * Gets the HTTP headers
   * @param headers
   * @returns HttpHeaders
   */
  getHttpHeaders(headers) {
    if (headers instanceof HttpHeaders) {
      return headers;
    }
    return new HttpHeaders(__spreadValues({
      "Content-Type": "application/json"
    }, headers));
  }
  /**
   * Handles an error
   * @param err - The error
   */
  errorHandler(err) {
    if (err.error instanceof Error) {
    } else {
      if (err && err.error && (err.error.code === -4 || err.error.code === -5 || err.error.code === -6 || err.error.hasOwnProperty("errors") && err.error.errors && err.error.errors.length)) {
        this.showServeError(err.error);
        return;
      }
    }
  }
  /**
   * Shows a server error
   * @param err - The error
   */
  showServeError(err) {
    if (err.hasOwnProperty("errors") && err.errors && err.errors.length) {
    }
  }
  /**
   * showLoader
   */
  showLoader() {
  }
  /**
   * hideLoader
   */
  hideLoader() {
  }
  static {
    this.ɵfac = function HttpUtilService_Factory(t) {
      return new (t || _HttpUtilService)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _HttpUtilService,
      factory: _HttpUtilService.ɵfac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpUtilService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var HttpService = class _HttpService {
  /**
   * Creates an instance of HttpService.
   * @param http - The HttpClient instance for making HTTP requests.
   * @param httpUtil - The HttpUtilService instance for handling HTTP utilities.
   * @param coreUtils - The CoreUtilService instance for core utility functions.
   * @param httpbackend - The HttpBackend instance for handling HTTP requests.
   */
  constructor(http, httpUtil, httpbackend) {
    this.http = http;
    this.httpUtil = httpUtil;
    this.httpbackend = httpbackend;
  }
  /**
   * Http GET request
   * @param url - The URL to send the GET request to.
   * @param options - The options for the GET request.
   * @returns An Observable that emits the response from the GET request.
   */
  sendGETRequest(url, options) {
    const httpOptions = this.httpUtil.getHttpOptions(options);
    return this.http.get(url, httpOptions);
  }
  /**
   * Http GET can pass custom heeaders
   * @param url - The URL to send the GET request to.
   * @param options - The options for the GET request.
   * @returns An Observable that emits the response from the GET request.
   */
  sendGETRequestBackend(url, options) {
    let httpClient = new HttpClient(this.httpbackend);
    return httpClient.get(url, options);
  }
  /**
   * Http DELETE request
   * @param url - The URL to send the DELETE request to.
   * @param options - The options for the DELETE request.
   * @returns An Observable that emits the response from the DELETE request.
   */
  sendDELETERequest(url, options) {
    const httpOptions = this.httpUtil.getHttpOptions(options);
    return this.http.delete(url, httpOptions);
  }
  /**
   * Http POST request
   * @param url - The URL to send the POST request to.
   * @param json - The payload to send in the POST request.
   * @param options - The options for the POST request.
   * @returns An Observable that emits the response from the POST request.
   */
  sendPOSTRequest(url, json, options) {
    if (!(json instanceof FormData) && (json === "" || json === "{}" || json === "[]")) {
      return throwError(new Error("Json should not be empty"));
    }
    const httpOptions = this.httpUtil.getHttpOptions(options);
    return this.http.post(url, json, httpOptions);
  }
  /**
   * Http POST can pass custom header
   * @param url - The URL to send the POST request to.
   * @param json - The payload to send in the POST request.
   * @param options - The options for the POST request.
   * @returns An Observable that emits the response from the POST request.
   */
  sendPOSTRequestBackend(url, json, options) {
    let httpClient = new HttpClient(this.httpbackend);
    return httpClient.post(url, json, options);
  }
  /**
   * Http PUT request
   * @param url - The URL to send the PUT request to.
   * @param json - The payload to send in the PUT request.
   * @param options - The options for the PUT request.
   * @returns An Observable that emits the response from the PUT request.
   */
  sendPUTRequest(url, json, options) {
    if (!(json instanceof FormData) && (json === "" || json === "{}" || json === "[]")) {
      return throwError(new Error("Json should not be empty"));
    }
    const httpOptions = this.httpUtil.getHttpOptions(options);
    return this.http.put(url, json, httpOptions);
  }
  /**
   * Http PATCH request
   * @param url - The URL to send the PATCH request to.
   * @param json - The payload to send in the PATCH request.
   * @param options - The options for the PATCH request.
   * @returns An Observable that emits the response from the PATCH request.
   */
  sendPATCHRequest(url, json, options) {
    if (!(json instanceof FormData) && (json === "" || json === "{}" || json === "[]")) {
      return throwError(new Error("Json should not be empty"));
    }
    const httpOptions = this.httpUtil.getHttpOptions(options);
    return this.http.patch(url, json, httpOptions);
  }
  /**
   * Http Proxy request
   * @param proxyUrl - The URL to send the proxy request to.
   * @param obj - The payload to send in the proxy request.
   * @returns An Observable that emits the response from the proxy request.
   */
  sendProxyRequest(proxyUrl, obj) {
  }
  /**
   * upload file
   * @param url - The URL to send the upload request to.
   * @param json - The payload to send in the upload request.
   * @param options - The options for the upload request.
   * @returns An Observable that emits the response from the upload request.
   */
  uploadFile(url, json, options) {
    const defaultOptions2 = {
      observe: Observe.EVENTS,
      headers: new HttpHeaders()
      // withCredentials: true,
    };
    return this.sendPOSTRequest(url, json, __spreadValues(__spreadValues({}, defaultOptions2), options)).pipe(filter((event) => event.type === HttpEventType.UploadProgress || event.type === HttpEventType.Response), map(this.httpUtil.getUploadProgress));
  }
  /**
   * upload file and download response
   * @p aram url - The URL to send the upload request to.
   * @param json - The payload to send in the upload request.
   * @param fileName - The name of the file to download.
   * @param options - The options for the upload request.
   * @returns An Observable that emits the response from the upload request.
   */
  uploadFileAndDownloadResponse(url, json, fileName, options) {
    const downloadFile = new Observable((observer) => {
      let contentDisposition = null;
      let contentType = null;
      const defaultOptions2 = {
        observe: Observe.EVENTS,
        headers: new HttpHeaders(),
        // withCredentials: true,
        responseType: ResponseType.BLOB
      };
      defaultOptions2.headers = options && options.headers ? options.headers : new HttpHeaders();
      this.sendPOSTRequest(url, json, __spreadValues(__spreadValues({}, defaultOptions2), options)).pipe(filter((event) => event.type === HttpEventType.ResponseHeader || event.type === HttpEventType.Response || event.type === HttpEventType.DownloadProgress), map(this.httpUtil.getUploadProgress)).subscribe((response) => {
        if (response.status && response.status === "progress") {
        } else if (response.type && response.type === "application/octet-stream") {
          contentDisposition = 'attachment; filename="IPAddressList.xlsx"';
          contentType = "application/octet-stream";
          try {
            this.httpUtil.saveDownloadedFile(contentDisposition, response, contentType, fileName);
            observer.next(response);
          } catch (ex) {
            observer.error(response);
          }
        } else {
          try {
            if (!contentType || contentType === "application/json" || contentType === "application/json;charset=UTF-8") {
              const reader = new FileReader();
              reader.addEventListener("loadend", (event) => {
                const text = event.srcElement["result"];
                if (JSON.parse(text) && JSON.parse(text).errorMsg) {
                } else {
                  this.httpUtil.saveDownloadedFile(contentDisposition, response, contentType, fileName);
                }
              });
              reader.readAsText(response);
            } else {
              this.httpUtil.saveDownloadedFile(contentDisposition, response, contentType, fileName);
            }
            observer.next(response);
          } catch (ex) {
            observer.error(response);
          }
        }
      }, (err) => {
        observer.error(err);
      });
    });
    return downloadFile;
  }
  /**
   * downloadFile
   * @param url - The URL to send the download request to.
   * @param fileName - The name of the file to download.
   * @param options - The options for the download request.
   * @param reportDownloadProgress - Whether to report download progress.
   * @param json - The payload to send in the download request.
   * @returns An Observable that emits the response from the download request.
   */
  downloadFile(url, fileName, options, reportDownloadProgress = false, json = "") {
    const downloadFile = new Observable((observer) => {
      let contentDisposition = null;
      let contentType = null;
      const defaultOptions2 = {
        reportProgress: true,
        observe: Observe.EVENTS,
        headers: new HttpHeaders(),
        responseType: json ? ResponseType.ARRAYBUFFER : ResponseType.BLOB
        // withCredentials: true,
      };
      defaultOptions2.headers = options && options.headers ? options.headers : new HttpHeaders();
      let urlResponse = json ? this.sendPOSTRequest(url, json, defaultOptions2) : this.sendGETRequest(url, defaultOptions2);
      urlResponse.pipe(filter((event) => event.type === HttpEventType.ResponseHeader || event.type === HttpEventType.Response || event.type === HttpEventType.DownloadProgress), map(this.httpUtil.getDownloadProgress)).subscribe((response) => {
        if (response?.status && response.status === "progress") {
          if (reportDownloadProgress) {
            observer.next(response);
          }
        } else if (response?.type && response.type === HttpEventType.ResponseHeader) {
          contentDisposition = response.headers.get("Content-Disposition");
          if (!contentDisposition) {
            console.warn("Unable to access Content-Disposition");
          }
          contentType = response.headers.get("content-type");
          if (options && options.fileNameHeader) {
            fileName = response.headers.get(options.fileNameHeader);
          }
          if (reportDownloadProgress) {
            observer.next(response);
          }
        } else {
          try {
            if (!contentType || contentType === "application/json" || contentType === "application/json;charset=UTF-8") {
              const reader = new FileReader();
              reader.addEventListener("loadend", (event) => {
                const text = event.srcElement["result"];
                if (text && JSON.parse(text) && JSON.parse(text).errorMsg) {
                } else {
                  this.httpUtil.saveDownloadedFile(contentDisposition, response, contentType, fileName);
                }
              });
              reader.readAsText(response);
            } else {
              this.httpUtil.saveDownloadedFile(contentDisposition, response, contentType, fileName);
            }
            observer.next(response);
          } catch (ex) {
            observer.error(response);
          }
        }
      }, (err) => {
        observer.error(err);
      });
    });
    return downloadFile;
  }
  //Dont use Method "downloadFileByPostRequest" both get/post request support provided in downloadFile method.
  /**
   * download file by post request
   * @param url - The URL to send the download request to.
   * @param json - The payload to send in the download request.
   * @param fileName - The name of the file to download.
   * @param options - The options for the download request.
   * @returns An Observable that emits the response from the download request.
   */
  downloadFileByPostRequest(url, json, fileName, options) {
    const downloadFile = new Observable((observer) => {
      let contentDisposition = null;
      let contentType = null;
      const defaultOptions2 = {
        reportProgress: true,
        observe: Observe.EVENTS,
        responseType: ResponseType.ARRAYBUFFER,
        headers: new HttpHeaders()
        // withCredentials: true,
      };
      defaultOptions2.headers = options && options.headers ? options.headers : new HttpHeaders();
      this.sendPOSTRequest(url, json, defaultOptions2).pipe(filter((event) => event.type === HttpEventType.ResponseHeader || event.type === HttpEventType.Response || event.type === HttpEventType.DownloadProgress), map(this.httpUtil.getDownloadProgress)).subscribe((response) => {
        if (response?.status && response.status === "progress") {
        } else if (response.type && response.type === HttpEventType.ResponseHeader) {
          contentDisposition = response.headers.get("Content-Disposition");
          contentType = response.headers.get("content-type");
        } else {
          try {
            if (!contentType || contentType === "application/json" || contentType === "application/json;charset=UTF-8") {
              const reader = new FileReader();
              reader.addEventListener("loadend", (event) => {
                const text = event.srcElement["result"];
                if (JSON.parse(text) && JSON.parse(text).errorMsg) {
                } else {
                  this.httpUtil.saveDownloadedFile(contentDisposition, response, contentType, fileName);
                }
              });
              reader.readAsText(response);
            } else {
              this.httpUtil.saveDownloadedFile(contentDisposition, response, contentType, fileName);
            }
            observer.next(response);
          } catch (ex) {
            observer.error(response);
          }
        }
      });
    });
    return downloadFile;
  }
  /**
   * download file by location
   * @param url - The URL to send the download request to.
   */
  downloadFileByLocation(url) {
    const downloadUrl = window.location.protocol + "//" + window.location.hostname + "/" + url;
    window.location.href = downloadUrl;
  }
  static {
    this.ɵfac = function HttpService_Factory(t) {
      return new (t || _HttpService)(ɵɵinject(HttpClient), ɵɵinject(HttpUtilService), ɵɵinject(HttpBackend));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _HttpService,
      factory: _HttpService.ɵfac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: HttpClient
  }, {
    type: HttpUtilService
  }, {
    type: HttpBackend
  }], null);
})();
var DataService = class _DataService {
  constructor() {
  }
  static {
    this.ɵfac = function DataService_Factory(t) {
      return new (t || _DataService)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _DataService,
      factory: _DataService.ɵfac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DataService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var MenuService = class _MenuService {
  constructor() {
    this.menuSubject = new BehaviorSubject([]);
    this.doctorMenu = [{
      label: "Dashboard",
      icon: "dashboard",
      route: "/dashboard",
      section: "main",
      userTypes: ["doctor"]
    }, {
      label: "Appointments",
      icon: "event",
      route: "/appointment",
      section: "main",
      userTypes: ["doctor"]
    }, {
      label: "Schedule",
      icon: "schedule",
      route: "/schedule",
      section: "main",
      userTypes: ["doctor"]
    }, {
      label: "Patients",
      icon: "groups",
      route: "/patient",
      section: "main",
      userTypes: ["doctor"]
    }, {
      label: "Chat",
      icon: "chat",
      route: "/chat",
      section: "main",
      userTypes: ["doctor"]
    }, {
      label: "Patient Queue",
      icon: "queue",
      route: "/patient-queue",
      section: "main",
      userTypes: ["doctor"]
    }, {
      label: "Admitted Patients",
      icon: "local_hospital",
      route: "/doctor-treatment",
      section: "main",
      userTypes: ["doctor"]
    }, {
      label: "Exercises",
      icon: "fitness_center",
      route: "/exercises",
      section: "services",
      userTypes: ["doctor"]
    }, {
      label: "Diet Plans",
      icon: "track_changes",
      route: "/diet",
      section: "services",
      userTypes: ["doctor"]
    }, {
      label: "Billing",
      icon: "credit_card",
      route: "/billing",
      section: "administration",
      userTypes: ["doctor"]
    }, {
      label: "Settings",
      icon: "settings",
      route: "/settings",
      section: "tools",
      userTypes: ["doctor"]
    }, {
      label: "Help & Support",
      icon: "help_center",
      route: "/help",
      section: "tools",
      userTypes: ["doctor"]
    }];
    this.adminMenu = [{
      label: "Dashboard",
      icon: "dashboard",
      route: "/admin-dashboard",
      section: "main",
      userTypes: ["admin"]
    }, {
      label: "Doctors Management",
      icon: "local_hospital",
      route: "/admin/doctors",
      section: "management",
      userTypes: ["admin"]
    }, {
      label: "Hospital Services",
      icon: "healing",
      route: "/admin/services",
      section: "services",
      userTypes: ["admin"]
    }, {
      label: "Doctor Permissions",
      icon: "tune",
      route: "/admin/doctor-permissions",
      section: "management",
      userTypes: ["admin"]
    }, {
      label: "Role Management",
      icon: "security",
      route: "/admin/roles",
      section: "administration",
      userTypes: ["admin"]
    }, {
      label: "Plans & Offers",
      icon: "card_giftcard",
      route: "/admin/plans",
      section: "administration",
      userTypes: ["admin"]
    }, {
      label: "Rooms & Beds",
      icon: "hotel",
      route: "/admin/rooms",
      section: "services",
      userTypes: ["admin"]
    }, {
      label: "Government Schemes",
      icon: "account_balance",
      route: "/admin/schemes",
      section: "administration",
      userTypes: ["admin"]
    }, {
      label: "Settings",
      icon: "settings",
      route: "/settings",
      section: "tools",
      userTypes: ["admin"]
    }, {
      label: "Help & Support",
      icon: "help_center",
      route: "/admin/help",
      section: "tools",
      userTypes: ["admin"]
    }];
  }
  getMenuForUserType(userType) {
    if (userType === "doctor") {
      return this.doctorMenu;
    } else if (userType === "admin") {
      return this.adminMenu;
    }
    return [];
  }
  updateMenu(userType) {
    const menu = this.getMenuForUserType(userType);
    this.menuSubject.next(menu);
  }
  getMenu() {
    return this.menuSubject.asObservable();
  }
  getCurrentMenu() {
    return this.menuSubject.value;
  }
  static {
    this.ɵfac = function MenuService_Factory(t) {
      return new (t || _MenuService)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _MenuService,
      factory: _MenuService.ɵfac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MenuService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var HttpCallsService = class _HttpCallsService {
  constructor(http) {
    this.http = http;
    this.handleError = (error) => {
      const errorResponse = {
        message: error.message || "An error occurred",
        status: error.status,
        statusText: error.statusText,
        error: error.error
      };
      return throwError(() => errorResponse);
    };
  }
  /**
   * Send GET request
   * @param url - The URL to send the GET request to
   * @param options - Optional HTTP options
   * @returns Observable with the response data
   */
  sendGet(url, options) {
    const httpOptions = this.prepareOptions(options);
    if (!options?.observe) {
      httpOptions.observe = "body";
    }
    return this.http.get(url, httpOptions).pipe(catchError(this.handleError));
  }
  /**
   * Send POST request
   * @param url - The URL to send the POST request to
   * @param body - The request body
   * @param options - Optional HTTP options
   * @returns Observable with the response data
   */
  sendPost(url, body, options) {
    const httpOptions = this.prepareOptions(options);
    if (!options?.observe) {
      httpOptions.observe = "body";
    }
    return this.http.post(url, body, httpOptions).pipe(catchError(this.handleError));
  }
  /**
   * Send PUT request
   * @param url - The URL to send the PUT request to
   * @param body - The request body
   * @param options - Optional HTTP options
   * @returns Observable with the response data
   */
  sendPut(url, body, options) {
    const httpOptions = this.prepareOptions(options);
    if (!options?.observe) {
      httpOptions.observe = "body";
    }
    return this.http.put(url, body, httpOptions).pipe(catchError(this.handleError));
  }
  /**
   * Send PATCH request
   * @param url - The URL to send the PATCH request to
   * @param body - The request body
   * @param options - Optional HTTP options
   * @returns Observable with the response data
   */
  sendPatch(url, body, options) {
    const httpOptions = this.prepareOptions(options);
    if (!options?.observe) {
      httpOptions.observe = "body";
    }
    return this.http.patch(url, body, httpOptions).pipe(catchError(this.handleError));
  }
  /**
   * Send DELETE request
   * @param url - The URL to send the DELETE request to
   * @param options - Optional HTTP options
   * @returns Observable with the response data
   */
  sendDelete(url, options) {
    const httpOptions = this.prepareOptions(options);
    if (!options?.observe) {
      httpOptions.observe = "body";
    }
    return this.http.delete(url, httpOptions).pipe(catchError(this.handleError));
  }
  /**
   * Get full HTTP response (including headers, status, etc.)
   * @param url - The URL to send the GET request to
   * @param options - Optional HTTP options
   * @returns Observable with the full HTTP response
   */
  sendGetResponse(url, options) {
    const baseOptions = this.prepareOptions(options);
    const httpOptions = __spreadProps(__spreadValues({}, baseOptions), {
      observe: "response"
    });
    return this.http.get(url, httpOptions).pipe(map((response) => ({
      data: response.body,
      status: response.status,
      statusText: response.statusText,
      headers: response.headers
    })), catchError(this.handleError));
  }
  /**
   * Post and get full HTTP response
   * @param url - The URL to send the POST request to
   * @param body - The request body
   * @param options - Optional HTTP options
   * @returns Observable with the full HTTP response
   */
  sendPostResponse(url, body, options) {
    const baseOptions = this.prepareOptions(options);
    const httpOptions = __spreadProps(__spreadValues({}, baseOptions), {
      observe: "response"
    });
    return this.http.post(url, body, httpOptions).pipe(map((response) => ({
      data: response.body,
      status: response.status,
      statusText: response.statusText,
      headers: response.headers
    })), catchError(this.handleError));
  }
  prepareOptions(options) {
    const defaultOptions2 = {
      headers: new HttpHeaders({
        "Content-Type": "application/json"
      }),
      observe: "body",
      responseType: "json"
    };
    if (options) {
      if (options.headers) {
        defaultOptions2.headers = options.headers instanceof HttpHeaders ? options.headers : new HttpHeaders(options.headers);
      }
      if (options.params) {
        defaultOptions2.params = options.params instanceof HttpParams ? options.params : new HttpParams({
          fromObject: options.params
        });
      }
      if (options.observe) {
        defaultOptions2.observe = options.observe;
      }
      if (options.reportProgress !== void 0) {
        defaultOptions2.reportProgress = options.reportProgress;
      }
      if (options.responseType) {
        defaultOptions2.responseType = options.responseType;
      }
      if (options.withCredentials !== void 0) {
        defaultOptions2.withCredentials = options.withCredentials;
      }
    }
    return defaultOptions2;
  }
  static {
    this.ɵfac = function HttpCallsService_Factory(t) {
      return new (t || _HttpCallsService)(ɵɵinject(HttpClient));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _HttpCallsService,
      factory: _HttpCallsService.ɵfac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpCallsService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: HttpClient
  }], null);
})();
var ChartService = class _ChartService {
  constructor() {
    this.defaultOptions = {
      chart: {
        type: "line"
      },
      title: {
        text: "Chart"
      },
      credits: {
        enabled: false
      },
      legend: {
        enabled: true
      },
      tooltip: {
        enabled: true
      }
    };
  }
  /**
   * Create a chart instance
   * @param container - The DOM element or element ID to render the chart in
   * @param options - Chart configuration options
   * @returns Highcharts chart instance
   */
  createChart(container, options) {
    if (typeof Highcharts === "undefined") {
      console.error("Highcharts library is not loaded. Please include Highcharts in your project.");
      return null;
    }
    const mergedOptions = this.mergeOptions(options);
    return Highcharts.chart(container, mergedOptions);
  }
  /**
   * Update an existing chart
   * @param chartInstance - The Highcharts chart instance
   * @param options - Chart configuration options to update
   */
  updateChart(chartInstance, options) {
    if (!chartInstance) {
      console.error("Chart instance is not provided");
      return;
    }
    const mergedOptions = this.mergeOptions(options);
    chartInstance.update(mergedOptions, true);
  }
  /**
   * Destroy a chart instance
   * @param chartInstance - The Highcharts chart instance to destroy
   */
  destroyChart(chartInstance) {
    if (chartInstance && typeof chartInstance.destroy === "function") {
      chartInstance.destroy();
    }
  }
  /**
   * Get default chart options
   * @param type - Chart type
   * @returns Default chart options for the specified type
   */
  getDefaultOptions(type = "line") {
    return __spreadProps(__spreadValues({}, this.defaultOptions), {
      chart: __spreadProps(__spreadValues({}, this.defaultOptions.chart), {
        type
      })
    });
  }
  /**
   * Create chart options object with provided input
   * @param input - Partial chart options
   * @returns Complete chart options object
   */
  createChartOptions(input) {
    return this.mergeOptions(input);
  }
  mergeOptions(options) {
    const merged = __spreadValues(__spreadValues({}, this.defaultOptions), options);
    if (options.chart) {
      merged.chart = __spreadValues(__spreadValues({}, this.defaultOptions.chart), options.chart);
    }
    if (options.title) {
      merged.title = __spreadValues(__spreadValues({}, this.defaultOptions.title), options.title);
    }
    return merged;
  }
  static {
    this.ɵfac = function ChartService_Factory(t) {
      return new (t || _ChartService)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _ChartService,
      factory: _ChartService.ɵfac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChartService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var SnackbarService = class _SnackbarService {
  constructor(snackBar) {
    this.snackBar = snackBar;
    this.defaultConfig = {
      duration: 3e3,
      horizontalPosition: "end",
      verticalPosition: "bottom",
      panelClass: []
    };
  }
  /**
   * Show success message
   * @param message - Message to display
   * @param config - Optional snackbar configuration
   * @returns Snackbar reference
   */
  success(message2, config) {
    return this.show(message2, __spreadProps(__spreadValues({}, config), {
      panelClass: ["success-snackbar", ...config?.panelClass ? Array.isArray(config.panelClass) ? config.panelClass : [config.panelClass] : []]
    }));
  }
  /**
   * Show error message
   * @param message - Message to display
   * @param config - Optional snackbar configuration
   * @returns Snackbar reference
   */
  error(message2, config) {
    return this.show(message2, __spreadProps(__spreadValues({}, config), {
      panelClass: ["error-snackbar", ...config?.panelClass ? Array.isArray(config.panelClass) ? config.panelClass : [config.panelClass] : []]
    }));
  }
  /**
   * Show warning message
   * @param message - Message to display
   * @param config - Optional snackbar configuration
   * @returns Snackbar reference
   */
  warning(message2, config) {
    return this.show(message2, __spreadProps(__spreadValues({}, config), {
      panelClass: ["warning-snackbar", ...config?.panelClass ? Array.isArray(config.panelClass) ? config.panelClass : [config.panelClass] : []]
    }));
  }
  /**
   * Show info message
   * @param message - Message to display
   * @param config - Optional snackbar configuration
   * @returns Snackbar reference
   */
  info(message2, config) {
    return this.show(message2, __spreadProps(__spreadValues({}, config), {
      panelClass: ["info-snackbar", ...config?.panelClass ? Array.isArray(config.panelClass) ? config.panelClass : [config.panelClass] : []]
    }));
  }
  /**
   * Show custom message
   * @param message - Message to display
   * @param config - Optional snackbar configuration
   * @returns Snackbar reference
   */
  show(message2, config) {
    const snackbarConfig = __spreadProps(__spreadValues({}, this.defaultConfig), {
      duration: config?.duration ?? this.defaultConfig.duration,
      horizontalPosition: config?.horizontalPosition ?? this.defaultConfig.horizontalPosition,
      verticalPosition: config?.verticalPosition ?? this.defaultConfig.verticalPosition,
      panelClass: config?.panelClass ?? this.defaultConfig.panelClass
    });
    const snackbarRef = this.snackBar.open(message2, config?.action || "Close", snackbarConfig);
    if (config?.actionCallback) {
      snackbarRef.onAction().subscribe(() => {
        config.actionCallback();
      });
    }
    return snackbarRef;
  }
  /**
   * Dismiss the currently open snackbar
   */
  dismiss() {
    this.snackBar.dismiss();
  }
  static {
    this.ɵfac = function SnackbarService_Factory(t) {
      return new (t || _SnackbarService)(ɵɵinject(MatSnackBar));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _SnackbarService,
      factory: _SnackbarService.ɵfac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SnackbarService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: MatSnackBar
  }], null);
})();
var AuthGuard = class _AuthGuard {
  constructor(authService, router) {
    this.authService = authService;
    this.router = router;
  }
  canActivate() {
    const token = this.authService.getStoredToken();
    const user = this.authService.getStoredUser();
    const refreshToken = this.authService.getStoredRefreshToken();
    if (!token || !user) {
      this.router.navigate(["/login"]);
      return false;
    }
    const isTokenValid = this.authService.isTokenValid(token);
    if (isTokenValid) {
      return true;
    }
    if (refreshToken) {
      return true;
    }
    console.warn("Token expired and no refresh token found. Access may be denied after state initialization.");
    const isAuthenticated = this.authService.isAuthenticated();
    if (!isAuthenticated) {
      this.router.navigate(["/login"]);
      return false;
    }
    return true;
  }
  static {
    this.ɵfac = function AuthGuard_Factory(t) {
      return new (t || _AuthGuard)(ɵɵinject(AuthService), ɵɵinject(Router));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _AuthGuard,
      factory: _AuthGuard.ɵfac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AuthGuard, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: AuthService
  }, {
    type: Router
  }], null);
})();
var LoginGuard = class _LoginGuard {
  constructor(authService, router) {
    this.authService = authService;
    this.router = router;
  }
  canActivate() {
    const isAuthenticated = this.authService.isAuthenticated();
    if (isAuthenticated && this.authService.isTokenValid()) {
      const userType = this.authService.getUserType();
      if (userType === "HOSPITAL") {
        this.router.navigate(["/admin-dashboard"]);
      } else if (userType === "DOCTOR") {
        this.router.navigate(["/dashboard"]);
      } else if (userType === "PATIENT") {
        this.router.navigate(["/patient-dashboard"]);
      } else {
        this.router.navigate(["/dashboard"]);
      }
      return false;
    } else {
      if (isAuthenticated) {
        this.authService.logout();
      }
      return true;
    }
  }
  static {
    this.ɵfac = function LoginGuard_Factory(t) {
      return new (t || _LoginGuard)(ɵɵinject(AuthService), ɵɵinject(Router));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _LoginGuard,
      factory: _LoginGuard.ɵfac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LoginGuard, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: AuthService
  }, {
    type: Router
  }], null);
})();
var HttpInterceptorService = class _HttpInterceptorService {
  constructor() {
    this.authService = inject(AuthService);
    this.isRefreshing = false;
    this.refreshTokenSubject = new BehaviorSubject(null);
  }
  intercept(req, next) {
    const authHeaders = this.authService.getAuthHeaders();
    const headers = __spreadValues({
      "Content-Type": "application/json",
      "Accept": "application/json",
      "X-Requested-With": "XMLHttpRequest"
    }, authHeaders);
    if (req.body instanceof FormData) {
      delete headers["Content-Type"];
    }
    const authReq = req.clone({
      setHeaders: headers
    });
    return next.handle(authReq).pipe(catchError((error) => {
      console.error("HTTP Error:", error);
      if (error.status === 0) {
        console.error("CORS Error: Unable to connect to server");
        return throwError(() => new Error("Unable to connect to server. Please check your network connection."));
      }
      if (error.status === 307 || error.status === 302) {
        console.error("Redirect Error:", error);
        return throwError(() => new Error("Server redirect error. Please check the API endpoint configuration."));
      }
      if (error.status === 401 && !req.url.includes("/api/auth/refresh") && !req.url.includes("/api/auth/login")) {
        return this.handle401Error(req, next);
      }
      return throwError(() => error);
    }));
  }
  handle401Error(request, next) {
    if (!this.isRefreshing) {
      this.isRefreshing = true;
      this.refreshTokenSubject.next(null);
      const refreshToken = this.authService.getStoredRefreshToken();
      if (refreshToken) {
        return this.authService.refreshToken().pipe(switchMap((success) => {
          this.isRefreshing = false;
          if (success) {
            this.refreshTokenSubject.next(success);
            const authHeaders = this.authService.getAuthHeaders();
            const headers = __spreadValues({
              "Content-Type": "application/json",
              "Accept": "application/json",
              "X-Requested-With": "XMLHttpRequest"
            }, authHeaders);
            if (request.body instanceof FormData) {
              delete headers["Content-Type"];
            }
            const clonedRequest = request.clone({
              setHeaders: headers
            });
            return next.handle(clonedRequest);
          } else {
            this.authService.logout();
            return throwError(() => new Error("Token refresh failed. Please login again."));
          }
        }), catchError((err) => {
          this.isRefreshing = false;
          this.authService.logout();
          return throwError(() => err);
        }));
      } else {
        this.isRefreshing = false;
        this.authService.logout();
        return throwError(() => new Error("No refresh token available. Please login again."));
      }
    } else {
      return this.refreshTokenSubject.pipe(filter((token) => token !== null), take(1), switchMap(() => {
        const authHeaders = this.authService.getAuthHeaders();
        const headers = __spreadValues({
          "Content-Type": "application/json",
          "Accept": "application/json",
          "X-Requested-With": "XMLHttpRequest"
        }, authHeaders);
        if (request.body instanceof FormData) {
          delete headers["Content-Type"];
        }
        const clonedRequest = request.clone({
          setHeaders: headers
        });
        return next.handle(clonedRequest);
      }));
    }
  }
  static {
    this.ɵfac = function HttpInterceptorService_Factory(t) {
      return new (t || _HttpInterceptorService)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _HttpInterceptorService,
      factory: _HttpInterceptorService.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpInterceptorService, [{
    type: Injectable
  }], null, null);
})();
var CommonUtils = class {
  static getCounter(counter) {
    if (!counter) return "0";
    if (counter > 9) return "" + counter + "+";
    return "" + counter;
  }
};
var CHIP_COLORS = {
  ACTIVE: "#149d14d4",
  INACTIVE: "#f23a3ae6",
  ON_LEAVE: "#ff9800",
  RETIRED: "#607d8b",
  SCHEDULED: "#149d14d4",
  CANCELED: "#f23a3ae6",
  COMPLETED: "#ff9800",
  A_POSITIVE: "#149d14d4",
  A_NEGATIVE: "#f23a3ae6",
  B_POSITIVE: "#ff9800",
  B_NEGATIVE: "#607d8b",
  AB_POSITIVE: "#149d14d4",
  AB_NEGATIVE: "#f23a3ae6",
  O_POSITIVE: "#ff9800",
  O_NEGATIVE: "#607d8b",
  true: "#149d14d4",
  false: "#f23a3ae6"
};
var AppInputComponent = class _AppInputComponent {
  constructor(http) {
    this.http = http;
    this.type = "text";
    this.placeholder = "";
    this.value = "";
    this.disabled = false;
    this.required = false;
    this.appearance = "outline";
    this.label = "";
    this.errorMessage = "";
    this.multiline = false;
    this.rows = 1;
    this.prefixIconSize = "24px";
    this.suffixIconSize = "24px";
    this.search = false;
    this.searchUrl = "";
    this.valueChange = new EventEmitter();
    this.searchResults = new EventEmitter();
    this.searchOptions = [];
    this.searchSubject = new Subject();
    this.onChange = (value) => {
    };
    this.onTouched = () => {
    };
    this.searchSubject.pipe(debounceTime(300), distinctUntilChanged(), switchMap((searchValue) => {
      if (this.search && this.searchUrl && searchValue) {
        const url = this.searchUrl.replace("${searchValue}", encodeURIComponent(searchValue));
        return this.http.get(url);
      }
      return of([]);
    })).subscribe((results) => {
      this.searchOptions = results;
      this.searchResults.emit(results);
    });
  }
  onInput(event) {
    const input = event.target;
    this.value = input.value;
    this.valueChange.emit(input.value);
    this.onChange(input.value);
    this.onTouched();
    if (this.search) {
      this.searchSubject.next(input.value);
    }
  }
  // ControlValueAccessor methods
  writeValue(value) {
    this.value = value || "";
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  // Handle form control value changes
  onFormControlChange(value) {
    this.value = value;
    this.onChange(value);
  }
  static {
    this.ɵfac = function AppInputComponent_Factory(t) {
      return new (t || _AppInputComponent)(ɵɵdirectiveInject(HttpClient));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _AppInputComponent,
      selectors: [["app-input"]],
      inputs: {
        type: "type",
        placeholder: "placeholder",
        value: "value",
        disabled: "disabled",
        required: "required",
        appearance: "appearance",
        label: "label",
        errorMessage: "errorMessage",
        multiline: "multiline",
        rows: "rows",
        prefixIconName: "prefixIconName",
        prefixIconSize: "prefixIconSize",
        suffixIconName: "suffixIconName",
        suffixIconSize: "suffixIconSize",
        search: "search",
        searchUrl: "searchUrl"
      },
      outputs: {
        valueChange: "valueChange",
        searchResults: "searchResults"
      },
      standalone: true,
      features: [ɵɵProvidersFeature([{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => _AppInputComponent),
        multi: true
      }]), ɵɵStandaloneFeature],
      decls: 2,
      vars: 1,
      consts: [["auto", "matAutocomplete"], ["hideRequiredMarker", "true", 1, "app-search-input-field", 3, "appearance"], [4, "ngIf"], ["matPrefix", "", 3, "fontSize"], ["matInput", "", 3, "input", "type", "placeholder", "disabled", "required", "value", "matAutocomplete"], ["matSuffix", "", 3, "fontSize"], [3, "value", 4, "ngFor", "ngForOf"], ["matPrefix", ""], ["matSuffix", ""], [3, "value"], ["hideRequiredMarker", "true", 1, "app-input-field", 3, "appearance"], ["matInput", "", 3, "placeholder", "disabled", "required", "value", "rows"], ["matInput", "", 3, "input", "placeholder", "disabled", "required", "value", "rows"], ["matInput", "", 3, "input", "type", "placeholder", "disabled", "required", "value"]],
      template: function AppInputComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵtemplate(0, AppInputComponent_Conditional_0_Template, 9, 12, "mat-form-field", 1)(1, AppInputComponent_Conditional_1_Template, 7, 6);
        }
        if (rf & 2) {
          ɵɵconditional(0, ctx.search && !ctx.multiline ? 0 : 1);
        }
      },
      dependencies: [CommonModule, NgForOf, NgIf, MatFormFieldModule, MatFormField, MatLabel, MatError, MatPrefix, MatSuffix, MatInputModule, MatInput, MatIconModule, MatIcon, MatAutocompleteModule, MatAutocomplete, MatOption, MatAutocompleteTrigger, FormsModule, HttpClientModule],
      styles: [".app-search-input-field[_ngcontent-%COMP%]{width:100%;background:#fff;border-radius:var(--input-radius);box-shadow:0 0 0 1px #ececec;transition:box-shadow .2s}.app-search-input-field[_ngcontent-%COMP%]   .mat-mdc-form-field-flex[_ngcontent-%COMP%]{border-radius:2rem;background:#fff;min-height:48px;align-items:center;box-shadow:none;border:none;padding-left:.5rem;padding-right:.5rem}.app-search-input-field[_ngcontent-%COMP%]   .mat-mdc-form-field-outline[_ngcontent-%COMP%]{display:none}.app-search-input-field[_ngcontent-%COMP%]   .mat-mdc-form-field-infix[_ngcontent-%COMP%]{padding:0}.app-search-input-field[_ngcontent-%COMP%]   .mat-mdc-form-field-label[_ngcontent-%COMP%]{display:none}.app-search-input-field[_ngcontent-%COMP%]   .mat-mdc-input-element[_ngcontent-%COMP%]{font-size:1.1rem;color:#222;background:transparent;border:none;outline:none;box-shadow:none;padding:.75rem 0}.app-search-input-field[_ngcontent-%COMP%]   .mat-mdc-input-element[_ngcontent-%COMP%]::placeholder{color:silver;opacity:1;font-weight:400}.app-search-input-field[_ngcontent-%COMP%]   .mat-icon[_ngcontent-%COMP%]{color:#18b6b2;font-size:1.5rem!important;margin-right:.5rem;margin-left:.25rem;vertical-align:middle}.app-search-input-field[_ngcontent-%COMP%]   .mat-mdc-form-field-subscript-wrapper[_ngcontent-%COMP%]{display:none!important}.app-search-input-field[_ngcontent-%COMP%]     .mdc-notched-outline__leading, .app-search-input-field[_ngcontent-%COMP%]     .mdc-notched-outline__trailing{border-color:transparent!important}.app-search-input-field[_ngcontent-%COMP%]     .mat-mdc-text-field-wrapper{height:2.5em!important}.app-search-input-field[_ngcontent-%COMP%]     .mat-mdc-form-field-flex{align-self:center;height:3.5em!important}.app-search-input-field[_ngcontent-%COMP%]     .mat-mdc-form-field-infix{padding-bottom:0!important;padding-top:.25em}.app-input-field[_ngcontent-%COMP%]{width:100%}"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AppInputComponent, [{
    type: Component,
    args: [{
      selector: "app-input",
      standalone: true,
      imports: [CommonModule, MatFormFieldModule, MatInputModule, MatIconModule, MatAutocompleteModule, FormsModule, HttpClientModule],
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => AppInputComponent),
        multi: true
      }],
      template: '@if(search && !multiline) {\n  <mat-form-field [appearance]="appearance" class="app-search-input-field" hideRequiredMarker="true">\n    <mat-label *ngIf="label">{{ label }}</mat-label>\n    @if(prefixIconName) {\n      <mat-icon matPrefix [style.fontSize]="prefixIconSize">{{ prefixIconName }}</mat-icon>\n    }\n    <input\n      matInput\n      [type]="type"\n      [placeholder]="placeholder"\n      [disabled]="disabled"\n      [required]="required"\n      [value]="value"\n      (input)="onInput($event)"\n      [matAutocomplete]="auto"\n    />\n    @if(suffixIconName) {\n      <mat-icon matSuffix [style.fontSize]="suffixIconSize">{{ suffixIconName }}</mat-icon>\n    }\n    <mat-error *ngIf="errorMessage">{{ errorMessage }}</mat-error>\n    <mat-autocomplete #auto="matAutocomplete">\n      <mat-option *ngFor="let option of searchOptions" [value]="option">\n        {{ option }}\n      </mat-option>\n    </mat-autocomplete>\n  </mat-form-field>\n} @else {\n  <mat-form-field [appearance]="appearance" class="app-input-field" hideRequiredMarker="true">\n    <mat-label *ngIf="label">{{ label }}</mat-label>\n    @if(prefixIconName) {\n      <mat-icon matPrefix [style.fontSize]="prefixIconSize">{{ prefixIconName }}</mat-icon>\n    }\n    @if(multiline) {\n      <textarea\n        matInput\n        [placeholder]="placeholder"\n        [disabled]="disabled"\n        [required]="required"\n        [value]="value"\n        (input)="onInput($event)"\n        [rows]="rows">\n      </textarea>\n    } @else {\n      <input\n        matInput\n        [type]="type"\n        [placeholder]="placeholder"\n        [disabled]="disabled"\n        [required]="required"\n        [value]="value"\n        (input)="onInput($event)"\n      />\n    }\n    @if(suffixIconName) {\n      <mat-icon matSuffix [style.fontSize]="suffixIconSize">{{ suffixIconName }}</mat-icon>\n    }\n    <mat-error *ngIf="errorMessage">{{ errorMessage }}</mat-error>\n  </mat-form-field>\n}\n',
      styles: [".app-search-input-field{width:100%;background:#fff;border-radius:var(--input-radius);box-shadow:0 0 0 1px #ececec;transition:box-shadow .2s}.app-search-input-field .mat-mdc-form-field-flex{border-radius:2rem;background:#fff;min-height:48px;align-items:center;box-shadow:none;border:none;padding-left:.5rem;padding-right:.5rem}.app-search-input-field .mat-mdc-form-field-outline{display:none}.app-search-input-field .mat-mdc-form-field-infix{padding:0}.app-search-input-field .mat-mdc-form-field-label{display:none}.app-search-input-field .mat-mdc-input-element{font-size:1.1rem;color:#222;background:transparent;border:none;outline:none;box-shadow:none;padding:.75rem 0}.app-search-input-field .mat-mdc-input-element::placeholder{color:silver;opacity:1;font-weight:400}.app-search-input-field .mat-icon{color:#18b6b2;font-size:1.5rem!important;margin-right:.5rem;margin-left:.25rem;vertical-align:middle}.app-search-input-field .mat-mdc-form-field-subscript-wrapper{display:none!important}.app-search-input-field ::ng-deep .mdc-notched-outline__leading,.app-search-input-field ::ng-deep .mdc-notched-outline__trailing{border-color:transparent!important}.app-search-input-field ::ng-deep .mat-mdc-text-field-wrapper{height:2.5em!important}.app-search-input-field ::ng-deep .mat-mdc-form-field-flex{align-self:center;height:3.5em!important}.app-search-input-field ::ng-deep .mat-mdc-form-field-infix{padding-bottom:0!important;padding-top:.25em}.app-input-field{width:100%}\n"]
    }]
  }], () => [{
    type: HttpClient
  }], {
    type: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    required: [{
      type: Input
    }],
    appearance: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    errorMessage: [{
      type: Input
    }],
    multiline: [{
      type: Input
    }],
    rows: [{
      type: Input
    }],
    prefixIconName: [{
      type: Input
    }],
    prefixIconSize: [{
      type: Input
    }],
    suffixIconName: [{
      type: Input
    }],
    suffixIconSize: [{
      type: Input
    }],
    search: [{
      type: Input
    }],
    searchUrl: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    searchResults: [{
      type: Output
    }]
  });
})();
var AppSelectboxComponent = class _AppSelectboxComponent {
  constructor() {
    this.options = [];
    this.displayExpr = "";
    this.valueField = "";
    this.placeholder = "";
    this.label = "";
    this.formGroup = new FormGroup({});
    this.formControlName = "";
    this.disabled = false;
    this.required = false;
    this.errorMessage = "";
    this.formControl = new FormControl("");
    this.control = new FormControl("");
    this.dataChange = new EventEmitter();
    this.onChange = (value) => {
    };
    this.onTouched = () => {
    };
    this.formGroup.addControl(this.formControlName, this.formControl);
  }
  onSelectionChange(value) {
    this.data = value;
    this.dataChange.emit(this.data);
    this.onChange(value);
    this.onTouched();
  }
  getDisplay(option) {
    return this.displayExpr ? option?.[this.displayExpr] : option;
  }
  getValue(option) {
    return this.valueField ? option?.[this.valueField] : option;
  }
  // ControlValueAccessor methods
  writeValue(value) {
    this.data = value;
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  static {
    this.ɵfac = function AppSelectboxComponent_Factory(t) {
      return new (t || _AppSelectboxComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _AppSelectboxComponent,
      selectors: [["app-selectbox"]],
      inputs: {
        options: "options",
        displayExpr: "displayExpr",
        valueField: "valueField",
        placeholder: "placeholder",
        label: "label",
        formGroup: "formGroup",
        formControlName: "formControlName",
        disabled: "disabled",
        required: "required",
        errorMessage: "errorMessage",
        data: "data"
      },
      outputs: {
        dataChange: "dataChange"
      },
      standalone: true,
      features: [ɵɵProvidersFeature([{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => _AppSelectboxComponent),
        multi: true
      }]), ɵɵStandaloneFeature],
      decls: 5,
      vars: 3,
      consts: [[4, "ngIf"], ["name", "countryString", 3, "valueChange", "value", "placeholder"], [3, "value"]],
      template: function AppSelectboxComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "mat-form-field");
          ɵɵtemplate(1, AppSelectboxComponent_mat_label_1_Template, 2, 1, "mat-label", 0);
          ɵɵelementStart(2, "mat-select", 1);
          ɵɵtwoWayListener("valueChange", function AppSelectboxComponent_Template_mat_select_valueChange_2_listener($event) {
            ɵɵtwoWayBindingSet(ctx.data, $event) || (ctx.data = $event);
            return $event;
          });
          ɵɵrepeaterCreate(3, AppSelectboxComponent_For_4_Template, 2, 2, "mat-option", 2, _forTrack0);
          ɵɵelementEnd()();
        }
        if (rf & 2) {
          ɵɵadvance();
          ɵɵproperty("ngIf", ctx.label);
          ɵɵadvance();
          ɵɵtwoWayProperty("value", ctx.data);
          ɵɵproperty("placeholder", ctx.placeholder);
          ɵɵadvance();
          ɵɵrepeater(ctx.options);
        }
      },
      dependencies: [CommonModule, NgIf, MatSelectModule, MatFormField, MatLabel, MatSelect, MatOption, FormsModule, MatFormFieldModule, MatOptionModule, ReactiveFormsModule],
      styles: [".app-selectbox-field[_ngcontent-%COMP%]{width:100%;margin-bottom:1rem}"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AppSelectboxComponent, [{
    type: Component,
    args: [{
      selector: "app-selectbox",
      standalone: true,
      imports: [CommonModule, MatSelectModule, FormsModule, MatFormFieldModule, MatOptionModule, ReactiveFormsModule],
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => AppSelectboxComponent),
        multi: true
      }],
      template: '<!-- <mat-form-field class="app-selectbox-field" appearance="outline">\n  \n  <mat-select\n    [formControl]="control"\n    [placeholder]="placeholder"\n    [disabled]="disabled"\n    [value]="data"\n    (selectionChange)="onSelectionChange($event.value)"\n    [required]="required"\n  >\n    <mat-option *ngFor="let option of options" [value]="getValue(option)">\n      {{ getDisplay(option) }}\n    </mat-option>\n  </mat-select>\n  <mat-error *ngIf="errorMessage">{{ errorMessage }}</mat-error>\n</mat-form-field> -->\n\n\n<mat-form-field>\n  <mat-label *ngIf="label">{{ label }}</mat-label>\n  <mat-select name="countryString" [(value)]="data" [placeholder]="placeholder">\n    @for (option of options; track option.value) {\n      <mat-option [value]="getValue(option)">{{ getDisplay(option) }}</mat-option>\n    }\n  </mat-select>\n</mat-form-field>',
      styles: [".app-selectbox-field{width:100%;margin-bottom:1rem}\n"]
    }]
  }], () => [], {
    options: [{
      type: Input
    }],
    displayExpr: [{
      type: Input
    }],
    valueField: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    formGroup: [{
      type: Input
    }],
    formControlName: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    required: [{
      type: Input
    }],
    errorMessage: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    dataChange: [{
      type: Output
    }]
  });
})();
var IconComponent = class _IconComponent {
  constructor() {
    this.fontSet = "";
    this.fontIcon = "";
    this.iconType = "material";
    this.icomoonClass = "";
    this.size = 24;
    this.isBlink = false;
    this.fontBold = false;
    this.color = "#888";
    this.class = "";
    this.counter = null;
    this.isCovered = false;
    this.iconClick = new EventEmitter();
  }
  onClick(event) {
    this.iconClick.emit(event);
  }
  ngOnInit() {
    if (!this.fontIcon) {
      this.counter = CommonUtils.getCounter(this.counter);
    }
  }
  static {
    this.ɵfac = function IconComponent_Factory(t) {
      return new (t || _IconComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _IconComponent,
      selectors: [["app-icon"]],
      inputs: {
        fontSet: "fontSet",
        fontIcon: "fontIcon",
        iconType: "iconType",
        icomoonClass: "icomoonClass",
        size: "size",
        isBlink: "isBlink",
        fontBold: "fontBold",
        color: "color",
        class: "class",
        counter: "counter",
        isCovered: "isCovered"
      },
      outputs: {
        iconClick: "iconClick"
      },
      standalone: true,
      features: [ɵɵStandaloneFeature],
      decls: 3,
      vars: 1,
      consts: [[1, "icon-covered"], [2, "vertical-align", "middle", "cursor", "pointer", 3, "class", "fontSize", "color"], [2, "vertical-align", "middle", "cursor", "pointer", 3, "click"], [2, "vertical-align", "middle", "cursor", "pointer", 3, "click", "fontIcon", "ngClass"], [1, "icon-covered", 3, "click"], [1, "counter"], [2, "vertical-align", "middle", "cursor", "pointer", 3, "click", "fontIcon", "ngClass", "color"]],
      template: function IconComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵtemplate(0, IconComponent_Conditional_0_Template, 3, 1, "div", 0)(1, IconComponent_Conditional_1_Template, 3, 8)(2, IconComponent_Conditional_2_Template, 2, 1);
        }
        if (rf & 2) {
          ɵɵconditional(0, ctx.isCovered && !ctx.counter ? 0 : ctx.counter ? 1 : 2);
        }
      },
      dependencies: [MatIconModule, MatIcon, NgClass],
      styles: ['.lucide[_ngcontent-%COMP%]{display:inline-block;vertical-align:middle}.icomoon[_ngcontent-%COMP%], i.icomoon[class^=icon-][_ngcontent-%COMP%], i.icomoon[class*=" icon-"][_ngcontent-%COMP%]{display:inline-block;vertical-align:middle;line-height:1;font-family:icomoon!important}.icon-covered[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center;width:var(--primary-icon-width);height:var(--primary-icon-height);border:var(--primary-border);border-radius:var(--button-radius);background:var(--secondary-color);box-shadow:var(--primary-shadow);cursor:pointer}.icon-covered[_ngcontent-%COMP%]   i.icomoon[class^=icon-][_ngcontent-%COMP%], .icon-covered[_ngcontent-%COMP%]   i.icomoon[class*=" icon-"][_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center}.icon-blink[_ngcontent-%COMP%]{animation:_ngcontent-%COMP%_blink 1s infinite}.font-bold[_ngcontent-%COMP%]{font-weight:600}@keyframes _ngcontent-%COMP%_blink{0%{opacity:1}50%{opacity:.3}}.material-icon[_ngcontent-%COMP%]     .material-icons{font-family:Material Icons!important;font-weight:400;font-style:normal;display:inline-block;line-height:1;text-transform:none;letter-spacing:normal;word-wrap:normal;white-space:nowrap;direction:ltr;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;-moz-osx-font-smoothing:grayscale;font-feature-settings:"liga"}']
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IconComponent, [{
    type: Component,
    args: [{
      selector: "app-icon",
      standalone: true,
      imports: [MatIconModule, NgClass],
      template: `@if(isCovered && !counter){ 
  <div class="icon-covered">
    @if(iconType === 'icomoon') {
      <i 
        [class]="'icomoon ' + icomoonClass + ' ' + class"
        [style.fontSize.px]="size"
        [style.color]="color"
        (click)="onClick($event)"
        style="vertical-align: middle; cursor: pointer;"
      ></i>
    } @else {
      <mat-icon
        [fontIcon]="fontIcon"
        [ngClass]="'material-icon ' + class"
        [style.fontSize.px]="size"
        [style.color]="color"
        (click)="onClick($event)"
        style="vertical-align: middle; cursor: pointer;"
      ></mat-icon>
    }
  </div>
}
@else if(counter){
  <div class="icon-covered" (click)="onClick($event)" [class]="{'icon-blink': isBlink, 'font-bold': fontBold}">
    <span class="counter" [style.color]="color">{{counter}}</span>
  </div>
}
@else{
  @if(iconType === 'icomoon') {
    <i 
      [class]="'icomoon icon-' + fontIcon + ' ' + class"
      [style.fontSize.px]="size"
      [style.color]="color"
      (click)="onClick($event)"
      style="vertical-align: middle; cursor: pointer;"
    ></i>
  } @else {
    <mat-icon
      [fontIcon]="fontIcon"
      [ngClass]="'material-icon ' + class"
      [style.fontSize.px]="size"
      [style.color]="color === 'primary' ? 'var(--primary-color)' : color"
      [color]="color === 'primary' ? 'var(--primary-color)' : color"
      (click)="onClick($event)"
      style="vertical-align: middle; cursor: pointer;"
    ></mat-icon>
  }
}`,
      styles: ['.lucide{display:inline-block;vertical-align:middle}.icomoon,i.icomoon[class^=icon-],i.icomoon[class*=" icon-"]{display:inline-block;vertical-align:middle;line-height:1;font-family:icomoon!important}.icon-covered{display:flex;align-items:center;justify-content:center;width:var(--primary-icon-width);height:var(--primary-icon-height);border:var(--primary-border);border-radius:var(--button-radius);background:var(--secondary-color);box-shadow:var(--primary-shadow);cursor:pointer}.icon-covered i.icomoon[class^=icon-],.icon-covered i.icomoon[class*=" icon-"]{display:flex;align-items:center;justify-content:center}.icon-blink{animation:blink 1s infinite}.font-bold{font-weight:600}@keyframes blink{0%{opacity:1}50%{opacity:.3}}.material-icon ::ng-deep .material-icons{font-family:Material Icons!important;font-weight:400;font-style:normal;display:inline-block;line-height:1;text-transform:none;letter-spacing:normal;word-wrap:normal;white-space:nowrap;direction:ltr;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;-moz-osx-font-smoothing:grayscale;font-feature-settings:"liga"}\n']
    }]
  }], null, {
    fontSet: [{
      type: Input
    }],
    fontIcon: [{
      type: Input
    }],
    iconType: [{
      type: Input
    }],
    icomoonClass: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    isBlink: [{
      type: Input
    }],
    fontBold: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    class: [{
      type: Input
    }],
    counter: [{
      type: Input
    }],
    isCovered: [{
      type: Input
    }],
    iconClick: [{
      type: Output
    }]
  });
})();
var AppButtonComponent = class _AppButtonComponent {
  constructor() {
    this.color = "primary";
    this.type = "button";
    this.disabled = false;
    this.appearance = "basic";
    this.class = "";
    this.text = "";
    this.fontIcon = "";
    this.btnClick = new EventEmitter();
  }
  onClick(event) {
    this.btnClick.emit(event);
  }
  static {
    this.ɵfac = function AppButtonComponent_Factory(t) {
      return new (t || _AppButtonComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _AppButtonComponent,
      selectors: [["app-button"]],
      inputs: {
        color: "color",
        type: "type",
        disabled: "disabled",
        appearance: "appearance",
        class: "class",
        text: "text",
        fontIcon: "fontIcon"
      },
      outputs: {
        btnClick: "btnClick"
      },
      standalone: true,
      features: [ɵɵStandaloneFeature],
      ngContentSelectors: _c113,
      decls: 10,
      vars: 7,
      consts: [["btnContent", ""], [3, "ngSwitch"], ["mat-raised-button", "", 3, "color", "type", "disabled", "ngClass", "click", 4, "ngSwitchCase"], ["mat-flat-button", "", 3, "color", "type", "disabled", "ngClass", "click", 4, "ngSwitchCase"], ["mat-stroked-button", "", 3, "color", "type", "disabled", "ngClass", "click", 4, "ngSwitchCase"], ["mat-icon-button", "", 3, "color", "type", "disabled", "ngClass", "click", 4, "ngSwitchCase"], ["mat-fab", "", 3, "color", "type", "disabled", "ngClass", "click", 4, "ngSwitchCase"], ["mat-mini-fab", "", 3, "color", "type", "disabled", "ngClass", "click", 4, "ngSwitchCase"], ["mat-button", "", 3, "color", "type", "disabled", "ngClass", "click", 4, "ngSwitchDefault"], [3, "fontIcon"], ["mat-raised-button", "", 3, "click", "color", "type", "disabled", "ngClass"], [4, "ngTemplateOutlet"], ["mat-flat-button", "", 3, "click", "color", "type", "disabled", "ngClass"], ["mat-stroked-button", "", 3, "click", "color", "type", "disabled", "ngClass"], ["mat-icon-button", "", 3, "click", "color", "type", "disabled", "ngClass"], ["mat-fab", "", 3, "click", "color", "type", "disabled", "ngClass"], ["mat-mini-fab", "", 3, "click", "color", "type", "disabled", "ngClass"], ["mat-button", "", 3, "click", "color", "type", "disabled", "ngClass"]],
      template: function AppButtonComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef();
          ɵɵtemplate(0, AppButtonComponent_ng_template_0_Template, 3, 2, "ng-template", null, 0, ɵɵtemplateRefExtractor);
          ɵɵelementContainerStart(2, 1);
          ɵɵtemplate(3, AppButtonComponent_button_3_Template, 2, 5, "button", 2)(4, AppButtonComponent_button_4_Template, 2, 5, "button", 3)(5, AppButtonComponent_button_5_Template, 2, 5, "button", 4)(6, AppButtonComponent_button_6_Template, 2, 5, "button", 5)(7, AppButtonComponent_button_7_Template, 2, 5, "button", 6)(8, AppButtonComponent_button_8_Template, 2, 5, "button", 7)(9, AppButtonComponent_button_9_Template, 2, 5, "button", 8);
          ɵɵelementContainerEnd();
        }
        if (rf & 2) {
          ɵɵadvance(2);
          ɵɵproperty("ngSwitch", ctx.appearance || "basic");
          ɵɵadvance();
          ɵɵproperty("ngSwitchCase", "raised");
          ɵɵadvance();
          ɵɵproperty("ngSwitchCase", "flat");
          ɵɵadvance();
          ɵɵproperty("ngSwitchCase", "stroked");
          ɵɵadvance();
          ɵɵproperty("ngSwitchCase", "icon");
          ɵɵadvance();
          ɵɵproperty("ngSwitchCase", "fab");
          ɵɵadvance();
          ɵɵproperty("ngSwitchCase", "mini-fab");
        }
      },
      dependencies: [CommonModule, NgClass, NgTemplateOutlet, NgSwitch, NgSwitchCase, NgSwitchDefault, MatButtonModule, MatButton, MatIconButton, MatMiniFabButton, MatFabButton, IconComponent]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AppButtonComponent, [{
    type: Component,
    args: [{
      selector: "app-button",
      standalone: true,
      imports: [CommonModule, MatButtonModule, NgClass, NgSwitch, NgSwitchCase, NgSwitchDefault, NgTemplateOutlet, IconComponent],
      template: `<ng-template #btnContent>
  @if(appearance === 'icon') {
    <app-icon [fontIcon]="fontIcon"></app-icon>
  }
  @if(text) {
    <span>{{ text }}</span>
  }
  <ng-content></ng-content>
</ng-template>

<ng-container [ngSwitch]="appearance || 'basic'">
  <button *ngSwitchCase="'raised'" mat-raised-button [color]="color" [type]="type" [disabled]="disabled" [ngClass]="class" (click)="onClick($event)">
    <ng-container *ngTemplateOutlet="btnContent"></ng-container>
  </button>
  <button *ngSwitchCase="'flat'" mat-flat-button [color]="color" [type]="type" [disabled]="disabled" [ngClass]="class" (click)="onClick($event)">
    <ng-container *ngTemplateOutlet="btnContent"></ng-container>
  </button>
  <button *ngSwitchCase="'stroked'" mat-stroked-button [color]="color" [type]="type" [disabled]="disabled" [ngClass]="class" (click)="onClick($event)">
    <ng-container *ngTemplateOutlet="btnContent"></ng-container>
  </button>
  <button *ngSwitchCase="'icon'" mat-icon-button [color]="color" [type]="type" [disabled]="disabled" [ngClass]="class" (click)="onClick($event)">
    <ng-container *ngTemplateOutlet="btnContent"></ng-container>
  </button>
  <button *ngSwitchCase="'fab'" mat-fab [color]="color" [type]="type" [disabled]="disabled" [ngClass]="class" (click)="onClick($event)">
    <ng-container *ngTemplateOutlet="btnContent"></ng-container>
  </button>
  <button *ngSwitchCase="'mini-fab'" mat-mini-fab [color]="color" [type]="type" [disabled]="disabled" [ngClass]="class" (click)="onClick($event)">
    <ng-container *ngTemplateOutlet="btnContent"></ng-container>
  </button>
  <button *ngSwitchDefault mat-button [color]="color" [type]="type" [disabled]="disabled" [ngClass]="class" (click)="onClick($event)">
    <ng-container *ngTemplateOutlet="btnContent"></ng-container>
  </button>
</ng-container>
`
    }]
  }], null, {
    color: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    appearance: [{
      type: Input
    }],
    class: [{
      type: Input
    }],
    text: [{
      type: Input
    }],
    fontIcon: [{
      type: Input
    }],
    btnClick: [{
      type: Output
    }]
  });
})();
var DatePickerComponent = class _DatePickerComponent {
  constructor() {
    this.label = "";
    this.placeholder = "Select date";
    this.required = false;
    this.disabled = false;
    this.minDate = null;
    this.maxDate = null;
    this.startView = "month";
    this.value = null;
    this.touched = false;
    this.onChange = (value) => {
    };
    this.onTouched = () => {
    };
  }
  ngOnInit() {
    if (this.minDate && typeof this.minDate === "string") {
      this.minDate = new Date(this.minDate);
    }
    if (this.maxDate && typeof this.maxDate === "string") {
      this.maxDate = new Date(this.maxDate);
    }
  }
  writeValue(value) {
    this.value = value;
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  onDateChange(date) {
    this.value = date;
    this.onChange(date);
    this.markAsTouched();
  }
  onDateInput(event) {
    const date = event.target.value ? new Date(event.target.value) : null;
    this.onDateChange(date);
  }
  markAsTouched() {
    if (!this.touched) {
      this.touched = true;
      this.onTouched();
    }
  }
  static {
    this.ɵfac = function DatePickerComponent_Factory(t) {
      return new (t || _DatePickerComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _DatePickerComponent,
      selectors: [["app-date-picker"]],
      inputs: {
        label: "label",
        placeholder: "placeholder",
        required: "required",
        disabled: "disabled",
        minDate: "minDate",
        maxDate: "maxDate",
        startView: "startView"
      },
      standalone: true,
      features: [ɵɵProvidersFeature([{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => _DatePickerComponent),
        multi: true
      }]), ɵɵStandaloneFeature],
      decls: 7,
      vars: 11,
      consts: [["picker", ""], ["appearance", "outline", 1, "date-picker-field"], [4, "ngIf"], ["matInput", "", 3, "dateChange", "input", "blur", "matDatepicker", "placeholder", "required", "disabled", "min", "max", "value"], ["matSuffix", "", 3, "for"], [3, "startView"]],
      template: function DatePickerComponent_Template(rf, ctx) {
        if (rf & 1) {
          const _r1 = ɵɵgetCurrentView();
          ɵɵelementStart(0, "mat-form-field", 1);
          ɵɵtemplate(1, DatePickerComponent_mat_label_1_Template, 2, 1, "mat-label", 2);
          ɵɵelementStart(2, "input", 3);
          ɵɵlistener("dateChange", function DatePickerComponent_Template_input_dateChange_2_listener($event) {
            ɵɵrestoreView(_r1);
            return ɵɵresetView(ctx.onDateChange($event.value));
          })("input", function DatePickerComponent_Template_input_input_2_listener($event) {
            ɵɵrestoreView(_r1);
            return ɵɵresetView(ctx.onDateInput($event));
          })("blur", function DatePickerComponent_Template_input_blur_2_listener() {
            ɵɵrestoreView(_r1);
            return ɵɵresetView(ctx.markAsTouched());
          });
          ɵɵelementEnd();
          ɵɵelement(3, "mat-datepicker-toggle", 4)(4, "mat-datepicker", 5, 0);
          ɵɵtemplate(6, DatePickerComponent_mat_error_6_Template, 2, 0, "mat-error", 2);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          const picker_r3 = ɵɵreference(5);
          ɵɵadvance();
          ɵɵproperty("ngIf", ctx.label);
          ɵɵadvance();
          ɵɵproperty("matDatepicker", picker_r3)("placeholder", ctx.placeholder)("required", ctx.required)("disabled", ctx.disabled)("min", ctx.minDate)("max", ctx.maxDate)("value", ctx.value);
          ɵɵadvance();
          ɵɵproperty("for", picker_r3);
          ɵɵadvance();
          ɵɵproperty("startView", ctx.startView);
          ɵɵadvance(2);
          ɵɵproperty("ngIf", ctx.required && !ctx.value);
        }
      },
      dependencies: [CommonModule, NgIf, FormsModule, ReactiveFormsModule, MatFormFieldModule, MatFormField, MatLabel, MatError, MatSuffix, MatDatepickerModule, MatDatepicker, MatDatepickerInput, MatDatepickerToggle, MatInputModule, MatInput, MatNativeDateModule, MatIconModule],
      styles: [".date-picker-field[_ngcontent-%COMP%]{width:100%}.date-picker-field[_ngcontent-%COMP%]     .mat-mdc-form-field{width:100%}.date-picker-field[_ngcontent-%COMP%]     .mat-mdc-text-field-wrapper{background-color:#fff;border-radius:8px;border:1px solid #e2e8f0;transition:border-color .2s ease,box-shadow .2s ease}.date-picker-field[_ngcontent-%COMP%]     .mat-mdc-text-field-wrapper:hover{border-color:#10b3b3}.date-picker-field[_ngcontent-%COMP%]     .mat-mdc-text-field-wrapper.mat-focused{border-color:#10b3b3;box-shadow:0 0 0 3px #10b3b31a}.date-picker-field[_ngcontent-%COMP%]     .mat-mdc-form-field-focus-overlay{background-color:transparent}.date-picker-field[_ngcontent-%COMP%]     .mat-mdc-form-field-subscript-wrapper{display:none}.date-picker-field[_ngcontent-%COMP%]     .mat-mdc-form-field-infix{padding:12px 0;min-height:auto}.date-picker-field[_ngcontent-%COMP%]     .mat-mdc-input-element{font-size:14px;color:#374151}.date-picker-field[_ngcontent-%COMP%]     .mat-mdc-input-element::placeholder{color:#9ca3af}.date-picker-field[_ngcontent-%COMP%]     .mat-mdc-input-element:disabled{color:#9ca3af;background-color:#f9fafb}.date-picker-field[_ngcontent-%COMP%]     .mat-mdc-form-field-label{color:#6b7280;font-size:14px}.date-picker-field[_ngcontent-%COMP%]     .mat-mdc-form-field-label.mat-mdc-form-field-label-alternate{color:#10b3b3}.date-picker-field[_ngcontent-%COMP%]     .mat-mdc-datepicker-toggle{color:#6b7280}.date-picker-field[_ngcontent-%COMP%]     .mat-mdc-datepicker-toggle:hover{color:#10b3b3}.date-picker-field[_ngcontent-%COMP%]     .mat-mdc-form-field-error{color:#ef4444;font-size:12px;margin-top:4px}"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatePickerComponent, [{
    type: Component,
    args: [{
      selector: "app-date-picker",
      standalone: true,
      imports: [CommonModule, FormsModule, ReactiveFormsModule, MatFormFieldModule, MatDatepickerModule, MatInputModule, MatNativeDateModule, MatIconModule],
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => DatePickerComponent),
        multi: true
      }],
      template: '<mat-form-field appearance="outline" class="date-picker-field">\n  <mat-label *ngIf="label">{{ label }}</mat-label>\n  <input \n    matInput \n    [matDatepicker]="picker" \n    [placeholder]="placeholder"\n    [required]="required"\n    [disabled]="disabled"\n    [min]="minDate"\n    [max]="maxDate"\n    [value]="value"\n    (dateChange)="onDateChange($event.value)"\n    (input)="onDateInput($event)"\n    (blur)="markAsTouched()">\n  <mat-datepicker-toggle matSuffix [for]="picker"></mat-datepicker-toggle>\n  <mat-datepicker #picker [startView]="startView"></mat-datepicker>\n  <mat-error *ngIf="required && !value">\n    This field is required\n  </mat-error>\n</mat-form-field> ',
      styles: [".date-picker-field{width:100%}.date-picker-field ::ng-deep .mat-mdc-form-field{width:100%}.date-picker-field ::ng-deep .mat-mdc-text-field-wrapper{background-color:#fff;border-radius:8px;border:1px solid #e2e8f0;transition:border-color .2s ease,box-shadow .2s ease}.date-picker-field ::ng-deep .mat-mdc-text-field-wrapper:hover{border-color:#10b3b3}.date-picker-field ::ng-deep .mat-mdc-text-field-wrapper.mat-focused{border-color:#10b3b3;box-shadow:0 0 0 3px #10b3b31a}.date-picker-field ::ng-deep .mat-mdc-form-field-focus-overlay{background-color:transparent}.date-picker-field ::ng-deep .mat-mdc-form-field-subscript-wrapper{display:none}.date-picker-field ::ng-deep .mat-mdc-form-field-infix{padding:12px 0;min-height:auto}.date-picker-field ::ng-deep .mat-mdc-input-element{font-size:14px;color:#374151}.date-picker-field ::ng-deep .mat-mdc-input-element::placeholder{color:#9ca3af}.date-picker-field ::ng-deep .mat-mdc-input-element:disabled{color:#9ca3af;background-color:#f9fafb}.date-picker-field ::ng-deep .mat-mdc-form-field-label{color:#6b7280;font-size:14px}.date-picker-field ::ng-deep .mat-mdc-form-field-label.mat-mdc-form-field-label-alternate{color:#10b3b3}.date-picker-field ::ng-deep .mat-mdc-datepicker-toggle{color:#6b7280}.date-picker-field ::ng-deep .mat-mdc-datepicker-toggle:hover{color:#10b3b3}.date-picker-field ::ng-deep .mat-mdc-form-field-error{color:#ef4444;font-size:12px;margin-top:4px}\n"]
    }]
  }], null, {
    label: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    required: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    minDate: [{
      type: Input
    }],
    maxDate: [{
      type: Input
    }],
    startView: [{
      type: Input
    }]
  });
})();
var DIALOG_DATA_TOKEN = new InjectionToken("dialogData");
var FilterComponent = class _FilterComponent {
  constructor() {
    this.fields = [];
    this.operators = [];
    this.operatorsMap = {};
    this.valuesMap = {};
    this.selectedField = "";
    this.selectedFieldObj = null;
    this.appliedFilters = {};
    this.showAdvanced = false;
    this.dataTitle = "All Data";
    this.filters = [];
    this.logic = "AND";
    this.dialogRef = inject(MatDialogRef);
    this.data = inject(DIALOG_DATA_TOKEN);
    if (this.data) {
      this.fields = this.data.fields || [];
      this.operators = this.data.operators || [];
      this.operatorsMap = this.data.operatorsMap || {};
      this.valuesMap = this.data.valuesMap || {};
      this.dataTitle = this.data.title || "All Data";
      if (this.fields.length > 0 && !this.selectedField) {
        this.selectField(this.fields[0]);
      }
      if (this.data.filters && this.data.filters.length > 0) {
        this.convertLegacyFilters(this.data.filters);
      }
    }
  }
  // Field Selection
  selectField(field) {
    this.selectedField = field.value;
    this.selectedFieldObj = field;
  }
  // Get field-specific values
  getValues(field) {
    return this.valuesMap[field] || [];
  }
  // Get field icon based on input type
  getFieldIcon(inputType) {
    switch (inputType) {
      case "select":
        return "📋";
      case "boolean":
        return "☑️";
      case "date":
        return "📅";
      case "number":
        return "🔢";
      case "input":
      default:
        return "📝";
    }
  }
  // Get field description
  getFieldDescription(field) {
    switch (field.inputType) {
      case "select":
        return `Select one or more ${field.label.toLowerCase()} options`;
      case "boolean":
        return `Choose true or false for ${field.label.toLowerCase()}`;
      case "date":
        return `Set date range for ${field.label.toLowerCase()}`;
      case "number":
        return `Set numeric range for ${field.label.toLowerCase()}`;
      case "input":
      default:
        return `Enter text to search in ${field.label.toLowerCase()}`;
    }
  }
  // Option Selection for Select fields
  isOptionSelected(field, option) {
    const fieldFilters = this.appliedFilters[field];
    if (!fieldFilters || !fieldFilters.values) return false;
    return fieldFilters.values.includes(option);
  }
  toggleOption(field, option) {
    if (!this.appliedFilters[field]) {
      this.appliedFilters[field] = {
        type: "select",
        values: []
      };
    }
    const values = this.appliedFilters[field]?.values || [];
    const index = values.indexOf(option);
    if (index > -1) {
      values.splice(index, 1);
      if (values.length === 0) {
        delete this.appliedFilters[field];
      }
    } else {
      values.push(option);
    }
  }
  // Boolean Selection
  isBooleanSelected(field, value) {
    const fieldFilter = this.appliedFilters[field];
    return fieldFilter && fieldFilter.value === value;
  }
  setBooleanValue(field, value) {
    if (this.isBooleanSelected(field, value)) {
      delete this.appliedFilters[field];
    } else {
      this.appliedFilters[field] = {
        type: "boolean",
        value
      };
    }
  }
  // Range Values (Number/Date)
  getRangeValue(field, type) {
    const fieldFilter = this.appliedFilters[field];
    if (!fieldFilter || fieldFilter.type !== "range") return "";
    return fieldFilter[type] || "";
  }
  setRangeMinValue(field, event) {
    this.setRangeValueInternal(field, "min", event.target.value);
  }
  setRangeMaxValue(field, event) {
    this.setRangeValueInternal(field, "max", event.target.value);
  }
  setRangeValueInternal(field, type, value) {
    if (!this.appliedFilters[field]) {
      this.appliedFilters[field] = {
        type: "range"
      };
    }
    this.appliedFilters[field][type] = value;
    if (!this.appliedFilters[field].min && !this.appliedFilters[field].max) {
      delete this.appliedFilters[field];
    }
  }
  // Text Values
  getTextValue(field) {
    const fieldFilter = this.appliedFilters[field];
    return fieldFilter && fieldFilter.type === "text" ? fieldFilter.value : "";
  }
  setTextValue(field, event) {
    const value = event.target.value;
    if (!value.trim()) {
      delete this.appliedFilters[field];
    } else {
      this.appliedFilters[field] = {
        type: "text",
        value
      };
    }
  }
  // Get filters for a specific field
  getFieldFilters(field) {
    const fieldFilter = this.appliedFilters[field];
    if (!fieldFilter) return [];
    switch (fieldFilter.type) {
      case "select":
        return fieldFilter.values || [];
      case "boolean":
        return [fieldFilter.value];
      case "range":
        const parts = [];
        if (fieldFilter.min) parts.push(`≥ ${fieldFilter.min}`);
        if (fieldFilter.max) parts.push(`≤ ${fieldFilter.max}`);
        return parts;
      case "text":
        return [fieldFilter.value];
      default:
        return [];
    }
  }
  // Remove field filter
  removeFieldFilter(field, filter2) {
    const fieldFilter = this.appliedFilters[field];
    if (!fieldFilter) return;
    if (fieldFilter.type === "select") {
      const index = fieldFilter.values.indexOf(filter2);
      if (index > -1) {
        fieldFilter.values.splice(index, 1);
        if (fieldFilter.values.length === 0) {
          delete this.appliedFilters[field];
        }
      }
    } else {
      delete this.appliedFilters[field];
    }
  }
  // Get display text for filter
  getFilterDisplayText(filter2) {
    return String(filter2);
  }
  // Get active filter fields
  getActiveFilterFields() {
    return Object.keys(this.appliedFilters);
  }
  // Get field label by field name
  getFieldLabel(fieldName) {
    const field = this.fields.find((f) => f.value === fieldName);
    return field ? field.label : fieldName;
  }
  // Clear all filters
  clearAllFilters() {
    this.appliedFilters = {};
  }
  // Count active filters
  getActiveFiltersCount() {
    return Object.keys(this.appliedFilters).length;
  }
  // Get data title
  getDataTitle() {
    return this.dataTitle;
  }
  // Advanced options
  hasAdvancedOptions(field) {
    return field.inputType === "input" || field.inputType === "number";
  }
  toggleAdvanced() {
    this.showAdvanced = !this.showAdvanced;
  }
  // Filter summary
  getFilterSummary() {
    const count2 = this.getActiveFiltersCount();
    if (count2 === 0) return "";
    if (count2 === 1) {
      return "1 active filter";
    }
    return `${count2} filters applied`;
  }
  // Estimated results (mock implementation)
  getEstimatedResults() {
    const baseCount = 2240;
    const filterReduction = this.getActiveFiltersCount() * 0.3;
    const estimated = Math.floor(baseCount * (1 - filterReduction));
    return estimated.toLocaleString();
  }
  // Convert to legacy format for backward compatibility
  convertToLegacyFilters() {
    const legacyFilters = [];
    Object.entries(this.appliedFilters).forEach(([field, filter2]) => {
      const fieldObj = this.fields.find((f) => f.value === field);
      if (!fieldObj) return;
      switch (filter2.type) {
        case "select":
          filter2.values.forEach((value) => {
            legacyFilters.push({
              field,
              operator: "eq",
              value,
              inputType: "select"
            });
          });
          break;
        case "boolean":
          legacyFilters.push({
            field,
            operator: "eq",
            value: filter2.value,
            inputType: "boolean"
          });
          break;
        case "range": {
          if (filter2.min && filter2.max) {
            legacyFilters.push({
              field,
              operator: "between",
              value: filter2.min,
              valueTo: filter2.max,
              inputType: fieldObj.inputType
            });
          } else if (filter2.min) {
            legacyFilters.push({
              field,
              operator: "gte",
              value: filter2.min,
              inputType: fieldObj.inputType
            });
          } else if (filter2.max) {
            legacyFilters.push({
              field,
              operator: "lte",
              value: filter2.max,
              inputType: fieldObj.inputType
            });
          }
          break;
        }
        case "text":
          legacyFilters.push({
            field,
            operator: "contains",
            value: filter2.value,
            inputType: "input"
          });
          break;
      }
    });
    return legacyFilters;
  }
  // Convert legacy filters to new format
  convertLegacyFilters(legacyFilters) {
    legacyFilters.forEach((filter2) => {
      const field = filter2.field;
      switch (filter2.inputType) {
        case "select":
          if (!this.appliedFilters[field]) {
            this.appliedFilters[field] = {
              type: "select",
              values: []
            };
          }
          if (!this.appliedFilters[field].values.includes(filter2.value)) {
            this.appliedFilters[field].values.push(filter2.value);
          }
          break;
        case "boolean":
          this.appliedFilters[field] = {
            type: "boolean",
            value: filter2.value
          };
          break;
        case "number":
        case "date":
          if (filter2.operator === "between") {
            this.appliedFilters[field] = {
              type: "range",
              min: filter2.value,
              max: filter2.valueTo
            };
          } else if (filter2.operator === "gte" || filter2.operator === "gt") {
            if (!this.appliedFilters[field]) {
              this.appliedFilters[field] = {
                type: "range"
              };
            }
            this.appliedFilters[field].min = filter2.value;
          } else if (filter2.operator === "lte" || filter2.operator === "lt") {
            if (!this.appliedFilters[field]) {
              this.appliedFilters[field] = {
                type: "range"
              };
            }
            this.appliedFilters[field].max = filter2.value;
          }
          break;
        case "input":
          this.appliedFilters[field] = {
            type: "text",
            value: filter2.value
          };
          break;
      }
    });
  }
  // Dialog actions
  cancel() {
    this.dialogRef.close();
  }
  apply() {
    const legacyFilters = this.convertToLegacyFilters();
    this.dialogRef.close({
      filters: legacyFilters,
      logic: this.logic,
      appliedFilters: this.appliedFilters
    });
  }
  // Legacy method support
  reset() {
    this.appliedFilters = {};
    this.selectedField = "";
    this.selectedFieldObj = null;
    if (this.fields.length > 0) {
      this.selectField(this.fields[0]);
    }
  }
  static {
    this.ɵfac = function FilterComponent_Factory(t) {
      return new (t || _FilterComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _FilterComponent,
      selectors: [["app-filter"]],
      standalone: true,
      features: [ɵɵStandaloneFeature],
      decls: 31,
      vars: 10,
      consts: [[1, "filter-container"], [1, "filter-info"], [1, "info-content"], [1, "info-subtitle"], ["class", "filter-count-badge", 4, "ngIf"], [1, "filter-controls"], [1, "filter-sidebar"], [1, "sidebar-section"], [1, "section-header"], [1, "filter-category"], ["class", "category-item", 4, "ngFor", "ngForOf"], [1, "filter-content"], ["class", "active-filters-summary", 4, "ngIf"], ["class", "field-configuration", 4, "ngIf"], ["class", "no-field-selected", 4, "ngIf"], [1, "filter-footer"], [1, "footer-left"], ["class", "results-preview", 4, "ngIf"], ["class", "filter-summary", 4, "ngIf"], [1, "footer-actions"], ["type", "button", 1, "footer-btn", "cancel-btn", 3, "click"], ["type", "button", 1, "footer-btn", "apply-btn", 3, "click", "disabled"], [1, "btn-icon"], ["class", "apply-count", 4, "ngIf"], [1, "filter-count-badge"], [1, "category-item"], [1, "category-button", 3, "click"], [1, "category-icon"], [1, "category-label"], [1, "category-arrow"], ["class", "applied-filters", 4, "ngIf"], [1, "applied-filters"], ["class", "applied-tag", "type", "button", 3, "click", 4, "ngFor", "ngForOf"], ["type", "button", 1, "applied-tag", 3, "click"], [1, "tag-remove"], [1, "active-filters-summary"], [1, "summary-header"], ["type", "button", 1, "clear-all-btn", 3, "click"], [1, "active-filters-list"], ["class", "active-filter-item", 4, "ngFor", "ngForOf"], [1, "active-filter-item"], [1, "filter-field-name"], [1, "filter-values"], ["class", "filter-value-tag", "type", "button", 3, "click", 4, "ngFor", "ngForOf"], ["type", "button", 1, "filter-value-tag", 3, "click"], [1, "value-remove"], [1, "field-configuration"], [1, "content-header"], [1, "content-subtitle"], ["class", "filter-section", 4, "ngIf"], [1, "filter-section"], [1, "section-title"], [1, "options-grid"], ["class", "option-checkbox", 3, "selected", 4, "ngFor", "ngForOf"], [1, "option-checkbox"], ["type", "checkbox", 1, "checkbox-input", 3, "change", "checked"], [1, "checkbox-custom"], [1, "option-label"], [1, "boolean-options"], [1, "boolean-option"], ["type", "radio", 1, "radio-input", 3, "change", "name", "checked"], [1, "radio-custom"], [1, "range-inputs"], [1, "range-field-group"], [1, "range-label", 3, "for"], ["type", "number", "class", "range-input", "placeholder", "Enter minimum", 3, "id", "value", "input", 4, "ngIf"], ["type", "date", "class", "range-input", 3, "id", "value", "input", 4, "ngIf"], [1, "range-separator"], ["type", "number", "class", "range-input", "placeholder", "Enter maximum", 3, "id", "value", "input", 4, "ngIf"], ["type", "number", "placeholder", "Enter minimum", 1, "range-input", 3, "input", "id", "value"], ["type", "date", 1, "range-input", 3, "input", "id", "value"], ["type", "number", "placeholder", "Enter maximum", 1, "range-input", 3, "input", "id", "value"], [1, "text-input-group"], [1, "text-label", 3, "for"], ["type", "text", "placeholder", "Type to search...", 1, "text-input", 3, "input", "id", "value"], [1, "input-hint"], [1, "no-field-selected"], [1, "empty-state"], [1, "empty-icon"], [1, "results-preview"], [1, "results-label"], [1, "results-count"], [1, "filter-summary"], [1, "apply-count"]],
      template: function FilterComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "div", 0)(1, "div", 1)(2, "div", 2)(3, "h3");
          ɵɵtext(4);
          ɵɵelementEnd();
          ɵɵelementStart(5, "p", 3);
          ɵɵtext(6, "See results in your view based on the filters you select here.");
          ɵɵelementEnd()();
          ɵɵtemplate(7, FilterComponent_div_7_Template, 2, 1, "div", 4);
          ɵɵelementEnd();
          ɵɵelementStart(8, "div", 5)(9, "div", 6)(10, "div", 7)(11, "div", 8);
          ɵɵtext(12, "Filters");
          ɵɵelementEnd();
          ɵɵelementStart(13, "ul", 9);
          ɵɵtemplate(14, FilterComponent_li_14_Template, 9, 5, "li", 10);
          ɵɵelementEnd()()();
          ɵɵelementStart(15, "div", 11);
          ɵɵtemplate(16, FilterComponent_div_16_Template, 8, 2, "div", 12)(17, FilterComponent_div_17_Template, 10, 6, "div", 13)(18, FilterComponent_div_18_Template, 8, 0, "div", 14);
          ɵɵelementEnd()();
          ɵɵelementStart(19, "div", 15)(20, "div", 16);
          ɵɵtemplate(21, FilterComponent_div_21_Template, 5, 1, "div", 17)(22, FilterComponent_div_22_Template, 2, 0, "div", 18);
          ɵɵelementEnd();
          ɵɵelementStart(23, "div", 19)(24, "button", 20);
          ɵɵlistener("click", function FilterComponent_Template_button_click_24_listener() {
            return ctx.cancel();
          });
          ɵɵtext(25, " Cancel ");
          ɵɵelementEnd();
          ɵɵelementStart(26, "button", 21);
          ɵɵlistener("click", function FilterComponent_Template_button_click_26_listener() {
            return ctx.apply();
          });
          ɵɵelementStart(27, "span", 22);
          ɵɵtext(28, "🔍");
          ɵɵelementEnd();
          ɵɵtext(29, " Apply Filters ");
          ɵɵtemplate(30, FilterComponent_span_30_Template, 2, 1, "span", 23);
          ɵɵelementEnd()()()();
        }
        if (rf & 2) {
          ɵɵadvance(4);
          ɵɵtextInterpolate1("Filters for: ", ctx.getDataTitle(), "");
          ɵɵadvance(3);
          ɵɵproperty("ngIf", ctx.getActiveFiltersCount() > 0);
          ɵɵadvance(7);
          ɵɵproperty("ngForOf", ctx.fields);
          ɵɵadvance(2);
          ɵɵproperty("ngIf", ctx.getActiveFiltersCount() > 0);
          ɵɵadvance();
          ɵɵproperty("ngIf", ctx.selectedFieldObj);
          ɵɵadvance();
          ɵɵproperty("ngIf", !ctx.selectedFieldObj);
          ɵɵadvance(3);
          ɵɵproperty("ngIf", ctx.getActiveFiltersCount() > 0);
          ɵɵadvance();
          ɵɵproperty("ngIf", ctx.getActiveFiltersCount() === 0);
          ɵɵadvance(4);
          ɵɵproperty("disabled", ctx.getActiveFiltersCount() === 0);
          ɵɵadvance(4);
          ɵɵproperty("ngIf", ctx.getActiveFiltersCount() > 0);
        }
      },
      dependencies: [CommonModule, NgForOf, NgIf, FormsModule, MatSelectModule, MatFormFieldModule, MatOptionModule],
      styles: ['@charset "UTF-8";.filter-container[_ngcontent-%COMP%]{display:flex;flex-direction:column;width:100%;height:100%;min-height:600px;max-height:70vh;overflow:hidden}.filter-info[_ngcontent-%COMP%]{background:var(--page-background-color);border:var(--primary-border);border-radius:var(--input-radius);padding:12px 16px;margin-bottom:16px;display:flex;align-items:center;justify-content:space-between;flex-shrink:0}.filter-info[_ngcontent-%COMP%]   .info-content[_ngcontent-%COMP%]   h3[_ngcontent-%COMP%]{margin:0 0 2px;font-size:16px;font-weight:600;color:var(--primary-font-color);line-height:1.2}.filter-info[_ngcontent-%COMP%]   .info-content[_ngcontent-%COMP%]   .info-subtitle[_ngcontent-%COMP%]{margin:0;font-size:var(--tertiary-font-size);color:var(--secondary-font-color);line-height:1.3}.filter-info[_ngcontent-%COMP%]   .filter-count-badge[_ngcontent-%COMP%]{background:var(--primary-color);color:var(--surface-color);font-size:12px;font-weight:600;padding:6px 12px;border-radius:16px;border:none}.filter-controls[_ngcontent-%COMP%]{display:flex;flex:1;min-height:400px;overflow:hidden;border:var(--primary-border);border-radius:var(--input-radius);background:var(--surface-color)}.filter-sidebar[_ngcontent-%COMP%]{width:280px;background:var(--page-background-color);border-right:var(--primary-border);border-radius:var(--input-radius) 0 0 0;padding:20px 0;overflow-y:auto;max-height:100%}.filter-sidebar[_ngcontent-%COMP%]   .sidebar-section[_ngcontent-%COMP%]   .section-header[_ngcontent-%COMP%]{padding:0 24px 12px;font-size:var(--tertiary-font-size);font-weight:var(--primary-font-weight);color:var(--secondary-font-color);text-transform:uppercase;letter-spacing:.5px}.filter-sidebar[_ngcontent-%COMP%]   .sidebar-section[_ngcontent-%COMP%]   .filter-category[_ngcontent-%COMP%]{margin:0;list-style:none;padding:0}.filter-sidebar[_ngcontent-%COMP%]   .sidebar-section[_ngcontent-%COMP%]   .filter-category[_ngcontent-%COMP%]   .category-item[_ngcontent-%COMP%]{margin:0}.filter-sidebar[_ngcontent-%COMP%]   .sidebar-section[_ngcontent-%COMP%]   .filter-category[_ngcontent-%COMP%]   .category-item[_ngcontent-%COMP%]   .category-button[_ngcontent-%COMP%]{width:100%;background:none;border:none;padding:12px 24px;text-align:left;cursor:pointer;display:flex;align-items:center;justify-content:space-between;font-size:14px;color:var(--primary-font-color);transition:all .2s ease;position:relative}.filter-sidebar[_ngcontent-%COMP%]   .sidebar-section[_ngcontent-%COMP%]   .filter-category[_ngcontent-%COMP%]   .category-item[_ngcontent-%COMP%]   .category-button[_ngcontent-%COMP%]:hover{background:var(--secondary-background-color)}.filter-sidebar[_ngcontent-%COMP%]   .sidebar-section[_ngcontent-%COMP%]   .filter-category[_ngcontent-%COMP%]   .category-item[_ngcontent-%COMP%]   .category-button.active[_ngcontent-%COMP%]{background:var(--diet-quinary-color);color:var(--primary-color);font-weight:var(--primary-font-weight)}.filter-sidebar[_ngcontent-%COMP%]   .sidebar-section[_ngcontent-%COMP%]   .filter-category[_ngcontent-%COMP%]   .category-item[_ngcontent-%COMP%]   .category-button.active[_ngcontent-%COMP%]:before{content:"";position:absolute;left:0;top:0;bottom:0;width:3px;background:var(--primary-color)}.filter-sidebar[_ngcontent-%COMP%]   .sidebar-section[_ngcontent-%COMP%]   .filter-category[_ngcontent-%COMP%]   .category-item[_ngcontent-%COMP%]   .category-button[_ngcontent-%COMP%]   .category-icon[_ngcontent-%COMP%]{margin-right:12px;font-size:16px}.filter-sidebar[_ngcontent-%COMP%]   .sidebar-section[_ngcontent-%COMP%]   .filter-category[_ngcontent-%COMP%]   .category-item[_ngcontent-%COMP%]   .category-button[_ngcontent-%COMP%]   .category-label[_ngcontent-%COMP%]{flex:1}.filter-sidebar[_ngcontent-%COMP%]   .sidebar-section[_ngcontent-%COMP%]   .filter-category[_ngcontent-%COMP%]   .category-item[_ngcontent-%COMP%]   .category-button[_ngcontent-%COMP%]   .category-arrow[_ngcontent-%COMP%]{font-size:12px;color:var(--tertiary-color)}.filter-sidebar[_ngcontent-%COMP%]   .sidebar-section[_ngcontent-%COMP%]   .filter-category[_ngcontent-%COMP%]   .category-item[_ngcontent-%COMP%]   .applied-filters[_ngcontent-%COMP%]{padding:0 24px 0 52px;margin-top:8px}.filter-sidebar[_ngcontent-%COMP%]   .sidebar-section[_ngcontent-%COMP%]   .filter-category[_ngcontent-%COMP%]   .category-item[_ngcontent-%COMP%]   .applied-filters[_ngcontent-%COMP%]   .applied-tag[_ngcontent-%COMP%]{display:inline-flex;align-items:center;background:var(--status-info-bg);color:var(--status-info-color);font-size:12px;padding:4px 8px;border-radius:6px;margin:2px 4px 2px 0;border:var(--status-info-border);cursor:pointer;transition:all .2s ease}.filter-sidebar[_ngcontent-%COMP%]   .sidebar-section[_ngcontent-%COMP%]   .filter-category[_ngcontent-%COMP%]   .category-item[_ngcontent-%COMP%]   .applied-filters[_ngcontent-%COMP%]   .applied-tag[_ngcontent-%COMP%]:hover{background:var(--status-info-color);color:var(--surface-color)}.filter-sidebar[_ngcontent-%COMP%]   .sidebar-section[_ngcontent-%COMP%]   .filter-category[_ngcontent-%COMP%]   .category-item[_ngcontent-%COMP%]   .applied-filters[_ngcontent-%COMP%]   .applied-tag[_ngcontent-%COMP%]   .tag-remove[_ngcontent-%COMP%]{margin-left:6px;font-weight:700;color:var(--status-info-color)}.filter-sidebar[_ngcontent-%COMP%]   .sidebar-section[_ngcontent-%COMP%]   .filter-category[_ngcontent-%COMP%]   .category-item[_ngcontent-%COMP%]   .applied-filters[_ngcontent-%COMP%]   .applied-tag[_ngcontent-%COMP%]   .tag-remove[_ngcontent-%COMP%]:hover{color:var(--surface-color)}.filter-content[_ngcontent-%COMP%]{flex:1;padding:20px 24px;overflow-y:auto;background:var(--surface-color);border-radius:0 8px 0 0;max-height:100%}.filter-content[_ngcontent-%COMP%]   .active-filters-summary[_ngcontent-%COMP%]{background:var(--page-background-color);border:var(--primary-border);border-radius:8px;padding:20px;margin-bottom:24px}.filter-content[_ngcontent-%COMP%]   .active-filters-summary[_ngcontent-%COMP%]   .summary-header[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:space-between;margin-bottom:16px}.filter-content[_ngcontent-%COMP%]   .active-filters-summary[_ngcontent-%COMP%]   .summary-header[_ngcontent-%COMP%]   h3[_ngcontent-%COMP%]{margin:0;font-size:16px;font-weight:600;color:var(--primary-font-color)}.filter-content[_ngcontent-%COMP%]   .active-filters-summary[_ngcontent-%COMP%]   .summary-header[_ngcontent-%COMP%]   .clear-all-btn[_ngcontent-%COMP%]{background:none;border:var(--primary-border);color:var(--secondary-font-color);font-size:12px;padding:6px 12px;border-radius:6px;cursor:pointer;transition:all .2s ease}.filter-content[_ngcontent-%COMP%]   .active-filters-summary[_ngcontent-%COMP%]   .summary-header[_ngcontent-%COMP%]   .clear-all-btn[_ngcontent-%COMP%]:hover{background:var(--secondary-background-color);border-color:var(--tertiary-color)}.filter-content[_ngcontent-%COMP%]   .active-filters-summary[_ngcontent-%COMP%]   .active-filters-list[_ngcontent-%COMP%]   .active-filter-item[_ngcontent-%COMP%]{margin-bottom:12px}.filter-content[_ngcontent-%COMP%]   .active-filters-summary[_ngcontent-%COMP%]   .active-filters-list[_ngcontent-%COMP%]   .active-filter-item[_ngcontent-%COMP%]   .filter-field-name[_ngcontent-%COMP%]{font-size:13px;font-weight:600;color:#475569;margin-bottom:6px}.filter-content[_ngcontent-%COMP%]   .active-filters-summary[_ngcontent-%COMP%]   .active-filters-list[_ngcontent-%COMP%]   .active-filter-item[_ngcontent-%COMP%]   .filter-values[_ngcontent-%COMP%]{display:flex;flex-wrap:wrap;gap:6px}.filter-content[_ngcontent-%COMP%]   .active-filters-summary[_ngcontent-%COMP%]   .active-filters-list[_ngcontent-%COMP%]   .active-filter-item[_ngcontent-%COMP%]   .filter-values[_ngcontent-%COMP%]   .filter-value-tag[_ngcontent-%COMP%]{background:var(--primary-color);color:var(--surface-color);font-size:12px;padding:4px 10px;border-radius:16px;border:none;cursor:pointer;transition:all .2s ease;display:inline-flex;align-items:center;gap:6px}.filter-content[_ngcontent-%COMP%]   .active-filters-summary[_ngcontent-%COMP%]   .active-filters-list[_ngcontent-%COMP%]   .active-filter-item[_ngcontent-%COMP%]   .filter-values[_ngcontent-%COMP%]   .filter-value-tag[_ngcontent-%COMP%]:hover{background:#0e9a9a}.filter-content[_ngcontent-%COMP%]   .active-filters-summary[_ngcontent-%COMP%]   .active-filters-list[_ngcontent-%COMP%]   .active-filter-item[_ngcontent-%COMP%]   .filter-values[_ngcontent-%COMP%]   .filter-value-tag[_ngcontent-%COMP%]   .value-remove[_ngcontent-%COMP%]{font-weight:700;opacity:.8}.filter-content[_ngcontent-%COMP%]   .active-filters-summary[_ngcontent-%COMP%]   .active-filters-list[_ngcontent-%COMP%]   .active-filter-item[_ngcontent-%COMP%]   .filter-values[_ngcontent-%COMP%]   .filter-value-tag[_ngcontent-%COMP%]   .value-remove[_ngcontent-%COMP%]:hover{opacity:1}.filter-content[_ngcontent-%COMP%]   .field-configuration[_ngcontent-%COMP%]   .content-header[_ngcontent-%COMP%]{margin-bottom:24px}.filter-content[_ngcontent-%COMP%]   .field-configuration[_ngcontent-%COMP%]   .content-header[_ngcontent-%COMP%]   h3[_ngcontent-%COMP%]{margin:0 0 8px;font-size:20px;font-weight:600;color:var(--primary-font-color)}.filter-content[_ngcontent-%COMP%]   .field-configuration[_ngcontent-%COMP%]   .content-header[_ngcontent-%COMP%]   .content-subtitle[_ngcontent-%COMP%]{margin:0;font-size:14px;color:var(--secondary-font-color);line-height:1.5}.filter-content[_ngcontent-%COMP%]   .field-configuration[_ngcontent-%COMP%]   .filter-section[_ngcontent-%COMP%]   .section-title[_ngcontent-%COMP%]{font-size:16px;font-weight:600;color:var(--primary-font-color);margin:0 0 16px}.filter-content[_ngcontent-%COMP%]   .field-configuration[_ngcontent-%COMP%]   .filter-section[_ngcontent-%COMP%]   .options-grid[_ngcontent-%COMP%]{display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:12px}.filter-content[_ngcontent-%COMP%]   .field-configuration[_ngcontent-%COMP%]   .filter-section[_ngcontent-%COMP%]   .options-grid[_ngcontent-%COMP%]   .option-checkbox[_ngcontent-%COMP%]{display:flex;align-items:center;padding:12px 16px;border:var(--primary-border);border-radius:8px;cursor:pointer;transition:all .2s ease;background:var(--surface-color)}.filter-content[_ngcontent-%COMP%]   .field-configuration[_ngcontent-%COMP%]   .filter-section[_ngcontent-%COMP%]   .options-grid[_ngcontent-%COMP%]   .option-checkbox[_ngcontent-%COMP%]:hover{border-color:#d1d5db;background:#f9fafb}.filter-content[_ngcontent-%COMP%]   .field-configuration[_ngcontent-%COMP%]   .filter-section[_ngcontent-%COMP%]   .options-grid[_ngcontent-%COMP%]   .option-checkbox.selected[_ngcontent-%COMP%]{border-color:var(--primary-color);background:#f0fdfa}.filter-content[_ngcontent-%COMP%]   .field-configuration[_ngcontent-%COMP%]   .filter-section[_ngcontent-%COMP%]   .options-grid[_ngcontent-%COMP%]   .option-checkbox[_ngcontent-%COMP%]   .checkbox-input[_ngcontent-%COMP%]{display:none}.filter-content[_ngcontent-%COMP%]   .field-configuration[_ngcontent-%COMP%]   .filter-section[_ngcontent-%COMP%]   .options-grid[_ngcontent-%COMP%]   .option-checkbox[_ngcontent-%COMP%]   .checkbox-custom[_ngcontent-%COMP%]{width:20px;height:20px;border:2px solid #d1d5db;border-radius:4px;margin-right:12px;position:relative;flex-shrink:0;transition:all .2s ease}.filter-content[_ngcontent-%COMP%]   .field-configuration[_ngcontent-%COMP%]   .filter-section[_ngcontent-%COMP%]   .options-grid[_ngcontent-%COMP%]   .option-checkbox[_ngcontent-%COMP%]   .checkbox-custom[_ngcontent-%COMP%]:after{content:"\\2713";position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:var(--surface-color);font-size:12px;font-weight:700;opacity:0;transition:opacity .2s ease}.filter-content[_ngcontent-%COMP%]   .field-configuration[_ngcontent-%COMP%]   .filter-section[_ngcontent-%COMP%]   .options-grid[_ngcontent-%COMP%]   .option-checkbox.selected[_ngcontent-%COMP%]   .checkbox-custom[_ngcontent-%COMP%]{background:var(--primary-color);border-color:var(--primary-color)}.filter-content[_ngcontent-%COMP%]   .field-configuration[_ngcontent-%COMP%]   .filter-section[_ngcontent-%COMP%]   .options-grid[_ngcontent-%COMP%]   .option-checkbox.selected[_ngcontent-%COMP%]   .checkbox-custom[_ngcontent-%COMP%]:after{opacity:1}.filter-content[_ngcontent-%COMP%]   .field-configuration[_ngcontent-%COMP%]   .filter-section[_ngcontent-%COMP%]   .options-grid[_ngcontent-%COMP%]   .option-checkbox[_ngcontent-%COMP%]   .option-label[_ngcontent-%COMP%]{font-size:14px;color:var(--primary-font-color);font-weight:500}.filter-content[_ngcontent-%COMP%]   .field-configuration[_ngcontent-%COMP%]   .filter-section[_ngcontent-%COMP%]   .boolean-options[_ngcontent-%COMP%]{display:flex;gap:16px}.filter-content[_ngcontent-%COMP%]   .field-configuration[_ngcontent-%COMP%]   .filter-section[_ngcontent-%COMP%]   .boolean-options[_ngcontent-%COMP%]   .boolean-option[_ngcontent-%COMP%]{display:flex;align-items:center;padding:16px 20px;border:var(--primary-border);border-radius:8px;cursor:pointer;transition:all .2s ease;background:var(--surface-color);min-width:120px}.filter-content[_ngcontent-%COMP%]   .field-configuration[_ngcontent-%COMP%]   .filter-section[_ngcontent-%COMP%]   .boolean-options[_ngcontent-%COMP%]   .boolean-option[_ngcontent-%COMP%]:hover{border-color:#d1d5db;background:#f9fafb}.filter-content[_ngcontent-%COMP%]   .field-configuration[_ngcontent-%COMP%]   .filter-section[_ngcontent-%COMP%]   .boolean-options[_ngcontent-%COMP%]   .boolean-option.selected[_ngcontent-%COMP%]{border-color:var(--primary-color);background:#f0fdfa}.filter-content[_ngcontent-%COMP%]   .field-configuration[_ngcontent-%COMP%]   .filter-section[_ngcontent-%COMP%]   .boolean-options[_ngcontent-%COMP%]   .boolean-option[_ngcontent-%COMP%]   .radio-input[_ngcontent-%COMP%]{display:none}.filter-content[_ngcontent-%COMP%]   .field-configuration[_ngcontent-%COMP%]   .filter-section[_ngcontent-%COMP%]   .boolean-options[_ngcontent-%COMP%]   .boolean-option[_ngcontent-%COMP%]   .radio-custom[_ngcontent-%COMP%]{width:20px;height:20px;border:2px solid #d1d5db;border-radius:50%;margin-right:12px;position:relative;flex-shrink:0;transition:all .2s ease}.filter-content[_ngcontent-%COMP%]   .field-configuration[_ngcontent-%COMP%]   .filter-section[_ngcontent-%COMP%]   .boolean-options[_ngcontent-%COMP%]   .boolean-option[_ngcontent-%COMP%]   .radio-custom[_ngcontent-%COMP%]:after{content:"";position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:8px;height:8px;background:var(--primary-color);border-radius:50%;opacity:0;transition:opacity .2s ease}.filter-content[_ngcontent-%COMP%]   .field-configuration[_ngcontent-%COMP%]   .filter-section[_ngcontent-%COMP%]   .boolean-options[_ngcontent-%COMP%]   .boolean-option.selected[_ngcontent-%COMP%]   .radio-custom[_ngcontent-%COMP%]{border-color:var(--primary-color)}.filter-content[_ngcontent-%COMP%]   .field-configuration[_ngcontent-%COMP%]   .filter-section[_ngcontent-%COMP%]   .boolean-options[_ngcontent-%COMP%]   .boolean-option.selected[_ngcontent-%COMP%]   .radio-custom[_ngcontent-%COMP%]:after{opacity:1}.filter-content[_ngcontent-%COMP%]   .field-configuration[_ngcontent-%COMP%]   .filter-section[_ngcontent-%COMP%]   .boolean-options[_ngcontent-%COMP%]   .boolean-option[_ngcontent-%COMP%]   .option-label[_ngcontent-%COMP%]{font-size:14px;color:var(--primary-font-color);font-weight:500}.filter-content[_ngcontent-%COMP%]   .field-configuration[_ngcontent-%COMP%]   .filter-section[_ngcontent-%COMP%]   .range-inputs[_ngcontent-%COMP%]{display:flex;align-items:flex-end;gap:16px}.filter-content[_ngcontent-%COMP%]   .field-configuration[_ngcontent-%COMP%]   .filter-section[_ngcontent-%COMP%]   .range-inputs[_ngcontent-%COMP%]   .range-field-group[_ngcontent-%COMP%]{flex:1}.filter-content[_ngcontent-%COMP%]   .field-configuration[_ngcontent-%COMP%]   .filter-section[_ngcontent-%COMP%]   .range-inputs[_ngcontent-%COMP%]   .range-field-group[_ngcontent-%COMP%]   .range-label[_ngcontent-%COMP%]{display:block;font-size:13px;font-weight:500;color:#374151;margin-bottom:8px}.filter-content[_ngcontent-%COMP%]   .field-configuration[_ngcontent-%COMP%]   .filter-section[_ngcontent-%COMP%]   .range-inputs[_ngcontent-%COMP%]   .range-field-group[_ngcontent-%COMP%]   .range-input[_ngcontent-%COMP%]{width:100%;padding:12px 16px;border:var(--primary-border);border-radius:8px;font-size:14px;background:var(--surface-color);transition:border-color .2s ease}.filter-content[_ngcontent-%COMP%]   .field-configuration[_ngcontent-%COMP%]   .filter-section[_ngcontent-%COMP%]   .range-inputs[_ngcontent-%COMP%]   .range-field-group[_ngcontent-%COMP%]   .range-input[_ngcontent-%COMP%]:focus{outline:none;border-color:var(--primary-color);box-shadow:0 0 0 3px #10b3b31a}.filter-content[_ngcontent-%COMP%]   .field-configuration[_ngcontent-%COMP%]   .filter-section[_ngcontent-%COMP%]   .range-inputs[_ngcontent-%COMP%]   .range-separator[_ngcontent-%COMP%]{padding:12px 8px 0;font-size:14px;color:var(--secondary-font-color);font-weight:500}.filter-content[_ngcontent-%COMP%]   .field-configuration[_ngcontent-%COMP%]   .filter-section[_ngcontent-%COMP%]   .text-input-group[_ngcontent-%COMP%]   .text-label[_ngcontent-%COMP%]{display:block;font-size:13px;font-weight:500;color:#374151;margin-bottom:8px}.filter-content[_ngcontent-%COMP%]   .field-configuration[_ngcontent-%COMP%]   .filter-section[_ngcontent-%COMP%]   .text-input-group[_ngcontent-%COMP%]   .text-input[_ngcontent-%COMP%]{width:100%;padding:12px 16px;border:var(--primary-border);border-radius:8px;font-size:14px;background:var(--surface-color);transition:border-color .2s ease}.filter-content[_ngcontent-%COMP%]   .field-configuration[_ngcontent-%COMP%]   .filter-section[_ngcontent-%COMP%]   .text-input-group[_ngcontent-%COMP%]   .text-input[_ngcontent-%COMP%]:focus{outline:none;border-color:var(--primary-color);box-shadow:0 0 0 3px #10b3b31a}.filter-content[_ngcontent-%COMP%]   .field-configuration[_ngcontent-%COMP%]   .filter-section[_ngcontent-%COMP%]   .text-input-group[_ngcontent-%COMP%]   .input-hint[_ngcontent-%COMP%]{display:block;font-size:12px;color:var(--secondary-font-color);margin-top:6px}.filter-content[_ngcontent-%COMP%]   .no-field-selected[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center;height:100%;min-height:300px}.filter-content[_ngcontent-%COMP%]   .no-field-selected[_ngcontent-%COMP%]   .empty-state[_ngcontent-%COMP%]{text-align:center;max-width:400px}.filter-content[_ngcontent-%COMP%]   .no-field-selected[_ngcontent-%COMP%]   .empty-state[_ngcontent-%COMP%]   .empty-icon[_ngcontent-%COMP%]{font-size:48px;margin-bottom:16px}.filter-content[_ngcontent-%COMP%]   .no-field-selected[_ngcontent-%COMP%]   .empty-state[_ngcontent-%COMP%]   h3[_ngcontent-%COMP%]{margin:0 0 12px;font-size:20px;font-weight:600;color:var(--primary-font-color)}.filter-content[_ngcontent-%COMP%]   .no-field-selected[_ngcontent-%COMP%]   .empty-state[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{margin:0;font-size:14px;color:var(--secondary-font-color);line-height:1.5}.filter-footer[_ngcontent-%COMP%]{background:var(--surface-color);border-top:var(--primary-border);border-radius:0 0 8px 8px;padding:16px 20px;display:flex;align-items:center;justify-content:space-between;flex-shrink:0;min-height:70px}.filter-footer[_ngcontent-%COMP%]   .footer-left[_ngcontent-%COMP%]{display:flex;align-items:center;gap:16px}.filter-footer[_ngcontent-%COMP%]   .footer-left[_ngcontent-%COMP%]   .results-preview[_ngcontent-%COMP%]{display:flex;align-items:center;gap:8px}.filter-footer[_ngcontent-%COMP%]   .footer-left[_ngcontent-%COMP%]   .results-preview[_ngcontent-%COMP%]   .results-label[_ngcontent-%COMP%]{font-size:14px;color:var(--secondary-font-color)}.filter-footer[_ngcontent-%COMP%]   .footer-left[_ngcontent-%COMP%]   .results-preview[_ngcontent-%COMP%]   .results-count[_ngcontent-%COMP%]{font-size:16px;font-weight:600;color:var(--primary-color);background:var(--status-success-bg);padding:4px 12px;border-radius:6px;border:var(--status-success-border)}.filter-footer[_ngcontent-%COMP%]   .footer-left[_ngcontent-%COMP%]   .filter-summary[_ngcontent-%COMP%]{font-size:14px;color:#6b7280;background:var(--secondary-background-color);padding:8px 12px;border-radius:6px}.filter-footer[_ngcontent-%COMP%]   .footer-actions[_ngcontent-%COMP%]{display:flex;align-items:center;gap:12px}.filter-footer[_ngcontent-%COMP%]   .footer-actions[_ngcontent-%COMP%]   .footer-btn[_ngcontent-%COMP%]{padding:12px 24px;border-radius:8px;font-size:14px;font-weight:600;cursor:pointer;transition:all .2s ease;display:flex;align-items:center;gap:8px;border:none}.filter-footer[_ngcontent-%COMP%]   .footer-actions[_ngcontent-%COMP%]   .footer-btn.cancel-btn[_ngcontent-%COMP%]{background:var(--surface-color);color:var(--secondary-font-color);border:var(--primary-border)}.filter-footer[_ngcontent-%COMP%]   .footer-actions[_ngcontent-%COMP%]   .footer-btn.cancel-btn[_ngcontent-%COMP%]:hover{background:#f9fafb;border-color:#d1d5db}.filter-footer[_ngcontent-%COMP%]   .footer-actions[_ngcontent-%COMP%]   .footer-btn.apply-btn[_ngcontent-%COMP%]{background:var(--primary-color);color:var(--surface-color);border:2px solid var(--primary-color);box-shadow:0 4px 12px #10b3b34d}.filter-footer[_ngcontent-%COMP%]   .footer-actions[_ngcontent-%COMP%]   .footer-btn.apply-btn[_ngcontent-%COMP%]:hover:not(:disabled){background:#0e9a9a;border-color:#0e9a9a;transform:translateY(-1px);box-shadow:0 6px 16px #10b3b366}.filter-footer[_ngcontent-%COMP%]   .footer-actions[_ngcontent-%COMP%]   .footer-btn.apply-btn[_ngcontent-%COMP%]:disabled{background:#9ca3af;border-color:#9ca3af;cursor:not-allowed;transform:none;box-shadow:none}.filter-footer[_ngcontent-%COMP%]   .footer-actions[_ngcontent-%COMP%]   .footer-btn.apply-btn[_ngcontent-%COMP%]   .apply-count[_ngcontent-%COMP%]{background:#fff3;padding:2px 6px;border-radius:10px;font-size:12px;margin-left:4px}.filter-footer[_ngcontent-%COMP%]   .footer-actions[_ngcontent-%COMP%]   .footer-btn[_ngcontent-%COMP%]   .btn-icon[_ngcontent-%COMP%]{font-size:16px}@media (max-width: 768px){.filter-container[_ngcontent-%COMP%]{min-width:95vw;max-width:95vw;max-height:90vh}.filter-controls[_ngcontent-%COMP%]{flex-direction:column}.filter-sidebar[_ngcontent-%COMP%]{width:100%;max-height:200px;order:2}.filter-content[_ngcontent-%COMP%]{order:1;padding:16px 20px}.filter-footer[_ngcontent-%COMP%]{padding:16px 20px;flex-direction:column;gap:12px}.filter-footer[_ngcontent-%COMP%]   .footer-left[_ngcontent-%COMP%], .filter-footer[_ngcontent-%COMP%]   .footer-actions[_ngcontent-%COMP%]{width:100%;justify-content:center}}@keyframes _ngcontent-%COMP%_slideInUp{0%{opacity:0;transform:translateY(20px)}to{opacity:1;transform:translateY(0)}}'],
      data: {
        animation: [trigger("slideIn", [transition(":enter", [style({
          opacity: 0,
          transform: "translateX(20px)"
        }), animate("300ms ease-out", style({
          opacity: 1,
          transform: "translateX(0)"
        }))])])]
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterComponent, [{
    type: Component,
    args: [{
      selector: "app-filter",
      standalone: true,
      imports: [CommonModule, FormsModule, AppSelectboxComponent, AppButtonComponent, AppInputComponent, DatePickerComponent, MatSelectModule, MatFormFieldModule, MatOptionModule],
      animations: [trigger("slideIn", [transition(":enter", [style({
        opacity: 0,
        transform: "translateX(20px)"
      }), animate("300ms ease-out", style({
        opacity: 1,
        transform: "translateX(0)"
      }))])])],
      template: `<div class="filter-container">
  <!-- Filter Info Header -->
  <div class="filter-info">
    <div class="info-content">
      <h3>Filters for: {{ getDataTitle() }}</h3>
      <p class="info-subtitle">See results in your view based on the filters you select here.</p>
    </div>
    <div class="filter-count-badge" *ngIf="getActiveFiltersCount() > 0">
      {{ getActiveFiltersCount() }} applied
    </div>
  </div>

  <!-- Main Content -->
  <div class="filter-controls">
    <!-- Left Sidebar -->
    <div class="filter-sidebar">
      <div class="sidebar-section">
        <div class="section-header">Filters</div>
        <ul class="filter-category">
          <li class="category-item" *ngFor="let field of fields; let i = index">
            <button 
              class="category-button" 
              [class.active]="selectedField === field.value"
              (click)="selectField(field)">
              <span class="category-icon">{{ getFieldIcon(field.inputType) }}</span>
              <span class="category-label">{{ field.label }}</span>
              <span class="category-arrow">›</span>
            </button>
            <div class="applied-filters" *ngIf="getFieldFilters(field.value).length > 0">
              <button 
                class="applied-tag" 
                *ngFor="let filter of getFieldFilters(field.value)"
                (click)="removeFieldFilter(field.value, filter)"
                type="button">
                {{ getFilterDisplayText(filter) }}
                <span class="tag-remove">×</span>
              </button>
            </div>
          </li>
        </ul>
      </div>
    </div>

    <!-- Right Content -->
    <div class="filter-content">
      <!-- Active Filters Summary -->
      <div class="active-filters-summary" *ngIf="getActiveFiltersCount() > 0">
        <div class="summary-header">
          <h3>Active Filters ({{ getActiveFiltersCount() }})</h3>
          <button class="clear-all-btn" (click)="clearAllFilters()" type="button">Clear All</button>
        </div>
        <div class="active-filters-list">
          <div class="active-filter-item" *ngFor="let fieldName of getActiveFilterFields()">
            <div class="filter-field-name">{{ getFieldLabel(fieldName) }}</div>
            <div class="filter-values">
              <button 
                class="filter-value-tag"
                *ngFor="let value of getFieldFilters(fieldName)"
                (click)="removeFieldFilter(fieldName, value)"
                type="button">
                {{ getFilterDisplayText(value) }}
                <span class="value-remove">×</span>
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- Field Configuration -->
      <div class="field-configuration" *ngIf="selectedFieldObj">
        <div class="content-header">
          <h3>{{ selectedFieldObj.label }}</h3>
          <p class="content-subtitle">{{ getFieldDescription(selectedFieldObj) }}</p>
        </div>

        <!-- Select Type Configuration -->
        <div class="filter-section" *ngIf="selectedFieldObj.inputType === 'select'">
          <div class="section-title">Available Options</div>
          <div class="options-grid">
            <label 
              class="option-checkbox"
              *ngFor="let option of getValues(selectedFieldObj.value)"
              [class.selected]="isOptionSelected(selectedFieldObj.value, option)">
              <input 
                type="checkbox"
                [checked]="isOptionSelected(selectedFieldObj.value, option)"
                (change)="toggleOption(selectedFieldObj.value, option)"
                class="checkbox-input">
              <span class="checkbox-custom"></span>
              <span class="option-label">{{ option }}</span>
            </label>
          </div>
        </div>

        <!-- Boolean Type Configuration -->
        <div class="filter-section" *ngIf="selectedFieldObj.inputType === 'boolean'">
          <div class="section-title">Select Value</div>
          <div class="boolean-options">
            <label class="boolean-option" [class.selected]="isBooleanSelected(selectedFieldObj.value, true)">
              <input 
                type="radio" 
                [name]="'boolean-' + selectedFieldObj.value"
                [checked]="isBooleanSelected(selectedFieldObj.value, true)"
                (change)="setBooleanValue(selectedFieldObj.value, true)"
                class="radio-input">
              <span class="radio-custom"></span>
              <span class="option-label">True</span>
            </label>
            <label class="boolean-option" [class.selected]="isBooleanSelected(selectedFieldObj.value, false)">
              <input 
                type="radio" 
                [name]="'boolean-' + selectedFieldObj.value"
                [checked]="isBooleanSelected(selectedFieldObj.value, false)"
                (change)="setBooleanValue(selectedFieldObj.value, false)"
                class="radio-input">
              <span class="radio-custom"></span>
              <span class="option-label">False</span>
            </label>
          </div>
        </div>

        <!-- Number/Date Range Configuration -->
        <div class="filter-section" *ngIf="selectedFieldObj.inputType === 'number' || selectedFieldObj.inputType === 'date'">
          <div class="section-title">Set Range</div>
          <div class="range-inputs">
            <div class="range-field-group">
              <label class="range-label" [for]="'min-' + selectedFieldObj.value">
                {{ selectedFieldObj.inputType === 'date' ? 'From Date' : 'Minimum Value' }}
              </label>
              <input 
                *ngIf="selectedFieldObj.inputType === 'number'"
                type="number" 
                class="range-input"
                [id]="'min-' + selectedFieldObj.value"
                [value]="getRangeValue(selectedFieldObj.value, 'min')"
                (input)="setRangeMinValue(selectedFieldObj.value, $event)"
                placeholder="Enter minimum">
              <input 
                *ngIf="selectedFieldObj.inputType === 'date'"
                type="date" 
                class="range-input"
                [id]="'min-' + selectedFieldObj.value"
                [value]="getRangeValue(selectedFieldObj.value, 'min')"
                (input)="setRangeMinValue(selectedFieldObj.value, $event)">
            </div>
            <div class="range-separator">to</div>
            <div class="range-field-group">
              <label class="range-label" [for]="'max-' + selectedFieldObj.value">
                {{ selectedFieldObj.inputType === 'date' ? 'To Date' : 'Maximum Value' }}
              </label>
              <input 
                *ngIf="selectedFieldObj.inputType === 'number'"
                type="number" 
                class="range-input"
                [id]="'max-' + selectedFieldObj.value"
                [value]="getRangeValue(selectedFieldObj.value, 'max')"
                (input)="setRangeMaxValue(selectedFieldObj.value, $event)"
                placeholder="Enter maximum">
              <input 
                *ngIf="selectedFieldObj.inputType === 'date'"
                type="date" 
                class="range-input"
                [id]="'max-' + selectedFieldObj.value"
                [value]="getRangeValue(selectedFieldObj.value, 'max')"
                (input)="setRangeMaxValue(selectedFieldObj.value, $event)">
            </div>
          </div>
        </div>

        <!-- Text Input Configuration -->
        <div class="filter-section" *ngIf="selectedFieldObj.inputType === 'input'">
          <div class="section-title">Search Text</div>
          <div class="text-input-group">
            <label class="text-label" [for]="'text-' + selectedFieldObj.value">
              Enter search term for {{ selectedFieldObj.label.toLowerCase() }}
            </label>
            <input 
              type="text" 
              class="text-input"
              [id]="'text-' + selectedFieldObj.value"
              [value]="getTextValue(selectedFieldObj.value)"
              (input)="setTextValue(selectedFieldObj.value, $event)"
              placeholder="Type to search...">
            <small class="input-hint">Search will match any part of the text</small>
          </div>
        </div>
      </div>

      <!-- No Field Selected State -->
      <div class="no-field-selected" *ngIf="!selectedFieldObj">
        <div class="empty-state">
          <div class="empty-icon">🎯</div>
          <h3>Select a Filter</h3>
          <p>Choose a field from the sidebar to configure your filters. You can apply multiple filters to narrow down your results.</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Footer -->
  <div class="filter-footer">
    <div class="footer-left">
      <div class="results-preview" *ngIf="getActiveFiltersCount() > 0">
        <span class="results-label">Results:</span>
        <span class="results-count">{{ getEstimatedResults() }}</span>
      </div>
      <div class="filter-summary" *ngIf="getActiveFiltersCount() === 0">
        No filters applied - showing all results
      </div>
    </div>
    <div class="footer-actions">
      <button class="footer-btn cancel-btn" (click)="cancel()" type="button">
        Cancel
      </button>
      <button class="footer-btn apply-btn" (click)="apply()" type="button" [disabled]="getActiveFiltersCount() === 0">
        <span class="btn-icon">🔍</span>
        Apply Filters
        <span class="apply-count" *ngIf="getActiveFiltersCount() > 0">({{ getActiveFiltersCount() }})</span>
      </button>
    </div>
  </div>
</div>`,
      styles: ['@charset "UTF-8";.filter-container{display:flex;flex-direction:column;width:100%;height:100%;min-height:600px;max-height:70vh;overflow:hidden}.filter-info{background:var(--page-background-color);border:var(--primary-border);border-radius:var(--input-radius);padding:12px 16px;margin-bottom:16px;display:flex;align-items:center;justify-content:space-between;flex-shrink:0}.filter-info .info-content h3{margin:0 0 2px;font-size:16px;font-weight:600;color:var(--primary-font-color);line-height:1.2}.filter-info .info-content .info-subtitle{margin:0;font-size:var(--tertiary-font-size);color:var(--secondary-font-color);line-height:1.3}.filter-info .filter-count-badge{background:var(--primary-color);color:var(--surface-color);font-size:12px;font-weight:600;padding:6px 12px;border-radius:16px;border:none}.filter-controls{display:flex;flex:1;min-height:400px;overflow:hidden;border:var(--primary-border);border-radius:var(--input-radius);background:var(--surface-color)}.filter-sidebar{width:280px;background:var(--page-background-color);border-right:var(--primary-border);border-radius:var(--input-radius) 0 0 0;padding:20px 0;overflow-y:auto;max-height:100%}.filter-sidebar .sidebar-section .section-header{padding:0 24px 12px;font-size:var(--tertiary-font-size);font-weight:var(--primary-font-weight);color:var(--secondary-font-color);text-transform:uppercase;letter-spacing:.5px}.filter-sidebar .sidebar-section .filter-category{margin:0;list-style:none;padding:0}.filter-sidebar .sidebar-section .filter-category .category-item{margin:0}.filter-sidebar .sidebar-section .filter-category .category-item .category-button{width:100%;background:none;border:none;padding:12px 24px;text-align:left;cursor:pointer;display:flex;align-items:center;justify-content:space-between;font-size:14px;color:var(--primary-font-color);transition:all .2s ease;position:relative}.filter-sidebar .sidebar-section .filter-category .category-item .category-button:hover{background:var(--secondary-background-color)}.filter-sidebar .sidebar-section .filter-category .category-item .category-button.active{background:var(--diet-quinary-color);color:var(--primary-color);font-weight:var(--primary-font-weight)}.filter-sidebar .sidebar-section .filter-category .category-item .category-button.active:before{content:"";position:absolute;left:0;top:0;bottom:0;width:3px;background:var(--primary-color)}.filter-sidebar .sidebar-section .filter-category .category-item .category-button .category-icon{margin-right:12px;font-size:16px}.filter-sidebar .sidebar-section .filter-category .category-item .category-button .category-label{flex:1}.filter-sidebar .sidebar-section .filter-category .category-item .category-button .category-arrow{font-size:12px;color:var(--tertiary-color)}.filter-sidebar .sidebar-section .filter-category .category-item .applied-filters{padding:0 24px 0 52px;margin-top:8px}.filter-sidebar .sidebar-section .filter-category .category-item .applied-filters .applied-tag{display:inline-flex;align-items:center;background:var(--status-info-bg);color:var(--status-info-color);font-size:12px;padding:4px 8px;border-radius:6px;margin:2px 4px 2px 0;border:var(--status-info-border);cursor:pointer;transition:all .2s ease}.filter-sidebar .sidebar-section .filter-category .category-item .applied-filters .applied-tag:hover{background:var(--status-info-color);color:var(--surface-color)}.filter-sidebar .sidebar-section .filter-category .category-item .applied-filters .applied-tag .tag-remove{margin-left:6px;font-weight:700;color:var(--status-info-color)}.filter-sidebar .sidebar-section .filter-category .category-item .applied-filters .applied-tag .tag-remove:hover{color:var(--surface-color)}.filter-content{flex:1;padding:20px 24px;overflow-y:auto;background:var(--surface-color);border-radius:0 8px 0 0;max-height:100%}.filter-content .active-filters-summary{background:var(--page-background-color);border:var(--primary-border);border-radius:8px;padding:20px;margin-bottom:24px}.filter-content .active-filters-summary .summary-header{display:flex;align-items:center;justify-content:space-between;margin-bottom:16px}.filter-content .active-filters-summary .summary-header h3{margin:0;font-size:16px;font-weight:600;color:var(--primary-font-color)}.filter-content .active-filters-summary .summary-header .clear-all-btn{background:none;border:var(--primary-border);color:var(--secondary-font-color);font-size:12px;padding:6px 12px;border-radius:6px;cursor:pointer;transition:all .2s ease}.filter-content .active-filters-summary .summary-header .clear-all-btn:hover{background:var(--secondary-background-color);border-color:var(--tertiary-color)}.filter-content .active-filters-summary .active-filters-list .active-filter-item{margin-bottom:12px}.filter-content .active-filters-summary .active-filters-list .active-filter-item .filter-field-name{font-size:13px;font-weight:600;color:#475569;margin-bottom:6px}.filter-content .active-filters-summary .active-filters-list .active-filter-item .filter-values{display:flex;flex-wrap:wrap;gap:6px}.filter-content .active-filters-summary .active-filters-list .active-filter-item .filter-values .filter-value-tag{background:var(--primary-color);color:var(--surface-color);font-size:12px;padding:4px 10px;border-radius:16px;border:none;cursor:pointer;transition:all .2s ease;display:inline-flex;align-items:center;gap:6px}.filter-content .active-filters-summary .active-filters-list .active-filter-item .filter-values .filter-value-tag:hover{background:#0e9a9a}.filter-content .active-filters-summary .active-filters-list .active-filter-item .filter-values .filter-value-tag .value-remove{font-weight:700;opacity:.8}.filter-content .active-filters-summary .active-filters-list .active-filter-item .filter-values .filter-value-tag .value-remove:hover{opacity:1}.filter-content .field-configuration .content-header{margin-bottom:24px}.filter-content .field-configuration .content-header h3{margin:0 0 8px;font-size:20px;font-weight:600;color:var(--primary-font-color)}.filter-content .field-configuration .content-header .content-subtitle{margin:0;font-size:14px;color:var(--secondary-font-color);line-height:1.5}.filter-content .field-configuration .filter-section .section-title{font-size:16px;font-weight:600;color:var(--primary-font-color);margin:0 0 16px}.filter-content .field-configuration .filter-section .options-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:12px}.filter-content .field-configuration .filter-section .options-grid .option-checkbox{display:flex;align-items:center;padding:12px 16px;border:var(--primary-border);border-radius:8px;cursor:pointer;transition:all .2s ease;background:var(--surface-color)}.filter-content .field-configuration .filter-section .options-grid .option-checkbox:hover{border-color:#d1d5db;background:#f9fafb}.filter-content .field-configuration .filter-section .options-grid .option-checkbox.selected{border-color:var(--primary-color);background:#f0fdfa}.filter-content .field-configuration .filter-section .options-grid .option-checkbox .checkbox-input{display:none}.filter-content .field-configuration .filter-section .options-grid .option-checkbox .checkbox-custom{width:20px;height:20px;border:2px solid #d1d5db;border-radius:4px;margin-right:12px;position:relative;flex-shrink:0;transition:all .2s ease}.filter-content .field-configuration .filter-section .options-grid .option-checkbox .checkbox-custom:after{content:"\\2713";position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:var(--surface-color);font-size:12px;font-weight:700;opacity:0;transition:opacity .2s ease}.filter-content .field-configuration .filter-section .options-grid .option-checkbox.selected .checkbox-custom{background:var(--primary-color);border-color:var(--primary-color)}.filter-content .field-configuration .filter-section .options-grid .option-checkbox.selected .checkbox-custom:after{opacity:1}.filter-content .field-configuration .filter-section .options-grid .option-checkbox .option-label{font-size:14px;color:var(--primary-font-color);font-weight:500}.filter-content .field-configuration .filter-section .boolean-options{display:flex;gap:16px}.filter-content .field-configuration .filter-section .boolean-options .boolean-option{display:flex;align-items:center;padding:16px 20px;border:var(--primary-border);border-radius:8px;cursor:pointer;transition:all .2s ease;background:var(--surface-color);min-width:120px}.filter-content .field-configuration .filter-section .boolean-options .boolean-option:hover{border-color:#d1d5db;background:#f9fafb}.filter-content .field-configuration .filter-section .boolean-options .boolean-option.selected{border-color:var(--primary-color);background:#f0fdfa}.filter-content .field-configuration .filter-section .boolean-options .boolean-option .radio-input{display:none}.filter-content .field-configuration .filter-section .boolean-options .boolean-option .radio-custom{width:20px;height:20px;border:2px solid #d1d5db;border-radius:50%;margin-right:12px;position:relative;flex-shrink:0;transition:all .2s ease}.filter-content .field-configuration .filter-section .boolean-options .boolean-option .radio-custom:after{content:"";position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:8px;height:8px;background:var(--primary-color);border-radius:50%;opacity:0;transition:opacity .2s ease}.filter-content .field-configuration .filter-section .boolean-options .boolean-option.selected .radio-custom{border-color:var(--primary-color)}.filter-content .field-configuration .filter-section .boolean-options .boolean-option.selected .radio-custom:after{opacity:1}.filter-content .field-configuration .filter-section .boolean-options .boolean-option .option-label{font-size:14px;color:var(--primary-font-color);font-weight:500}.filter-content .field-configuration .filter-section .range-inputs{display:flex;align-items:flex-end;gap:16px}.filter-content .field-configuration .filter-section .range-inputs .range-field-group{flex:1}.filter-content .field-configuration .filter-section .range-inputs .range-field-group .range-label{display:block;font-size:13px;font-weight:500;color:#374151;margin-bottom:8px}.filter-content .field-configuration .filter-section .range-inputs .range-field-group .range-input{width:100%;padding:12px 16px;border:var(--primary-border);border-radius:8px;font-size:14px;background:var(--surface-color);transition:border-color .2s ease}.filter-content .field-configuration .filter-section .range-inputs .range-field-group .range-input:focus{outline:none;border-color:var(--primary-color);box-shadow:0 0 0 3px #10b3b31a}.filter-content .field-configuration .filter-section .range-inputs .range-separator{padding:12px 8px 0;font-size:14px;color:var(--secondary-font-color);font-weight:500}.filter-content .field-configuration .filter-section .text-input-group .text-label{display:block;font-size:13px;font-weight:500;color:#374151;margin-bottom:8px}.filter-content .field-configuration .filter-section .text-input-group .text-input{width:100%;padding:12px 16px;border:var(--primary-border);border-radius:8px;font-size:14px;background:var(--surface-color);transition:border-color .2s ease}.filter-content .field-configuration .filter-section .text-input-group .text-input:focus{outline:none;border-color:var(--primary-color);box-shadow:0 0 0 3px #10b3b31a}.filter-content .field-configuration .filter-section .text-input-group .input-hint{display:block;font-size:12px;color:var(--secondary-font-color);margin-top:6px}.filter-content .no-field-selected{display:flex;align-items:center;justify-content:center;height:100%;min-height:300px}.filter-content .no-field-selected .empty-state{text-align:center;max-width:400px}.filter-content .no-field-selected .empty-state .empty-icon{font-size:48px;margin-bottom:16px}.filter-content .no-field-selected .empty-state h3{margin:0 0 12px;font-size:20px;font-weight:600;color:var(--primary-font-color)}.filter-content .no-field-selected .empty-state p{margin:0;font-size:14px;color:var(--secondary-font-color);line-height:1.5}.filter-footer{background:var(--surface-color);border-top:var(--primary-border);border-radius:0 0 8px 8px;padding:16px 20px;display:flex;align-items:center;justify-content:space-between;flex-shrink:0;min-height:70px}.filter-footer .footer-left{display:flex;align-items:center;gap:16px}.filter-footer .footer-left .results-preview{display:flex;align-items:center;gap:8px}.filter-footer .footer-left .results-preview .results-label{font-size:14px;color:var(--secondary-font-color)}.filter-footer .footer-left .results-preview .results-count{font-size:16px;font-weight:600;color:var(--primary-color);background:var(--status-success-bg);padding:4px 12px;border-radius:6px;border:var(--status-success-border)}.filter-footer .footer-left .filter-summary{font-size:14px;color:#6b7280;background:var(--secondary-background-color);padding:8px 12px;border-radius:6px}.filter-footer .footer-actions{display:flex;align-items:center;gap:12px}.filter-footer .footer-actions .footer-btn{padding:12px 24px;border-radius:8px;font-size:14px;font-weight:600;cursor:pointer;transition:all .2s ease;display:flex;align-items:center;gap:8px;border:none}.filter-footer .footer-actions .footer-btn.cancel-btn{background:var(--surface-color);color:var(--secondary-font-color);border:var(--primary-border)}.filter-footer .footer-actions .footer-btn.cancel-btn:hover{background:#f9fafb;border-color:#d1d5db}.filter-footer .footer-actions .footer-btn.apply-btn{background:var(--primary-color);color:var(--surface-color);border:2px solid var(--primary-color);box-shadow:0 4px 12px #10b3b34d}.filter-footer .footer-actions .footer-btn.apply-btn:hover:not(:disabled){background:#0e9a9a;border-color:#0e9a9a;transform:translateY(-1px);box-shadow:0 6px 16px #10b3b366}.filter-footer .footer-actions .footer-btn.apply-btn:disabled{background:#9ca3af;border-color:#9ca3af;cursor:not-allowed;transform:none;box-shadow:none}.filter-footer .footer-actions .footer-btn.apply-btn .apply-count{background:#fff3;padding:2px 6px;border-radius:10px;font-size:12px;margin-left:4px}.filter-footer .footer-actions .footer-btn .btn-icon{font-size:16px}@media (max-width: 768px){.filter-container{min-width:95vw;max-width:95vw;max-height:90vh}.filter-controls{flex-direction:column}.filter-sidebar{width:100%;max-height:200px;order:2}.filter-content{order:1;padding:16px 20px}.filter-footer{padding:16px 20px;flex-direction:column;gap:12px}.filter-footer .footer-left,.filter-footer .footer-actions{width:100%;justify-content:center}}@keyframes slideInUp{0%{opacity:0;transform:translateY(20px)}to{opacity:1;transform:translateY(0)}}\n']
    }]
  }], () => [], null);
})();
var GridMenuRendererComponent = class _GridMenuRendererComponent {
  constructor() {
    this.menuActions = [];
  }
  agInit(params) {
    this.params = params;
    if (params.context?.gridOptions?.menuActions) {
      this.menuActions = params.context.gridOptions.menuActions || [];
    }
  }
  onActionClick(action, rowData) {
    if (action.click && typeof action.click === "function") {
      action.click({
        data: rowData,
        action
      });
    }
  }
  static {
    this.ɵfac = function GridMenuRendererComponent_Factory(t) {
      return new (t || _GridMenuRendererComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _GridMenuRendererComponent,
      selectors: [["app-grid-menu-renderer"]],
      standalone: true,
      features: [ɵɵStandaloneFeature],
      decls: 5,
      vars: 3,
      consts: [["menu", "matMenu"], ["mat-icon-button", "", "aria-label", "Row actions", 1, "menu-trigger", 3, "click", "matMenuTriggerFor"], ["fontSet", "material-icons-outlined", "fontIcon", "more_vert", 3, "size"], ["mat-menu-item", "", 3, "click", 4, "ngFor", "ngForOf"], ["mat-menu-item", "", 3, "click"], ["fontSet", "material-icons-outlined", 3, "fontIcon"]],
      template: function GridMenuRendererComponent_Template(rf, ctx) {
        if (rf & 1) {
          const _r1 = ɵɵgetCurrentView();
          ɵɵelementStart(0, "button", 1);
          ɵɵlistener("click", function GridMenuRendererComponent_Template_button_click_0_listener($event) {
            ɵɵrestoreView(_r1);
            return ɵɵresetView($event.stopPropagation());
          });
          ɵɵelement(1, "app-icon", 2);
          ɵɵelementEnd();
          ɵɵelementStart(2, "mat-menu", null, 0);
          ɵɵtemplate(4, GridMenuRendererComponent_button_4_Template, 4, 2, "button", 3);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          const menu_r5 = ɵɵreference(3);
          ɵɵproperty("matMenuTriggerFor", menu_r5);
          ɵɵadvance();
          ɵɵproperty("size", 18);
          ɵɵadvance(3);
          ɵɵproperty("ngForOf", ctx.menuActions);
        }
      },
      dependencies: [CommonModule, NgForOf, MatMenuModule, MatMenu, MatMenuItem, MatMenuTrigger, MatIconModule, MatButtonModule, MatIconButton, IconComponent],
      styles: ["[_nghost-%COMP%]{display:flex;width:100%;height:100%;align-items:center;justify-content:center}.menu-trigger[_ngcontent-%COMP%]{opacity:.7;transition:opacity .2s ease;width:28px!important;height:28px!important;border-radius:50%!important;padding:0!important;display:flex;align-items:center;justify-content:center}.ag-row-hover[_nghost-%COMP%]   .menu-trigger[_ngcontent-%COMP%], .ag-row-hover   [_nghost-%COMP%]   .menu-trigger[_ngcontent-%COMP%], .ag-row-selected[_nghost-%COMP%]   .menu-trigger[_ngcontent-%COMP%], .ag-row-selected   [_nghost-%COMP%]   .menu-trigger[_ngcontent-%COMP%], [_nghost-%COMP%]:hover   .menu-trigger[_ngcontent-%COMP%], .menu-trigger[_ngcontent-%COMP%]:hover, .menu-trigger[_ngcontent-%COMP%]:focus{opacity:1}.actions-cell[_nghost-%COMP%], .actions-cell   [_nghost-%COMP%]{padding:0!important}.actions-header-cell[_nghost-%COMP%], .actions-header-cell   [_nghost-%COMP%]{padding:0!important}"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridMenuRendererComponent, [{
    type: Component,
    args: [{
      selector: "app-grid-menu-renderer",
      standalone: true,
      imports: [CommonModule, MatMenuModule, MatIconModule, MatButtonModule, IconComponent],
      template: '<button class="menu-trigger" mat-icon-button [matMenuTriggerFor]="menu" (click)="$event.stopPropagation()" aria-label="Row actions">\n  <app-icon \n    fontSet="material-icons-outlined" \n    fontIcon="more_vert" \n    [size]="18">\n  </app-icon>\n</button>\n  <mat-menu #menu="matMenu">\n    <button \n      mat-menu-item \n      *ngFor="let action of menuActions" \n      (click)="onActionClick(action, params.data)">\n        <app-icon \n            fontSet="material-icons-outlined" \n            [fontIcon]="action.icon" \n            >\n        </app-icon>\n      <span>{{ action.title }}</span>\n    </button>\n  </mat-menu>',
      styles: [":host{display:flex;width:100%;height:100%;align-items:center;justify-content:center}.menu-trigger{opacity:.7;transition:opacity .2s ease;width:28px!important;height:28px!important;border-radius:50%!important;padding:0!important;display:flex;align-items:center;justify-content:center}:host-context(.ag-row-hover) .menu-trigger,:host-context(.ag-row-selected) .menu-trigger,:host:hover .menu-trigger,.menu-trigger:hover,.menu-trigger:focus{opacity:1}:host-context(.actions-cell){padding:0!important}:host-context(.actions-header-cell){padding:0!important}\n"]
    }]
  }], null, null);
})();
var ConfirmationDialogWrapperComponent = class _ConfirmationDialogWrapperComponent {
  constructor() {
    this.dialogRef = inject(MatDialogRef);
    this.data = inject(MAT_DIALOG_DATA);
  }
  onFooterActionClick(actionId, event) {
    if (event) {
      event.preventDefault();
      event.stopPropagation();
    }
    const result = {
      action: actionId,
      actionId
    };
    if (actionId === "confirm") {
      result.confirmed = true;
    } else if (actionId === "cancel") {
      result.confirmed = false;
    }
    this.dialogRef.close(result);
  }
  get displayTitle() {
    return this.data?.title || "Confirm";
  }
  get displayMessage() {
    return this.data?.message || "Are you sure?";
  }
  get footerActions() {
    const actions = [];
    if (this.data?.showCancel !== false) {
      actions.push({
        id: "cancel",
        text: this.data?.cancelText || "Cancel",
        color: "primary",
        appearance: "flat"
      });
    }
    if (this.data?.showConfirm !== false) {
      actions.push({
        id: "confirm",
        text: this.data?.confirmText || "Yes",
        color: "primary",
        appearance: "flat"
      });
    }
    return actions;
  }
  static {
    this.ɵfac = function ConfirmationDialogWrapperComponent_Factory(t) {
      return new (t || _ConfirmationDialogWrapperComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _ConfirmationDialogWrapperComponent,
      selectors: [["app-confirmation-dialog-wrapper"]],
      standalone: true,
      features: [ɵɵStandaloneFeature],
      decls: 11,
      vars: 3,
      consts: [[1, "confirmation-dialog-wrapper"], [1, "confirmation-header"], [1, "confirmation-title"], [1, "confirmation-content"], [1, "message-container"], [1, "confirmation-message"], [1, "confirmation-footer"], [1, "footer-actions"], [3, "text", "color", "appearance", "type", "class", "btnClick", 4, "ngFor", "ngForOf"], [3, "btnClick", "text", "color", "appearance", "type"]],
      template: function ConfirmationDialogWrapperComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "div", 0)(1, "div", 1)(2, "div", 2);
          ɵɵtext(3);
          ɵɵelementEnd()();
          ɵɵelementStart(4, "div", 3)(5, "div", 4)(6, "p", 5);
          ɵɵtext(7);
          ɵɵelementEnd()()();
          ɵɵelementStart(8, "div", 6)(9, "div", 7);
          ɵɵtemplate(10, ConfirmationDialogWrapperComponent_app_button_10_Template, 1, 6, "app-button", 8);
          ɵɵelementEnd()()();
        }
        if (rf & 2) {
          ɵɵadvance(3);
          ɵɵtextInterpolate(ctx.displayTitle);
          ɵɵadvance(4);
          ɵɵtextInterpolate(ctx.displayMessage);
          ɵɵadvance(3);
          ɵɵproperty("ngForOf", ctx.footerActions);
        }
      },
      dependencies: [CommonModule, NgForOf, AppButtonComponent],
      styles: [".confirmation-dialog-wrapper[_ngcontent-%COMP%]{display:flex;flex-direction:column;min-width:400px;max-width:500px;background:#fff;border-radius:16px;overflow:hidden}.confirmation-dialog-wrapper[_ngcontent-%COMP%]   .confirmation-header[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center;padding:20px 24px 12px;border-bottom:1px solid #f0f0f0;background:#fff;border-top-left-radius:16px;border-top-right-radius:16px}.confirmation-dialog-wrapper[_ngcontent-%COMP%]   .confirmation-header[_ngcontent-%COMP%]   .confirmation-title[_ngcontent-%COMP%]{color:#1f2937;font-size:1.15rem;font-weight:600;text-align:center}.confirmation-dialog-wrapper[_ngcontent-%COMP%]   .confirmation-content[_ngcontent-%COMP%]{padding:20px 24px;background:#fff;flex:1}.confirmation-dialog-wrapper[_ngcontent-%COMP%]   .confirmation-content[_ngcontent-%COMP%]   .message-container[_ngcontent-%COMP%]{width:100%}.confirmation-dialog-wrapper[_ngcontent-%COMP%]   .confirmation-content[_ngcontent-%COMP%]   .message-container[_ngcontent-%COMP%]   .confirmation-message[_ngcontent-%COMP%]{margin:0;font-size:16px;line-height:1.6;color:#1f2937;word-wrap:break-word;text-align:left}.confirmation-dialog-wrapper[_ngcontent-%COMP%]   .confirmation-footer[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:flex-end;padding:16px 24px;background:#fff;border-top:1px solid #f0f0f0;border-bottom-left-radius:16px;border-bottom-right-radius:16px;gap:0}.confirmation-dialog-wrapper[_ngcontent-%COMP%]   .confirmation-footer[_ngcontent-%COMP%]   .footer-actions[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:flex-end;gap:0;width:100%}.confirmation-dialog-wrapper[_ngcontent-%COMP%]   .confirmation-footer[_ngcontent-%COMP%]   .footer-actions[_ngcontent-%COMP%]   app-button[_ngcontent-%COMP%]{position:relative;margin:0;cursor:pointer}.confirmation-dialog-wrapper[_ngcontent-%COMP%]   .confirmation-footer[_ngcontent-%COMP%]   .footer-actions[_ngcontent-%COMP%]   app-button[_ngcontent-%COMP%]:not(:last-child){margin-right:0;padding-right:12px}.confirmation-dialog-wrapper[_ngcontent-%COMP%]   .confirmation-footer[_ngcontent-%COMP%]   .footer-actions[_ngcontent-%COMP%]   app-button[_ngcontent-%COMP%]:not(:first-child){padding-left:12px;border-left:1px solid #e5e7eb}.confirmation-dialog-wrapper[_ngcontent-%COMP%]   .confirmation-footer[_ngcontent-%COMP%]   .footer-actions[_ngcontent-%COMP%]   app-button[_ngcontent-%COMP%]     button{cursor:pointer;pointer-events:auto}  .confirmation-dialog-panel .mat-dialog-container{border-radius:16px;padding:0;box-shadow:0 8px 32px #0000002e;background:#fff;position:relative;margin:auto}  .cdk-overlay-pane.confirmation-dialog-panel{display:flex!important;align-items:center!important;justify-content:center!important}"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ConfirmationDialogWrapperComponent, [{
    type: Component,
    args: [{
      selector: "app-confirmation-dialog-wrapper",
      standalone: true,
      imports: [CommonModule, AppButtonComponent],
      template: `<div class="confirmation-dialog-wrapper">
  <div class="confirmation-header">
    <div class="confirmation-title">{{ displayTitle }}</div>
  </div>
  
  <div class="confirmation-content">
    <div class="message-container">
      <p class="confirmation-message">{{ displayMessage }}</p>
    </div>
  </div>
  
  <div class="confirmation-footer">
    <div class="footer-actions">
      <app-button
        *ngFor="let action of footerActions"
        [text]="action.text"
        [color]="action.color || 'primary'"
        [appearance]="action.appearance || 'flat'"
        [type]="'button'"
        [class]="action.class || ''"
        (btnClick)="onFooterActionClick(action.id, $event)">
      </app-button>
    </div>
  </div>
</div>

`,
      styles: [".confirmation-dialog-wrapper{display:flex;flex-direction:column;min-width:400px;max-width:500px;background:#fff;border-radius:16px;overflow:hidden}.confirmation-dialog-wrapper .confirmation-header{display:flex;align-items:center;justify-content:center;padding:20px 24px 12px;border-bottom:1px solid #f0f0f0;background:#fff;border-top-left-radius:16px;border-top-right-radius:16px}.confirmation-dialog-wrapper .confirmation-header .confirmation-title{color:#1f2937;font-size:1.15rem;font-weight:600;text-align:center}.confirmation-dialog-wrapper .confirmation-content{padding:20px 24px;background:#fff;flex:1}.confirmation-dialog-wrapper .confirmation-content .message-container{width:100%}.confirmation-dialog-wrapper .confirmation-content .message-container .confirmation-message{margin:0;font-size:16px;line-height:1.6;color:#1f2937;word-wrap:break-word;text-align:left}.confirmation-dialog-wrapper .confirmation-footer{display:flex;align-items:center;justify-content:flex-end;padding:16px 24px;background:#fff;border-top:1px solid #f0f0f0;border-bottom-left-radius:16px;border-bottom-right-radius:16px;gap:0}.confirmation-dialog-wrapper .confirmation-footer .footer-actions{display:flex;align-items:center;justify-content:flex-end;gap:0;width:100%}.confirmation-dialog-wrapper .confirmation-footer .footer-actions app-button{position:relative;margin:0;cursor:pointer}.confirmation-dialog-wrapper .confirmation-footer .footer-actions app-button:not(:last-child){margin-right:0;padding-right:12px}.confirmation-dialog-wrapper .confirmation-footer .footer-actions app-button:not(:first-child){padding-left:12px;border-left:1px solid #e5e7eb}.confirmation-dialog-wrapper .confirmation-footer .footer-actions app-button ::ng-deep button{cursor:pointer;pointer-events:auto}::ng-deep .confirmation-dialog-panel .mat-dialog-container{border-radius:16px;padding:0;box-shadow:0 8px 32px #0000002e;background:#fff;position:relative;margin:auto}::ng-deep .cdk-overlay-pane.confirmation-dialog-panel{display:flex!important;align-items:center!important;justify-content:center!important}\n"]
    }]
  }], null, null);
})();
var DialogboxService = class _DialogboxService {
  constructor() {
    this.dialog = inject(MatDialog);
  }
  openDialog(component, config = {}) {
    const dialogRef = this.dialog.open(DialogboxContentComponent, {
      data: {
        title: config.title,
        component,
        componentData: config.data,
        hideHeader: config.hideHeader,
        footerActions: config.footerActions
      },
      panelClass: "custom-dialog-panel",
      width: config.width || "80%",
      height: config.height || "60%",
      minWidth: config.minWidth,
      minHeight: config.minHeight,
      maxWidth: config.maxWidth,
      maxHeight: config.maxHeight,
      autoFocus: false,
      hasBackdrop: true,
      disableClose: false
    });
    return dialogRef;
  }
  openConfirmationDialog(config) {
    const dialogRef = this.dialog.open(ConfirmationDialogWrapperComponent, {
      data: {
        message: config.message,
        title: config.title || "Confirm",
        cancelText: config.cancelText,
        confirmText: config.confirmText,
        icon: config.icon || "info",
        showCancel: config.showCancel !== false,
        showConfirm: config.showConfirm !== false
      },
      panelClass: "confirmation-dialog-panel",
      width: config.width || "450px",
      minWidth: config.minWidth || "400px",
      maxWidth: config.maxWidth || "600px",
      autoFocus: false,
      hasBackdrop: true,
      disableClose: false
    });
    return dialogRef;
  }
  static {
    this.ɵfac = function DialogboxService_Factory(t) {
      return new (t || _DialogboxService)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _DialogboxService,
      factory: _DialogboxService.ɵfac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DialogboxService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var DialogboxComponent = class _DialogboxComponent {
  constructor() {
    this.title = "";
    this.closed = new EventEmitter();
    this.dialog = inject(MatDialog);
  }
  openDialog() {
    const dialogRef = this.dialog.open(DialogboxContentComponent, {
      data: {
        title: this.title,
        content: this.data
      },
      panelClass: "custom-dialog-panel",
      autoFocus: false
    });
    dialogRef.afterClosed().subscribe((result) => {
      this.closed.emit(result);
    });
    return dialogRef;
  }
  static {
    this.ɵfac = function DialogboxComponent_Factory(t) {
      return new (t || _DialogboxComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _DialogboxComponent,
      selectors: [["app-dialogbox"]],
      inputs: {
        title: "title",
        data: "data"
      },
      outputs: {
        closed: "closed"
      },
      standalone: true,
      features: [ɵɵStandaloneFeature],
      decls: 0,
      vars: 0,
      template: function DialogboxComponent_Template(rf, ctx) {
      },
      dependencies: [CommonModule, MatDialogModule],
      styles: [".custom-dialog-panel .mat-dialog-container{border-radius:16px;padding:0;min-width:400px;max-width:90vw;box-shadow:0 8px 32px #0000002e;background:#fff;position:relative;margin:auto}  .cdk-overlay-pane.custom-dialog-panel{display:flex!important;align-items:center!important;justify-content:center!important}.dialogbox-header[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:space-between;padding:.8em .7em .7em;height:3em;border-bottom:1px solid #f0f0f0;font-size:1.2rem;font-weight:600;background:#fff;border-top-left-radius:16px;border-top-right-radius:16px}.dialogbox-header.confirmation-header[_ngcontent-%COMP%]{justify-content:center;padding:20px 24px}.dialogbox-title[_ngcontent-%COMP%]{flex:1;color:#222;font-size:1.15rem;font-weight:600}.dialogbox-title.centered-title[_ngcontent-%COMP%]{flex:none;text-align:center;color:#1f2937}.close-icon[_ngcontent-%COMP%]{cursor:pointer;color:#888;transition:color .2s;margin-left:16px}.close-icon[_ngcontent-%COMP%]:hover{color:#18b6b2}.dialogbox-content[_ngcontent-%COMP%]{padding:1em;height:calc(100% - 6.5em);background:var(--surface-color);border-bottom-left-radius:16px;border-bottom-right-radius:16px;max-height:75vh;overflow:scroll}.dialogbox-content.no-header[_ngcontent-%COMP%]{padding-top:16px;padding-bottom:16px;border-top-left-radius:16px;border-top-right-radius:16px}.dialogbox-content.has-footer[_ngcontent-%COMP%]{border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom:1px solid #f0f0f0}.dialogbox-content[_ngcontent-%COMP%]   app-filter[_ngcontent-%COMP%]{display:block;width:100%;height:600px;max-height:70vh}.dialogbox-content[_ngcontent-%COMP%]   app-filter[_ngcontent-%COMP%]   .filter-container[_ngcontent-%COMP%]{height:100%;max-height:100%}.dialogbox-footer[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:flex-end;padding:1em 1.2em;height:3.5em;background:#fff;border-bottom-left-radius:16px;border-bottom-right-radius:16px;border-top:1px solid #f0f0f0;gap:0}.dialogbox-footer[_ngcontent-%COMP%]:has( + .dialogbox-content.no-header)[_ngcontent-%COMP%], .no-header[_ngcontent-%COMP%] ~ .dialogbox-footer[_ngcontent-%COMP%]{padding-top:12px;padding-bottom:12px}.dialogbox-footer[_ngcontent-%COMP%]   .footer-actions[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:flex-end;gap:0;width:100%}.dialogbox-footer[_ngcontent-%COMP%]   .footer-actions[_ngcontent-%COMP%]   app-button[_ngcontent-%COMP%]{position:relative;margin:0}.dialogbox-footer[_ngcontent-%COMP%]   .footer-actions[_ngcontent-%COMP%]   app-button[_ngcontent-%COMP%]:not(:last-child){margin-right:0;padding-right:12px}.dialogbox-footer[_ngcontent-%COMP%]   .footer-actions[_ngcontent-%COMP%]   app-button[_ngcontent-%COMP%]:not(:first-child){padding-left:12px;border-left:1px solid #e5e7eb}"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DialogboxComponent, [{
    type: Component,
    args: [{
      selector: "app-dialogbox",
      standalone: true,
      imports: [CommonModule, MatDialogModule],
      template: "",
      styles: ["::ng-deep .custom-dialog-panel .mat-dialog-container{border-radius:16px;padding:0;min-width:400px;max-width:90vw;box-shadow:0 8px 32px #0000002e;background:#fff;position:relative;margin:auto}::ng-deep .cdk-overlay-pane.custom-dialog-panel{display:flex!important;align-items:center!important;justify-content:center!important}.dialogbox-header{display:flex;align-items:center;justify-content:space-between;padding:.8em .7em .7em;height:3em;border-bottom:1px solid #f0f0f0;font-size:1.2rem;font-weight:600;background:#fff;border-top-left-radius:16px;border-top-right-radius:16px}.dialogbox-header.confirmation-header{justify-content:center;padding:20px 24px}.dialogbox-title{flex:1;color:#222;font-size:1.15rem;font-weight:600}.dialogbox-title.centered-title{flex:none;text-align:center;color:#1f2937}.close-icon{cursor:pointer;color:#888;transition:color .2s;margin-left:16px}.close-icon:hover{color:#18b6b2}.dialogbox-content{padding:1em;height:calc(100% - 6.5em);background:var(--surface-color);border-bottom-left-radius:16px;border-bottom-right-radius:16px;max-height:75vh;overflow:scroll}.dialogbox-content.no-header{padding-top:16px;padding-bottom:16px;border-top-left-radius:16px;border-top-right-radius:16px}.dialogbox-content.has-footer{border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom:1px solid #f0f0f0}.dialogbox-content app-filter{display:block;width:100%;height:600px;max-height:70vh}.dialogbox-content app-filter .filter-container{height:100%;max-height:100%}.dialogbox-footer{display:flex;align-items:center;justify-content:flex-end;padding:1em 1.2em;height:3.5em;background:#fff;border-bottom-left-radius:16px;border-bottom-right-radius:16px;border-top:1px solid #f0f0f0;gap:0}.dialogbox-footer:has(+.dialogbox-content.no-header),.no-header~.dialogbox-footer{padding-top:12px;padding-bottom:12px}.dialogbox-footer .footer-actions{display:flex;align-items:center;justify-content:flex-end;gap:0;width:100%}.dialogbox-footer .footer-actions app-button{position:relative;margin:0}.dialogbox-footer .footer-actions app-button:not(:last-child){margin-right:0;padding-right:12px}.dialogbox-footer .footer-actions app-button:not(:first-child){padding-left:12px;border-left:1px solid #e5e7eb}\n"]
    }]
  }], null, {
    title: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    closed: [{
      type: Output
    }]
  });
})();
var DialogboxContentComponent = class _DialogboxContentComponent {
  constructor() {
    this.dialogRef = inject(MatDialogRef);
    this.data = inject(MAT_DIALOG_DATA);
    this.injector = inject(Injector);
    this.changeDetectorRef = inject(ChangeDetectorRef);
    this.originalFooterActions = [];
    this.componentInjector = Injector.create({
      providers: [{
        provide: DIALOG_DATA_TOKEN,
        useValue: this.data.componentData
      }],
      parent: this.injector
    });
    if (this.data?.footerActions) {
      this.originalFooterActions = [...this.data.footerActions];
    }
  }
  close() {
    this.dialogRef.close();
  }
  isConfirmationDialog() {
    return this.data?.componentData?.isConfirmationDialog === true;
  }
  onFooterActionClick(actionId, event) {
    const result = {
      action: actionId,
      actionId,
      event
    };
    if (actionId === "confirm") {
      result.confirmed = true;
    } else if (actionId === "cancel") {
      result.confirmed = false;
    }
    this.dialogRef.close(result);
  }
  /**
   * Update footer actions dynamically
   * @param actions - New array of footer actions, or a function to filter/update existing actions
   */
  updateFooterActions(actions) {
    if (!this.data) return;
    if (typeof actions === "function") {
      const allActions = this.originalFooterActions.length > 0 ? this.originalFooterActions : this.data.footerActions || [];
      if (this.originalFooterActions.length === 0 && allActions.length > 0) {
        this.originalFooterActions = [...allActions];
      }
      const updatedActions = actions(allActions);
      this.data.footerActions = updatedActions.map((action) => __spreadValues({}, action));
    } else if (actions) {
      this.data.footerActions = actions.map((action) => __spreadValues({}, action));
    }
    this.changeDetectorRef.markForCheck();
    this.changeDetectorRef.detectChanges();
  }
  /**
   * Update disabled state of a specific footer action
   * @param actionId - ID of the action to update
   * @param disabled - New disabled state
   */
  setFooterActionDisabled(actionId, disabled) {
    if (!this.data?.footerActions) return;
    const action = this.data.footerActions.find((a) => a.id === actionId);
    if (action) {
      action.disabled = disabled;
      this.changeDetectorRef.detectChanges();
    }
  }
  /**
   * Get current footer actions
   */
  getFooterActions() {
    return this.data?.footerActions || [];
  }
  /**
   * Get original footer actions
   */
  getOriginalFooterActions() {
    return this.originalFooterActions.length > 0 ? this.originalFooterActions : this.data?.footerActions || [];
  }
  /**
   * Track by function for ngFor to improve change detection
   */
  trackByActionId(index, action) {
    return action.id;
  }
  static {
    this.ɵfac = function DialogboxContentComponent_Factory(t) {
      return new (t || _DialogboxContentComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _DialogboxContentComponent,
      selectors: [["app-dialogbox-content"]],
      standalone: true,
      features: [ɵɵStandaloneFeature],
      ngContentSelectors: _c113,
      decls: 5,
      vars: 8,
      consts: [["projected", ""], ["class", "dialogbox-header", 3, "confirmation-header", 4, "ngIf"], [1, "dialogbox-content"], [4, "ngIf"], ["class", "dialogbox-footer", 4, "ngIf"], [1, "dialogbox-header"], [1, "dialogbox-title"], ["fontIcon", "close", "class", "close-icon", 3, "size", "iconClick", 4, "ngIf"], ["fontIcon", "close", 1, "close-icon", 3, "iconClick", "size"], [4, "ngComponentOutlet", "ngComponentOutletInjector"], [4, "ngIf", "ngIfElse"], [1, "dialogbox-footer"], [1, "footer-actions"], [3, "text", "color", "appearance", "disabled", "fontIcon", "class", "btnClick", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "btnClick", "text", "color", "appearance", "disabled", "fontIcon"]],
      template: function DialogboxContentComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef();
          ɵɵtemplate(0, DialogboxContentComponent_div_0_Template, 4, 6, "div", 1);
          ɵɵelementStart(1, "div", 2);
          ɵɵtemplate(2, DialogboxContentComponent_ng_container_2_Template, 2, 2, "ng-container", 3)(3, DialogboxContentComponent_ng_container_3_Template, 4, 2, "ng-container", 3);
          ɵɵelementEnd();
          ɵɵtemplate(4, DialogboxContentComponent_div_4_Template, 3, 2, "div", 4);
        }
        if (rf & 2) {
          ɵɵproperty("ngIf", !(ctx.data == null ? null : ctx.data.hideHeader));
          ɵɵadvance();
          ɵɵclassProp("no-header", ctx.data == null ? null : ctx.data.hideHeader)("has-footer", ctx.data == null ? null : ctx.data.footerActions == null ? null : ctx.data.footerActions.length);
          ɵɵadvance();
          ɵɵproperty("ngIf", ctx.data == null ? null : ctx.data.component);
          ɵɵadvance();
          ɵɵproperty("ngIf", !(ctx.data == null ? null : ctx.data.component));
          ɵɵadvance();
          ɵɵproperty("ngIf", ctx.data == null ? null : ctx.data.footerActions == null ? null : ctx.data.footerActions.length);
        }
      },
      dependencies: [CommonModule, NgComponentOutlet, NgForOf, NgIf, MatDialogModule, IconComponent, AppButtonComponent],
      styles: [_c211]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DialogboxContentComponent, [{
    type: Component,
    args: [{
      selector: "app-dialogbox-content",
      standalone: true,
      imports: [CommonModule, MatDialogModule, IconComponent, AppButtonComponent],
      template: `<div class="dialogbox-header" *ngIf="!data?.hideHeader" [class.confirmation-header]="isConfirmationDialog()">
  <div class="dialogbox-title" [class.centered-title]="isConfirmationDialog()">{{ data?.title }}</div>
  <app-icon *ngIf="!isConfirmationDialog()" fontIcon="close" [size]="22" (iconClick)="close()" class="close-icon"></app-icon>
</div>
<div class="dialogbox-content" [class.no-header]="data?.hideHeader" [class.has-footer]="data?.footerActions?.length">
  <ng-container *ngIf="data?.component">
    <ng-container *ngComponentOutlet="data.component; injector: componentInjector"></ng-container>
  </ng-container>
  <ng-container *ngIf="!data?.component">
    <ng-container *ngIf="data?.content; else projected">
      {{ data.content }}
    </ng-container>
    <ng-template #projected>
      <ng-content></ng-content>
    </ng-template>
  </ng-container>
</div>
<div class="dialogbox-footer" *ngIf="data?.footerActions?.length">
  <div class="footer-actions">
    <app-button
      *ngFor="let action of data.footerActions; trackBy: trackByActionId"
      [text]="action.text"
      [color]="action.color || 'primary'"
      [appearance]="action.appearance || 'raised'"
      [disabled]="action.disabled || false"
      [fontIcon]="action.fontIcon || ''"
      [class]="action.class || ''"
      (btnClick)="onFooterActionClick(action.id, $event)"
    ></app-button>
  </div>
</div> `,
      styles: ["::ng-deep .custom-dialog-panel .mat-dialog-container{border-radius:16px;padding:0;min-width:400px;max-width:90vw;box-shadow:0 8px 32px #0000002e;background:#fff;position:relative;margin:auto}::ng-deep .cdk-overlay-pane.custom-dialog-panel{display:flex!important;align-items:center!important;justify-content:center!important}.dialogbox-header{display:flex;align-items:center;justify-content:space-between;padding:.8em .7em .7em;height:3em;border-bottom:1px solid #f0f0f0;font-size:1.2rem;font-weight:600;background:#fff;border-top-left-radius:16px;border-top-right-radius:16px}.dialogbox-header.confirmation-header{justify-content:center;padding:20px 24px}.dialogbox-title{flex:1;color:#222;font-size:1.15rem;font-weight:600}.dialogbox-title.centered-title{flex:none;text-align:center;color:#1f2937}.close-icon{cursor:pointer;color:#888;transition:color .2s;margin-left:16px}.close-icon:hover{color:#18b6b2}.dialogbox-content{padding:1em;height:calc(100% - 6.5em);background:var(--surface-color);border-bottom-left-radius:16px;border-bottom-right-radius:16px;max-height:75vh;overflow:scroll}.dialogbox-content.no-header{padding-top:16px;padding-bottom:16px;border-top-left-radius:16px;border-top-right-radius:16px}.dialogbox-content.has-footer{border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom:1px solid #f0f0f0}.dialogbox-content app-filter{display:block;width:100%;height:600px;max-height:70vh}.dialogbox-content app-filter .filter-container{height:100%;max-height:100%}.dialogbox-footer{display:flex;align-items:center;justify-content:flex-end;padding:1em 1.2em;height:3.5em;background:#fff;border-bottom-left-radius:16px;border-bottom-right-radius:16px;border-top:1px solid #f0f0f0;gap:0}.dialogbox-footer:has(+.dialogbox-content.no-header),.no-header~.dialogbox-footer{padding-top:12px;padding-bottom:12px}.dialogbox-footer .footer-actions{display:flex;align-items:center;justify-content:flex-end;gap:0;width:100%}.dialogbox-footer .footer-actions app-button{position:relative;margin:0}.dialogbox-footer .footer-actions app-button:not(:last-child){margin-right:0;padding-right:12px}.dialogbox-footer .footer-actions app-button:not(:first-child){padding-left:12px;border-left:1px solid #e5e7eb}\n"]
    }]
  }], () => [], null);
})();
ModuleRegistry.registerModules([AllCommunityModule]);
var GridComponent = class _GridComponent {
  constructor(dialogbox, platformId, apiConfigService, http) {
    this.dialogbox = dialogbox;
    this.platformId = platformId;
    this.apiConfigService = apiConfigService;
    this.http = http;
    this.rowData = [];
    this.columnDefs = [];
    this.gridOptions = {};
    this.domLayout = "autoHeight";
    this.animateRows = true;
    this.class = "ag-theme-alpine";
    this.height = "400px";
    this.width = "100%";
    this.showHeader = true;
    this.searchPlaceholder = "Search...";
    this.rightTooltemplateRef = null;
    this.cardTemplate = null;
    this.defaultViewMode = "list";
    this.showAddButton = false;
    this.apiConfig = null;
    this.searchChange = new EventEmitter();
    this.rowClicked = new EventEmitter();
    this.addClick = new EventEmitter();
    this.searchText = "";
    this.filteredRowData = [];
    this.processedColumnDefs = [];
    this.activeFiltersCount = 0;
    this.activeFilterChips = [];
    this.viewMode = "list";
    this.displayedRows = 0;
    this.totalRows = 0;
    this._activeFilters = [];
    this._activeLogic = "AND";
    this.isBrowser = isPlatformBrowser(this.platformId);
  }
  ngOnInit() {
    this.gridOptions.pagination = true;
    this.gridOptions.paginationPageSize = 25;
    this.gridOptions.paginationPageSizeSelector = [10, 25, 50, 100];
    this.gridOptions.rowHeight = 48;
    this.gridOptions.headerHeight = 40;
    this.gridOptions.suppressCellFocus = true;
    this.gridOptions.getRowHeight = (params) => {
      return params.node.rowHeight || 48;
    };
    this.gridOptions.context = {
      gridOptions: this.gridOptions
    };
    this.gridOptions.noRowsOverlayComponentParams = {
      noRowsMessageFunc: () => "No records to display"
    };
    if (this.gridOptions.rowSelection) {
      if (this.gridOptions.suppressRowClickSelection === void 0) {
        this.gridOptions.suppressRowClickSelection = false;
      }
      this.class = (this.class || "ag-theme-clean") + " has-row-selection";
    }
    if (!this.gridOptions.components) {
      this.gridOptions.components = {};
    }
    this.gridOptions.components["gridMenu"] = GridMenuRendererComponent;
    this.filteredRowData = [...this.rowData];
    this.viewMode = this.defaultViewMode;
    if (this.shouldFetchFromApi()) {
      this.fetchGridDataFromApi();
    } else {
      this.processColumnDefs();
      this.updatePaginationInfo();
    }
  }
  ngOnChanges(changes) {
    const rowDataChanged = "rowData" in changes;
    const apiConfigChanged = "apiConfig" in changes;
    if (rowDataChanged && this.rowData && this.rowData.length > 0) {
      this.filteredRowData = this.applySearchTo([...this.rowData]);
      this.processColumnDefs();
      this.updatePaginationInfo();
      return;
    }
    if (apiConfigChanged && this.shouldFetchFromApi()) {
      this.fetchGridDataFromApi();
    }
  }
  onGridReady(params) {
    this.gridApi = params.api;
    this.updatePaginationInfo();
  }
  onModelUpdated(event) {
    this.updatePaginationInfo();
  }
  updatePaginationInfo() {
    if (this.gridApi) {
      const totalFilteredRows = this.gridApi.getDisplayedRowCount();
      const pageSize = this.gridApi.paginationGetPageSize();
      const currentPage = this.gridApi.paginationGetCurrentPage();
      const startRow = currentPage * pageSize;
      const endRow = Math.min(startRow + pageSize, totalFilteredRows);
      const displayedOnPage = totalFilteredRows > 0 ? endRow - startRow : 0;
      this.displayedRows = displayedOnPage;
      this.totalRows = totalFilteredRows;
    } else {
      this.displayedRows = this.filteredRowData.length;
      this.totalRows = this.filteredRowData.length;
    }
  }
  onAddClick() {
    this.addClick.emit();
  }
  onColumnSettingsClick() {
    if (this.gridApi) {
      console.log("Column settings clicked");
    }
  }
  /**
   * Get status class based on status value
   * Helper method to automatically determine status badge class from enum/string values
   */
  static getStatusClass(statusValue) {
    if (!statusValue) return "status-neutral";
    const status = String(statusValue).toLowerCase().replace(/[_\s-]/g, "-");
    if (["paid", "closed", "cleared", "active", "completed", "approved", "enabled", "online", "available", "done", "finished", "resolved", "accepted", "verified", "confirmed", "delivered", "published", "live"].includes(status)) {
      return "status-success";
    }
    if (["cancelled", "canceled", "failed", "void", "rejected", "denied", "blocked", "disabled", "inactive", "unavailable", "offline", "expired", "terminated", "suspended", "deleted", "error", "critical"].includes(status)) {
      return "status-danger";
    }
    if (["pending", "in-progress", "in_progress", "waiting", "processing", "queued", "draft", "review", "under-review", "on-hold", "onhold", "delayed", "partially-paid", "partially_paid", "partial"].includes(status)) {
      return "status-warning";
    }
    if (["issued", "scheduled", "assigned", "allocated", "reserved", "booked", "acknowledged", "notified", "info"].includes(status)) {
      return "status-info";
    }
    if (["urgent", "emergency", "high-priority", "high_priority", "priority"].includes(status)) {
      return "status-urgent";
    }
    if (["busy", "working", "occupied"].includes(status)) {
      return "status-busy";
    }
    return "status-neutral";
  }
  /**
   * Process column definitions to add menu column if needed
   *
   * This method:
   * 1. Checks if any column has cellRenderer: 'gridMenu'
   * 2. If menuActions exist in gridOptions but no menu column is configured, adds one automatically
   * 3. If a menu column exists, updates it with the proper cell renderer
   * 4. Auto-detects status columns and applies appropriate cell classes
   */
  processColumnDefs() {
    this.processedColumnDefs = this.columnDefs.map((col) => {
      const field = col.field?.toLowerCase() || "";
      const isStatusColumn = field.includes("status") || field.includes("state");
      return __spreadProps(__spreadValues({}, col), {
        floatingFilter: col.floatingFilter ?? false,
        suppressHeaderMenuButton: col.suppressHeaderMenuButton ?? true,
        // Auto-add status cell class for status columns
        cellClass: isStatusColumn && !col.cellClass ? "status-cell" : col.cellClass
      });
    });
    const hasMenuColumn = this.processedColumnDefs.some((col) => col.cellRenderer === "gridMenu" || col.cellRenderer === GridMenuRendererComponent || col.field === "actions" && col.pinned === "right");
    const extendedGridOptions = this.gridOptions;
    if (!hasMenuColumn && extendedGridOptions.menuActions && extendedGridOptions.menuActions.length > 0) {
      this.processedColumnDefs.push({
        headerName: "",
        field: "actions",
        sortable: false,
        filter: false,
        width: 36,
        minWidth: 36,
        maxWidth: 36,
        suppressSizeToFit: true,
        resizable: false,
        pinned: "right",
        cellClass: "actions-cell",
        headerClass: "actions-header-cell",
        cellRenderer: GridMenuRendererComponent,
        cellRendererParams: {
          menuActions: extendedGridOptions.menuActions
        }
      });
    } else if (hasMenuColumn) {
      this.processedColumnDefs = this.processedColumnDefs.map((col) => {
        if (col.cellRenderer === "gridMenu") {
          return __spreadProps(__spreadValues({}, col), {
            cellRenderer: GridMenuRendererComponent,
            cellRendererParams: {
              menuActions: extendedGridOptions.menuActions
            }
          });
        }
        return col;
      });
    }
  }
  onSearchChange(value) {
    this.searchText = value;
    const base = this._activeFilters && this._activeFilters.length ? (this.rowData || []).filter((r) => this._activeFilters.map((f) => this.evaluateFilter(r, f)).reduce((acc, cur) => this._activeLogic === "AND" ? acc && cur : acc || cur, this._activeLogic === "AND")) : [...this.rowData || []];
    this.filteredRowData = this.applySearchTo(base);
    this.searchChange.emit(value);
  }
  applySearchTo(data) {
    if (!this.searchText || !this.searchText.trim()) return data;
    const searchTerm = this.searchText.toLowerCase();
    return (data || []).filter((row) => Object.values(row).some((value) => value?.toString().toLowerCase().includes(searchTerm)));
  }
  onFilterClick() {
    const data = this.buildFilterDialogData();
    const ref = this.dialogbox.openDialog(FilterComponent, {
      title: "Filter Grid",
      data,
      width: "900px"
    });
    ref.afterClosed().subscribe((result) => {
      if (result && result.filters) {
        this.applyAdvancedFilters(result.filters, result.logic || "AND");
        this.activeFiltersCount = result.filters.length;
        this.updateFilterChips(result.filters);
      } else if (result === null) {
        this.activeFiltersCount = 0;
        this.activeFilterChips = [];
      }
    });
  }
  buildFilterDialogData() {
    const extendedGridOptions = this.gridOptions;
    const provided = extendedGridOptions.filterConfig || {};
    const fields = provided.fields && provided.fields.length ? provided.fields : this.columnDefs.filter((col) => !!col.field).map((col) => {
      return {
        label: col.headerName || col.field,
        value: col.field,
        inputType: this.detectInputType(col.field)
      };
    });
    const valuesMap = __spreadValues({}, provided.valuesMap || {});
    const operatorsMap = __spreadValues({}, provided.operatorsMap || {});
    for (const fieldDef of fields) {
      if (fieldDef.inputType === "select") {
        if (!valuesMap[fieldDef.value]) {
          valuesMap[fieldDef.value] = this.getUniqueValues(fieldDef.value, 200);
        }
      }
      if (!operatorsMap[fieldDef.value]) {
        operatorsMap[fieldDef.value] = this.defaultOperatorsByType(fieldDef.inputType);
      }
    }
    const initialFilters = provided.initialFilters || this._activeFilters || [];
    const logic = provided.logic || this._activeLogic || "AND";
    return {
      fields,
      valuesMap,
      operatorsMap,
      filters: initialFilters,
      logic
    };
  }
  detectInputType(field) {
    const uniques = this.getUniqueValues(field, 51);
    if (uniques.length > 0 && uniques.length <= 50) {
      return "select";
    }
    const sample = this.rowData && this.rowData.length ? this.rowData[0][field] : void 0;
    if (typeof sample === "number") return "number";
    if (typeof sample === "boolean") return "boolean";
    if (this.looksLikeDate(sample)) return "date";
    return "input";
  }
  looksLikeDate(value) {
    if (!value) return false;
    if (value instanceof Date) return true;
    const dt = new Date(value);
    return !isNaN(dt.getTime());
  }
  getUniqueValues(field, limit) {
    const set = /* @__PURE__ */ new Set();
    for (const row of this.rowData || []) {
      set.add(row[field]);
      if (set.size >= limit) break;
    }
    return Array.from(set);
  }
  defaultOperatorsByType(type) {
    switch (type) {
      case "number":
        return [{
          label: "Equals",
          value: "eq"
        }, {
          label: "Not Equals",
          value: "neq"
        }, {
          label: "Greater Than",
          value: "gt"
        }, {
          label: "Greater Or Equal",
          value: "gte"
        }, {
          label: "Less Than",
          value: "lt"
        }, {
          label: "Less Or Equal",
          value: "lte"
        }, {
          label: "Between",
          value: "between"
        }];
      case "date":
        return [{
          label: "On",
          value: "eq"
        }, {
          label: "Before",
          value: "lt"
        }, {
          label: "After",
          value: "gt"
        }, {
          label: "Between",
          value: "between"
        }];
      case "boolean":
        return [{
          label: "Is",
          value: "eq"
        }, {
          label: "Is Not",
          value: "neq"
        }];
      case "select":
      case "input":
      default:
        return [{
          label: "Contains",
          value: "contains"
        }, {
          label: "Equals",
          value: "eq"
        }, {
          label: "Not Equals",
          value: "neq"
        }, {
          label: "Starts With",
          value: "startsWith"
        }, {
          label: "Ends With",
          value: "endsWith"
        }, {
          label: "Is Empty",
          value: "empty"
        }, {
          label: "Is Not Empty",
          value: "notEmpty"
        }];
    }
  }
  updateFilterChips(filters) {
    this.activeFilterChips = filters.map((f) => {
      const column = this.columnDefs.find((col) => col.field === f.field);
      const label = column?.headerName || f.field;
      let value = f.value;
      if (f.inputType === "boolean") {
        value = f.value === true || f.value === "true" ? "Yes" : "No";
      } else if (f.inputType === "date") {
        value = new Date(f.value).toLocaleDateString();
      } else if (f.operator === "between" && f.valueTo !== void 0) {
        value = `${f.value} - ${f.valueTo}`;
      }
      return {
        label,
        value: String(value),
        field: f.field
      };
    });
  }
  removeFilterChip(field) {
    this._activeFilters = this._activeFilters.filter((f) => f.field !== field);
    this.activeFiltersCount = this._activeFilters.length;
    this.activeFilterChips = this.activeFilterChips.filter((chip) => chip.field !== field);
    if (this._activeFilters.length === 0) {
      this.filteredRowData = this.applySearchTo([...this.rowData || []]);
    } else {
      this.applyAdvancedFilters(this._activeFilters, this._activeLogic);
    }
  }
  applyAdvancedFilters(filters, logic) {
    this._activeFilters = filters;
    this._activeLogic = logic;
    if (!filters || filters.length === 0) {
      this.filteredRowData = this.applySearchTo([...this.rowData || []]);
      this.activeFilterChips = [];
      return;
    }
    const evaluator = (row) => {
      const results = filters.map((f) => this.evaluateFilter(row, f));
      return logic === "AND" ? results.every(Boolean) : results.some(Boolean);
    };
    const base = (this.rowData || []).filter(evaluator);
    this.filteredRowData = this.applySearchTo(base);
  }
  evaluateFilter(row, f) {
    const raw = row[f.field];
    const op = (f.operator || "").toLowerCase();
    const type = f.inputType;
    if (op === "empty") return raw === void 0 || raw === null || String(raw).trim() === "";
    if (op === "notempty") return !(raw === void 0 || raw === null || String(raw).trim() === "");
    if (type === "number") {
      const a2 = Number(raw);
      const b2 = Number(f.value);
      const c = f.valueTo !== void 0 ? Number(f.valueTo) : void 0;
      if (isNaN(a2) || isNaN(b2)) return false;
      switch (op) {
        case "eq":
          return a2 === b2;
        case "neq":
          return a2 !== b2;
        case "gt":
          return a2 > b2;
        case "gte":
          return a2 >= b2;
        case "lt":
          return a2 < b2;
        case "lte":
          return a2 <= b2;
        case "between":
          return c !== void 0 && !isNaN(c) ? a2 >= Math.min(b2, c) && a2 <= Math.max(b2, c) : false;
        default:
          return false;
      }
    }
    if (type === "date") {
      const a2 = this.toDate(raw);
      const b2 = this.toDate(f.value);
      const c = f.valueTo ? this.toDate(f.valueTo) : null;
      if (!a2 || !b2) return false;
      switch (op) {
        case "eq":
          return this.sameDay(a2, b2);
        case "lt":
          return a2.getTime() < b2.getTime();
        case "gt":
          return a2.getTime() > b2.getTime();
        case "between":
          return !!c && a2.getTime() >= Math.min(b2.getTime(), c.getTime()) && a2.getTime() <= Math.max(b2.getTime(), c.getTime());
        default:
          return false;
      }
    }
    if (type === "boolean") {
      const a2 = Boolean(raw);
      const b2 = f.value === true || f.value === "true";
      switch (op) {
        case "eq":
          return a2 === b2;
        case "neq":
          return a2 !== b2;
        default:
          return false;
      }
    }
    const a = (raw ?? "").toString().toLowerCase();
    const b = (f.value ?? "").toString().toLowerCase();
    switch (op) {
      case "eq":
        return a === b;
      case "neq":
        return a !== b;
      case "contains":
        return a.includes(b);
      case "startswith":
        return a.startsWith(b);
      case "endswith":
        return a.endsWith(b);
      default:
        return false;
    }
  }
  toDate(value) {
    if (!value) return null;
    if (value instanceof Date) return value;
    const d = new Date(value);
    return isNaN(d.getTime()) ? null : d;
  }
  sameDay(a, b) {
    return a.getFullYear() === b.getFullYear() && a.getMonth() === b.getMonth() && a.getDate() === b.getDate();
  }
  // New grid methods for enhanced functionality
  onRefresh() {
    this.filteredRowData = [...this.rowData];
    console.log("Grid refreshed");
  }
  onExport() {
    const csvContent = this.exportToCSV();
    this.downloadCSV(csvContent, "grid-data.csv");
  }
  exportToCSV() {
    if (!this.filteredRowData || this.filteredRowData.length === 0) {
      return "";
    }
    const headers = this.processedColumnDefs.filter((col) => col.field && col.field !== "actions").map((col) => col.headerName || col.field);
    const rows = this.filteredRowData.map((item) => this.processedColumnDefs.filter((col) => col.field && col.field !== "actions").map((col) => {
      const value = item[col.field];
      return typeof value === "string" ? `"${value.replace(/"/g, '""')}"` : value;
    }));
    const csvArray = [headers, ...rows];
    return csvArray.map((row) => row.join(",")).join("\n");
  }
  downloadCSV(content, filename) {
    const blob = new Blob([content], {
      type: "text/csv;charset=utf-8;"
    });
    const link = document.createElement("a");
    if (link.download !== void 0) {
      const url = URL.createObjectURL(blob);
      link.setAttribute("href", url);
      link.setAttribute("download", filename);
      link.style.visibility = "hidden";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  }
  // View mode switching
  switchToListView() {
    this.viewMode = "list";
  }
  switchToCardView() {
    this.viewMode = "card";
  }
  toggleViewMode() {
    this.viewMode = this.viewMode === "list" ? "card" : "list";
  }
  onRowClicked(event) {
    if (!event || !event.data) return;
    if (this.gridOptions.rowSelection && this.gridApi && event.node) {
      if (this.gridOptions.rowSelection === "single") {
        this.gridApi.deselectAll();
      }
      event.node.setSelected(true);
    }
    this.rowClicked.emit(event.data);
  }
  ngOnDestroy() {
    if (this.dataFetchSub) {
      this.dataFetchSub.unsubscribe();
    }
  }
  shouldFetchFromApi() {
    return (!this.rowData || this.rowData.length === 0) && !!this.apiConfig?.dataConfig;
  }
  fetchGridDataFromApi() {
    if (!this.apiConfig?.dataConfig) {
      return;
    }
    const limits = this.getPaginationLimits();
    const dataRequest$ = this.sendApiRequest(this.apiConfig.dataConfig, limits).pipe(catchError(() => of({})));
    const countRequest$ = this.apiConfig.countConfig ? this.sendApiRequest(this.apiConfig.countConfig, limits).pipe(catchError(() => of({}))) : of(null);
    if (this.dataFetchSub) {
      this.dataFetchSub.unsubscribe();
    }
    this.dataFetchSub = forkJoin({
      data: dataRequest$,
      count: countRequest$
    }).subscribe((response) => {
      const rows = this.extractDataArray(response.data);
      const count2 = this.extractCount(response.count);
      this.applyFetchedData(rows, count2);
    });
  }
  sendApiRequest(config, limits) {
    const url = this.appendQueryParams(this.buildUrl(config.url), config, limits);
    const method = (config.requestType || "GET").toUpperCase();
    if (method === "POST") {
      const payload = this.buildPayload(config, limits);
      return this.http.post(url, payload);
    }
    const params = this.buildHttpParams(config, limits);
    return this.http.get(url, {
      params
    });
  }
  buildPayload(config, limits) {
    const payload = __spreadValues({}, config.params || {});
    if (limits) {
      const lowerKey = config.lLimitKey || "llimit";
      const upperKey = config.uLimitKey || "ulimit";
      payload[lowerKey] = limits.lower;
      payload[upperKey] = limits.upper;
    }
    return config.suppressNullValues ? this.stripNullish(payload) : payload;
  }
  buildHttpParams(config, limits) {
    const params = __spreadValues({}, config.params || {});
    if (limits) {
      const lowerKey = config.lLimitKey || "llimit";
      const upperKey = config.uLimitKey || "ulimit";
      params[lowerKey] = limits.lower;
      params[upperKey] = limits.upper;
    }
    const cleaned = config.suppressNullValues ? this.stripNullish(params) : params;
    let httpParams = new HttpParams();
    Object.entries(cleaned).forEach(([key, value]) => {
      if (value !== void 0 && value !== null) {
        httpParams = httpParams.append(key, String(value));
      }
    });
    return httpParams;
  }
  stripNullish(obj) {
    return Object.entries(obj).reduce((acc, [key, value]) => {
      if (value !== null && value !== void 0) {
        acc[key] = value;
      }
      return acc;
    }, {});
  }
  appendQueryParams(url, config, limits) {
    if (!config.queryParamsUrl) {
      return url;
    }
    const lower = limits?.lower ?? "";
    const upper = limits?.upper ?? "";
    const query2 = config.queryParamsUrl.replace(/\$llimit/gi, String(lower)).replace(/\$ulimit/gi, String(upper));
    if (!query2) {
      return url;
    }
    const separator = url.includes("?") ? "&" : "?";
    return `${url}${separator}${query2}`;
  }
  buildUrl(path) {
    const base = this.apiConfigService.getApiUrl();
    if (!base) {
      return path;
    }
    return `${base.replace(/\/$/, "")}/${path.replace(/^\//, "")}`;
  }
  extractDataArray(response) {
    if (!response) return [];
    const casted = response;
    return casted.data || casted.result || casted.records || casted.items || [];
  }
  extractCount(response) {
    if (!response) return void 0;
    const casted = response;
    return casted.count ?? casted.totalCount ?? casted.total;
  }
  applyFetchedData(rows, totalCount) {
    this.rowData = Array.isArray(rows) ? rows : [];
    this.filteredRowData = this.applySearchTo([...this.rowData]);
    this.totalRows = totalCount ?? this.rowData.length;
    this.displayedRows = this.filteredRowData.length;
    this.processColumnDefs();
    this.updatePaginationInfo();
  }
  getPaginationLimits() {
    const pageSize = this.gridOptions.paginationPageSize || 25;
    const lower = 0;
    const upper = lower + pageSize;
    return {
      lower,
      upper
    };
  }
  static {
    this.ɵfac = function GridComponent_Factory(t) {
      return new (t || _GridComponent)(ɵɵdirectiveInject(DialogboxService), ɵɵdirectiveInject(PLATFORM_ID), ɵɵdirectiveInject(ApiConfigService), ɵɵdirectiveInject(HttpClient));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _GridComponent,
      selectors: [["app-grid"]],
      inputs: {
        rowData: "rowData",
        columnDefs: "columnDefs",
        gridOptions: "gridOptions",
        domLayout: "domLayout",
        animateRows: "animateRows",
        class: "class",
        height: "height",
        width: "width",
        showHeader: "showHeader",
        searchPlaceholder: "searchPlaceholder",
        rightTooltemplateRef: "rightTooltemplateRef",
        cardTemplate: "cardTemplate",
        defaultViewMode: "defaultViewMode",
        showAddButton: "showAddButton",
        apiConfig: "apiConfig"
      },
      outputs: {
        searchChange: "searchChange",
        rowClicked: "rowClicked",
        addClick: "addClick"
      },
      standalone: true,
      features: [ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
      decls: 7,
      vars: 4,
      consts: [[1, "grid-container"], ["class", "grid-toolbar", 4, "ngIf"], [1, "grid-content"], [1, "grid-wrapper"], ["class", "clean-grid ag-theme-clean", 3, "rowData", "columnDefs", "gridOptions", "domLayout", "animateRows", "class", "has-row-selection", "width", "height", "gridReady", "modelUpdated", "rowClicked", 4, "ngIf"], ["class", "card-grid", 4, "ngIf"], ["class", "grid-loading", 4, "ngIf"], [1, "grid-toolbar"], [1, "toolbar-left"], [1, "pagination-info"], ["class", "filter-chips", 4, "ngIf"], [1, "toolbar-center"], [1, "search-section"], [1, "search-input", 3, "valueChange", "placeholder", "value", "prefixIconName", "search"], [1, "toolbar-right"], [1, "action-icons"], [4, "ngTemplateOutlet"], ["title", "Filter", 1, "icon-btn", "filter-btn", 3, "click"], [1, "filter-chips"], ["class", "filter-chip", 4, "ngFor", "ngForOf"], [1, "filter-chip"], [1, "chip-label"], [1, "chip-value"], ["type", "button", "title", "Remove filter", "aria-label", "Remove filter", 1, "chip-remove", 3, "click"], [1, "clean-grid", "ag-theme-clean", 3, "gridReady", "modelUpdated", "rowClicked", "rowData", "columnDefs", "gridOptions", "domLayout", "animateRows"], [1, "card-grid"], [4, "ngFor", "ngForOf"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "grid-loading"], [1, "loading-spinner"]],
      template: function GridComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "div", 0);
          ɵɵtemplate(1, GridComponent_div_1_Template, 14, 10, "div", 1);
          ɵɵelementStart(2, "div", 2)(3, "div", 3);
          ɵɵtemplate(4, GridComponent_ag_grid_angular_4_Template, 1, 13, "ag-grid-angular", 4)(5, GridComponent_div_5_Template, 2, 1, "div", 5)(6, GridComponent_div_6_Template, 4, 0, "div", 6);
          ɵɵelementEnd()()();
        }
        if (rf & 2) {
          ɵɵadvance();
          ɵɵproperty("ngIf", ctx.showHeader);
          ɵɵadvance(3);
          ɵɵproperty("ngIf", ctx.isBrowser && ctx.viewMode === "list");
          ɵɵadvance();
          ɵɵproperty("ngIf", ctx.isBrowser && ctx.viewMode === "card" && ctx.cardTemplate);
          ɵɵadvance();
          ɵɵproperty("ngIf", !ctx.isBrowser);
        }
      },
      dependencies: [CommonModule, NgForOf, NgIf, NgTemplateOutlet, AgGridModule, AgGridAngular, AppInputComponent, HttpClientModule, MatMenuModule, MatIconModule, MatIcon, MatButtonModule],
      styles: ['.grid-container[_ngcontent-%COMP%]{display:flex;flex-direction:column;height:100%;width:100%;background:var(--page-background-color);border-radius:var(--input-radius);overflow:hidden;box-shadow:var(--primary-shadow)}.grid-container[_ngcontent-%COMP%]     .mat-mdc-form-field-subscript-wrapper{display:none!important}.grid-toolbar[_ngcontent-%COMP%]{min-height:4em;display:flex;align-items:center;justify-content:space-between;padding:.75em 1.25em;background:var(--surface-color);border-bottom:1px solid var(--primary-border);border-radius:var(--input-radius) var(--input-radius) 0 0;box-shadow:inset 0 -1px #18b6b21a;gap:1.25em;flex-wrap:wrap}.toolbar-left[_ngcontent-%COMP%]{display:flex;align-items:center;gap:1em;min-width:0}.toolbar-left[_ngcontent-%COMP%]   .pagination-info[_ngcontent-%COMP%]{display:inline-flex;align-items:center;padding:6px 12px;background:#18b6b214;border-radius:999px;color:var(--primary-color);font-weight:var(--secondary-font-weight);font-size:calc(var(--tertiary-font-size) - 1px);letter-spacing:.015em}.toolbar-left[_ngcontent-%COMP%]   .filter-chips[_ngcontent-%COMP%]{display:flex;align-items:center;flex-wrap:wrap;gap:8px;max-width:clamp(200px,30vw,450px);padding-left:4px}.toolbar-left[_ngcontent-%COMP%]   .filter-chip[_ngcontent-%COMP%]{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;background:#18b6b21f;border:1px solid rgba(24,182,178,.35);border-radius:999px;color:var(--primary-font-color);font-size:calc(var(--tertiary-font-size) - 1px);transition:all .2s ease}.toolbar-left[_ngcontent-%COMP%]   .filter-chip[_ngcontent-%COMP%]   .chip-label[_ngcontent-%COMP%]{font-weight:600;color:var(--primary-color)}.toolbar-left[_ngcontent-%COMP%]   .filter-chip[_ngcontent-%COMP%]   .chip-value[_ngcontent-%COMP%]{font-weight:var(--secondary-font-weight);max-width:130px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.toolbar-left[_ngcontent-%COMP%]   .filter-chip[_ngcontent-%COMP%]:hover{background:#18b6b22e;border-color:#18b6b28c;box-shadow:0 8px 16px -12px #18b6b2d9;transform:translateY(-1px)}.toolbar-left[_ngcontent-%COMP%]   .filter-chip[_ngcontent-%COMP%]   .chip-remove[_ngcontent-%COMP%]{width:18px;height:18px;border-radius:50%;background:#ffffffd9;border:none;color:var(--primary-color);display:flex;align-items:center;justify-content:center;cursor:pointer;font-size:12px;line-height:1;padding:0;transition:all .2s ease}.toolbar-left[_ngcontent-%COMP%]   .filter-chip[_ngcontent-%COMP%]   .chip-remove[_ngcontent-%COMP%]:hover{background:var(--primary-color);color:var(--surface-color);box-shadow:0 4px 10px -6px var(--primary-color)}.toolbar-center[_ngcontent-%COMP%]{flex:1;display:flex;justify-content:flex-start;max-width:400px}.toolbar-center[_ngcontent-%COMP%]   .search-section[_ngcontent-%COMP%]{width:100%;max-width:320px}.toolbar-center[_ngcontent-%COMP%]   .search-section[_ngcontent-%COMP%]   .search-input[_ngcontent-%COMP%]{width:100%}.toolbar-center[_ngcontent-%COMP%]   .search-section[_ngcontent-%COMP%]   .search-input[_ngcontent-%COMP%]     .app-input-container{box-shadow:var(--primary-shadow);border:1px solid var(--primary-border);transition:all .3s ease}.toolbar-center[_ngcontent-%COMP%]   .search-section[_ngcontent-%COMP%]   .search-input[_ngcontent-%COMP%]     .app-input-container:focus-within{border-color:var(--primary-color);box-shadow:0 0 0 3px #18b6b21a}.toolbar-right[_ngcontent-%COMP%]{flex:0 0 auto}.toolbar-right[_ngcontent-%COMP%]   .action-icons[_ngcontent-%COMP%]{display:flex;align-items:center;gap:12px;background:#18b6b20f;border-radius:999px;padding:6px 10px}.icon-btn[_ngcontent-%COMP%]{display:inline-flex;align-items:center;justify-content:center;gap:8px;width:40px;height:40px;border:1px solid var(--primary-border);border-radius:50%;background:var(--surface-color);color:var(--primary-font-color);font-size:var(--tertiary-font-size);font-weight:var(--secondary-font-weight);cursor:pointer;transition:all .3s ease;position:relative;-webkit-backdrop-filter:blur(4px);backdrop-filter:blur(4px)}.icon-btn[_ngcontent-%COMP%]:hover{background:var(--secondary-background-color);border-color:var(--primary-color);transform:translateY(-1px);box-shadow:var(--primary-shadow)}.icon-btn[_ngcontent-%COMP%]:active{transform:translateY(0);box-shadow:0 2px 4px #0000001a}.icon-btn[_ngcontent-%COMP%]:focus-visible{outline:2px solid rgba(24,182,178,.4);outline-offset:2px}.icon-btn.add-btn[_ngcontent-%COMP%]{background:linear-gradient(135deg,var(--primary-color),var(--tertiary-color));color:var(--surface-color);border-color:transparent;box-shadow:0 10px 18px -15px #18b6b2d9}.icon-btn.add-btn[_ngcontent-%COMP%]:hover{border-color:transparent;box-shadow:0 16px 28px -18px #18b6b2f2}.icon-btn.settings-btn[_ngcontent-%COMP%]{background:#18b6b214;border-color:#18b6b240}.icon-btn.settings-btn[_ngcontent-%COMP%]:hover{background:#18b6b229;border-color:var(--primary-color);color:var(--primary-color)}.icon-btn.refresh-btn[_ngcontent-%COMP%]:hover, .icon-btn.export-btn[_ngcontent-%COMP%]:hover{background:var(--secondary-background-color);border-color:var(--tertiary-color);color:var(--primary-font-color)}.icon-btn.filter-btn.active[_ngcontent-%COMP%], .icon-btn.filter-btn[_ngcontent-%COMP%]:hover{background:var(--diet-quinary-color);border-color:var(--primary-color);color:var(--primary-color)}.icon-btn.filter-btn[_ngcontent-%COMP%]   .filter-badge[_ngcontent-%COMP%]{position:absolute;top:-8px;right:-8px;background:var(--diet-secondary-color);color:var(--surface-color);border-radius:50%;width:20px;height:20px;display:flex;align-items:center;justify-content:center;font-size:10px;font-weight:600;border:2px solid var(--surface-color)}.grid-content[_ngcontent-%COMP%]{height:calc(100% - 4em);flex:1;display:flex;flex-direction:column;overflow:hidden;background:linear-gradient(160deg,#18b6b20d,#1c324605)}.grid-wrapper[_ngcontent-%COMP%]{flex:1;position:relative;overflow:hidden;height:100%;background:var(--surface-color);border-radius:calc(var(--input-radius) + 2px);box-shadow:0 24px 48px -32px #0f172a8c;border:1px solid rgba(24,182,178,.08)}.grid-wrapper[_ngcontent-%COMP%]:after{content:"";position:absolute;inset:0;pointer-events:none;background:linear-gradient(180deg,#18b6b212,#18b6b200 40%);opacity:.6}@media (max-width: 960px){.grid-toolbar[_ngcontent-%COMP%]{padding:.75em;gap:.75em}.toolbar-left[_ngcontent-%COMP%]{flex:1 1 100%;justify-content:space-between}.toolbar-center[_ngcontent-%COMP%]{order:3;flex-basis:100%;margin-top:.75em}.toolbar-right[_ngcontent-%COMP%]{margin-left:auto}}@media (max-width: 640px){.toolbar-left[_ngcontent-%COMP%]{flex-direction:column;align-items:flex-start;gap:.5em}.toolbar-left[_ngcontent-%COMP%]   .pagination-info[_ngcontent-%COMP%]{width:100%;justify-content:center}.toolbar-left[_ngcontent-%COMP%]   .filter-chips[_ngcontent-%COMP%]{max-width:100%}.icon-btn[_ngcontent-%COMP%]{width:36px;height:36px}}  .status-chip{display:inline-flex;align-items:center;justify-content:center;padding:6px 12px;border-radius:var(--button-radius);border:1px solid;font-size:var(--tertiary-font-size);font-weight:var(--secondary-font-weight);line-height:1.4;white-space:nowrap;min-width:80px;text-transform:capitalize}  .status-success{background:var(--status-success-bg);color:var(--status-success-color);border-color:var(--status-success-border)}  .status-warning{background:var(--status-warning-bg);color:var(--status-warning-color);border-color:var(--status-warning-border)}  .status-danger{background:var(--status-danger-bg);color:var(--status-danger-color);border-color:var(--status-danger-border)}  .status-info{background:var(--status-info-bg);color:var(--status-info-color);border-color:var(--status-info-border)}  .status-neutral{background:var(--status-neutral-bg);color:var(--status-neutral-color);border-color:var(--status-neutral-border)}  .status-available{background:var(--status-available-bg);color:var(--status-available-color);border-color:var(--status-available-border)}  .status-unavailable{background:var(--status-unavailable-bg);color:var(--status-unavailable-color);border-color:var(--status-unavailable-border)}  .status-busy{background:var(--status-busy-bg);color:var(--status-busy-color);border-color:var(--status-busy-border)}  .status-offline{background:var(--status-offline-bg);color:var(--status-offline-color);border-color:var(--status-offline-border)}  .actions-header-cell{padding:0!important}  .actions-cell{padding:0!important;display:flex;align-items:center;justify-content:center;position:relative}  .ag-row.ag-row-hover .actions-cell:after,   .ag-row.ag-row-selected .actions-cell:after{content:"";position:absolute;right:0;top:0;bottom:0;width:4px;background:var(--primary-color)}.grid-loading[_ngcontent-%COMP%]{display:flex;flex-direction:column;align-items:center;justify-content:center;height:300px;color:var(--secondary-font-color);gap:16px}.grid-loading[_ngcontent-%COMP%]   .loading-spinner[_ngcontent-%COMP%]{width:32px;height:32px;border:3px solid var(--primary-border);border-top:3px solid var(--primary-color);border-radius:50%;animation:_ngcontent-%COMP%_spin 1s linear infinite}@keyframes _ngcontent-%COMP%_spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.grid-empty[_ngcontent-%COMP%]{display:flex;flex-direction:column;align-items:center;justify-content:center;height:400px;padding:40px;text-align:center;color:var(--secondary-font-color)}.grid-empty[_ngcontent-%COMP%]   .empty-icon[_ngcontent-%COMP%]{margin-bottom:16px;opacity:.6}.grid-empty[_ngcontent-%COMP%]   h4[_ngcontent-%COMP%]{margin:0 0 8px;font-size:var(--primary-font-size);font-weight:var(--primary-font-weight);color:var(--primary-font-color)}.grid-empty[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{margin:0 0 24px;font-size:var(--tertiary-font-size);color:var(--secondary-font-color);max-width:300px;line-height:1.5}.grid-empty[_ngcontent-%COMP%]   .empty-action-btn[_ngcontent-%COMP%]{display:flex;align-items:center;gap:8px;padding:12px 20px;border:1px solid var(--primary-color);border-radius:var(--button-radius);background:var(--primary-color);color:var(--surface-color);font-size:var(--tertiary-font-size);font-weight:var(--secondary-font-weight);cursor:pointer;transition:all .3s ease}.grid-empty[_ngcontent-%COMP%]   .empty-action-btn[_ngcontent-%COMP%]:hover{background:var(--primary-color);transform:translateY(-1px);box-shadow:var(--primary-shadow)}  .ag-row-focus{background:var(--secondary-background-color)!important;border-left:3px solid var(--primary-color)!important}  .clean-grid.ag-theme-clean{--ag-background-color: var(--surface-color);--ag-foreground-color: var(--primary-font-color);--ag-border-color: var(--primary-border);--ag-header-background-color: var(--page-background-color);--ag-header-foreground-color: var(--primary-font-color);--ag-odd-row-background-color: var(--surface-color);--ag-row-hover-color: var(--secondary-background-color);--ag-selected-row-background-color: rgba(24, 182, 178, .1);--ag-range-selection-background-color: rgba(24, 182, 178, .2);--ag-header-height: 56px;--ag-row-height: 52px;--ag-grid-size: 4px;--ag-icon-size: 16px;--ag-font-size: var(--tertiary-font-size);--ag-font-family: inherit;border:none!important;border-radius:0 0 var(--input-radius) var(--input-radius);box-shadow:none!important}  .clean-grid .ag-header{background:linear-gradient(180deg,var(--page-background-color) 0%,var(--secondary-background-color) 100%);border-bottom:2px solid var(--primary-border);font-weight:var(--primary-font-weight)}  .clean-grid .ag-header .ag-header-cell{border-right:1px solid var(--primary-border);padding:0 16px}  .clean-grid .ag-header .ag-header-cell .ag-header-cell-label{font-weight:var(--primary-font-weight);color:var(--primary-font-color);font-size:var(--tertiary-font-size)}  .clean-grid .ag-header .ag-header-cell:hover{background:#18b6b20d}  .clean-grid .ag-header .ag-header-cell-resize{background:var(--primary-color);width:2px;opacity:.6}  .clean-grid .ag-row{border-bottom:1px solid var(--primary-border);transition:all .2s ease}  .clean-grid .ag-row:hover{background:var(--page-background-color)!important;box-shadow:inset 4px 0 0 var(--primary-color)}  .clean-grid .ag-row.ag-row-selected{background:#18b6b214!important;border-color:var(--primary-color)}  .clean-grid .ag-row:last-child{border-bottom:none}  .clean-grid.has-row-selection .ag-row{cursor:pointer}  .clean-grid.has-row-selection .ag-row.ag-row-selected{background:#18b6b226!important;border-left:4px solid var(--primary-color)!important;box-shadow:inset 0 0 0 1px #18b6b233,0 2px 8px #18b6b21a!important}  .clean-grid.has-row-selection .ag-row.ag-row-selected .ag-cell{background-color:transparent!important;font-weight:var(--secondary-font-weight)}  .clean-grid.has-row-selection .ag-row.ag-row-selected:hover{background:#18b6b22e!important;box-shadow:inset 0 0 0 1px #18b6b24d,0 4px 12px #18b6b226!important}  .clean-grid.has-row-selection .ag-row.ag-row-focus.ag-row-selected{background:#18b6b226!important;border-left:4px solid var(--primary-color)!important}  .clean-grid .ag-cell{display:flex!important;align-items:center!important;padding:0 16px;border-right:1px solid transparent;color:var(--primary-font-color);font-size:var(--tertiary-font-size);line-height:1.4}  .clean-grid .ag-cell:focus{border:2px solid var(--primary-color)!important;outline:none;border-radius:4px}  .clean-grid .ag-cell .ag-cell-value{display:flex!important;align-items:center!important;width:100%}  .clean-grid .ag-center-cols-viewport{background:var(--surface-color)}  .clean-grid .ag-root-wrapper,   .clean-grid .ag-root-wrapper.ag-layout-auto-height.ag-ltr,   .clean-grid .ag-root-wrapper-body{height:100%;border:none!important;box-shadow:none!important}  .clean-grid .ag-body-viewport{overflow-y:scroll}  .clean-grid .ag-body-viewport::-webkit-scrollbar{width:8px;height:8px}  .clean-grid .ag-body-viewport::-webkit-scrollbar-track{background:var(--secondary-background-color);border-radius:4px}  .clean-grid .ag-body-viewport::-webkit-scrollbar-thumb{background:var(--tertiary-color);border-radius:4px;transition:background .3s ease}  .clean-grid .ag-body-viewport::-webkit-scrollbar-thumb:hover{background:var(--primary-color)}  .clean-grid .ag-overlay-loading-wrapper{background:#ffffffe6;-webkit-backdrop-filter:blur(4px);backdrop-filter:blur(4px)}  .clean-grid .ag-overlay-no-rows-wrapper{background:transparent}  .clean-grid .ag-header-icon{color:var(--primary-color)}  .clean-grid .ag-header-cell-filtered{background:#18b6b21a}  .clean-grid .ag-header-cell-filtered .ag-header-cell-label{color:var(--primary-color);font-weight:600}  .clean-grid .ag-selection-checkbox .ag-input-wrapper{background:var(--surface-color);border:2px solid var(--primary-border);border-radius:4px}  .clean-grid .ag-selection-checkbox .ag-input-wrapper:after{color:var(--primary-color)}  .clean-grid .ag-selection-checkbox input:checked+.ag-input-wrapper{background:var(--primary-color);border-color:var(--primary-color)}  .clean-grid .ag-pinned-left-cols-container,   .clean-grid .ag-pinned-right-cols-container,   .clean-grid .ag-pinned-left-header,   .clean-grid .ag-pinned-right-header{box-shadow:none!important}  .clean-grid .ag-pinned-left-cols-container,   .clean-grid .ag-pinned-left-header{border-right:none!important}  .clean-grid .ag-pinned-right-cols-container,   .clean-grid .ag-pinned-right-header{border-left:none!important}  .clean-grid .clean-grid.ag-theme-clean .ag-cell.ag-cell-first-right-pinned{border-left:none!important}  .mat-mdc-form-field-subscript-wrapper{display:none!important}  .mat-mdc-tab-body-content{overflow:hidden!important}@media print{[_nghost-%COMP%]{background:none!important}.grid-toolbar[_ngcontent-%COMP%], .grid-content[_ngcontent-%COMP%], .grid-wrapper[_ngcontent-%COMP%]{background:#fff!important;box-shadow:none!important}.grid-wrapper[_ngcontent-%COMP%]:after{display:none!important}}']
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridComponent, [{
    type: Component,
    args: [{
      selector: "app-grid",
      standalone: true,
      imports: [CommonModule, AgGridModule, AppInputComponent, GridMenuRendererComponent, IconComponent, HttpClientModule, MatMenuModule, MatIconModule, MatButtonModule],
      template: `<div class="grid-container">
  <!-- Clean Grid Toolbar -->
  <div class="grid-toolbar" *ngIf="showHeader">
    <div class="toolbar-left">
      <span class="pagination-info">Displaying {{ displayedRows }} of {{ totalRows }}</span>
      
      <!-- Filter Chips -->
      <div class="filter-chips" *ngIf="activeFilterChips.length > 0">
        <div class="filter-chip" *ngFor="let chip of activeFilterChips">
          <span class="chip-label">{{ chip.label }}:</span>
          <span class="chip-value">{{ chip.value }}</span>
          <button type="button" class="chip-remove" (click)="removeFilterChip(chip.field)" title="Remove filter" aria-label="Remove filter">×</button>
        </div>
      </div>
    </div>
    
    <div class="toolbar-center">
      <div class="search-section">
        <app-input
          [placeholder]="searchPlaceholder"
          [value]="searchText"
          [prefixIconName]="'search'"
          (valueChange)="onSearchChange($event)"
          [search]="true"
          class="search-input">
        </app-input>
      </div>
    </div>
    
    <div class="toolbar-right">
      <div class="action-icons">
        <ng-container *ngTemplateOutlet="rightTooltemplateRef"></ng-container>

        <!-- Only keep Filter icon for now -->
        <button
          class="icon-btn filter-btn"
          (click)="onFilterClick()"
          title="Filter"
          [class.active]="activeFiltersCount > 0">
          <mat-icon>tune</mat-icon>
        </button>
      </div>
    </div>
  </div>
  
  <!-- Grid Content -->
  <div class="grid-content">
    <div class="grid-wrapper">
      <!-- List View (AG-Grid) -->
      <ag-grid-angular
        *ngIf="isBrowser && viewMode === 'list'"
        [rowData]="filteredRowData"
        class="clean-grid ag-theme-clean"
        [columnDefs]="processedColumnDefs"
        [gridOptions]="gridOptions"
        [domLayout]="domLayout"
        [animateRows]="animateRows"
        [class]="class"
        [class.has-row-selection]="gridOptions.rowSelection"
        [style.width]="width"
        [style.height]="'100%'"
        (gridReady)="onGridReady($event)"
        (modelUpdated)="onModelUpdated($event)"
        (rowClicked)="onRowClicked($event)">
      </ag-grid-angular>

      <!-- Card View (Custom Template) -->
      <div class="card-grid" *ngIf="isBrowser && viewMode === 'card' && cardTemplate">
        <ng-container *ngFor="let item of filteredRowData">
          <ng-container *ngTemplateOutlet="cardTemplate; context: { $implicit: item }"></ng-container>
        </ng-container>
      </div>
      
      <!-- Loading State -->
      <div class="grid-loading" *ngIf="!isBrowser">
        <div class="loading-spinner"></div>
        <span>Loading grid...</span>
      </div>
    </div>
  </div>
</div>
`,
      styles: ['.grid-container{display:flex;flex-direction:column;height:100%;width:100%;background:var(--page-background-color);border-radius:var(--input-radius);overflow:hidden;box-shadow:var(--primary-shadow)}.grid-container ::ng-deep .mat-mdc-form-field-subscript-wrapper{display:none!important}.grid-toolbar{min-height:4em;display:flex;align-items:center;justify-content:space-between;padding:.75em 1.25em;background:var(--surface-color);border-bottom:1px solid var(--primary-border);border-radius:var(--input-radius) var(--input-radius) 0 0;box-shadow:inset 0 -1px #18b6b21a;gap:1.25em;flex-wrap:wrap}.toolbar-left{display:flex;align-items:center;gap:1em;min-width:0}.toolbar-left .pagination-info{display:inline-flex;align-items:center;padding:6px 12px;background:#18b6b214;border-radius:999px;color:var(--primary-color);font-weight:var(--secondary-font-weight);font-size:calc(var(--tertiary-font-size) - 1px);letter-spacing:.015em}.toolbar-left .filter-chips{display:flex;align-items:center;flex-wrap:wrap;gap:8px;max-width:clamp(200px,30vw,450px);padding-left:4px}.toolbar-left .filter-chip{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;background:#18b6b21f;border:1px solid rgba(24,182,178,.35);border-radius:999px;color:var(--primary-font-color);font-size:calc(var(--tertiary-font-size) - 1px);transition:all .2s ease}.toolbar-left .filter-chip .chip-label{font-weight:600;color:var(--primary-color)}.toolbar-left .filter-chip .chip-value{font-weight:var(--secondary-font-weight);max-width:130px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.toolbar-left .filter-chip:hover{background:#18b6b22e;border-color:#18b6b28c;box-shadow:0 8px 16px -12px #18b6b2d9;transform:translateY(-1px)}.toolbar-left .filter-chip .chip-remove{width:18px;height:18px;border-radius:50%;background:#ffffffd9;border:none;color:var(--primary-color);display:flex;align-items:center;justify-content:center;cursor:pointer;font-size:12px;line-height:1;padding:0;transition:all .2s ease}.toolbar-left .filter-chip .chip-remove:hover{background:var(--primary-color);color:var(--surface-color);box-shadow:0 4px 10px -6px var(--primary-color)}.toolbar-center{flex:1;display:flex;justify-content:flex-start;max-width:400px}.toolbar-center .search-section{width:100%;max-width:320px}.toolbar-center .search-section .search-input{width:100%}.toolbar-center .search-section .search-input ::ng-deep .app-input-container{box-shadow:var(--primary-shadow);border:1px solid var(--primary-border);transition:all .3s ease}.toolbar-center .search-section .search-input ::ng-deep .app-input-container:focus-within{border-color:var(--primary-color);box-shadow:0 0 0 3px #18b6b21a}.toolbar-right{flex:0 0 auto}.toolbar-right .action-icons{display:flex;align-items:center;gap:12px;background:#18b6b20f;border-radius:999px;padding:6px 10px}.icon-btn{display:inline-flex;align-items:center;justify-content:center;gap:8px;width:40px;height:40px;border:1px solid var(--primary-border);border-radius:50%;background:var(--surface-color);color:var(--primary-font-color);font-size:var(--tertiary-font-size);font-weight:var(--secondary-font-weight);cursor:pointer;transition:all .3s ease;position:relative;-webkit-backdrop-filter:blur(4px);backdrop-filter:blur(4px)}.icon-btn:hover{background:var(--secondary-background-color);border-color:var(--primary-color);transform:translateY(-1px);box-shadow:var(--primary-shadow)}.icon-btn:active{transform:translateY(0);box-shadow:0 2px 4px #0000001a}.icon-btn:focus-visible{outline:2px solid rgba(24,182,178,.4);outline-offset:2px}.icon-btn.add-btn{background:linear-gradient(135deg,var(--primary-color),var(--tertiary-color));color:var(--surface-color);border-color:transparent;box-shadow:0 10px 18px -15px #18b6b2d9}.icon-btn.add-btn:hover{border-color:transparent;box-shadow:0 16px 28px -18px #18b6b2f2}.icon-btn.settings-btn{background:#18b6b214;border-color:#18b6b240}.icon-btn.settings-btn:hover{background:#18b6b229;border-color:var(--primary-color);color:var(--primary-color)}.icon-btn.refresh-btn:hover,.icon-btn.export-btn:hover{background:var(--secondary-background-color);border-color:var(--tertiary-color);color:var(--primary-font-color)}.icon-btn.filter-btn.active,.icon-btn.filter-btn:hover{background:var(--diet-quinary-color);border-color:var(--primary-color);color:var(--primary-color)}.icon-btn.filter-btn .filter-badge{position:absolute;top:-8px;right:-8px;background:var(--diet-secondary-color);color:var(--surface-color);border-radius:50%;width:20px;height:20px;display:flex;align-items:center;justify-content:center;font-size:10px;font-weight:600;border:2px solid var(--surface-color)}.grid-content{height:calc(100% - 4em);flex:1;display:flex;flex-direction:column;overflow:hidden;background:linear-gradient(160deg,#18b6b20d,#1c324605)}.grid-wrapper{flex:1;position:relative;overflow:hidden;height:100%;background:var(--surface-color);border-radius:calc(var(--input-radius) + 2px);box-shadow:0 24px 48px -32px #0f172a8c;border:1px solid rgba(24,182,178,.08)}.grid-wrapper:after{content:"";position:absolute;inset:0;pointer-events:none;background:linear-gradient(180deg,#18b6b212,#18b6b200 40%);opacity:.6}@media (max-width: 960px){.grid-toolbar{padding:.75em;gap:.75em}.toolbar-left{flex:1 1 100%;justify-content:space-between}.toolbar-center{order:3;flex-basis:100%;margin-top:.75em}.toolbar-right{margin-left:auto}}@media (max-width: 640px){.toolbar-left{flex-direction:column;align-items:flex-start;gap:.5em}.toolbar-left .pagination-info{width:100%;justify-content:center}.toolbar-left .filter-chips{max-width:100%}.icon-btn{width:36px;height:36px}}::ng-deep .status-chip{display:inline-flex;align-items:center;justify-content:center;padding:6px 12px;border-radius:var(--button-radius);border:1px solid;font-size:var(--tertiary-font-size);font-weight:var(--secondary-font-weight);line-height:1.4;white-space:nowrap;min-width:80px;text-transform:capitalize}::ng-deep .status-success{background:var(--status-success-bg);color:var(--status-success-color);border-color:var(--status-success-border)}::ng-deep .status-warning{background:var(--status-warning-bg);color:var(--status-warning-color);border-color:var(--status-warning-border)}::ng-deep .status-danger{background:var(--status-danger-bg);color:var(--status-danger-color);border-color:var(--status-danger-border)}::ng-deep .status-info{background:var(--status-info-bg);color:var(--status-info-color);border-color:var(--status-info-border)}::ng-deep .status-neutral{background:var(--status-neutral-bg);color:var(--status-neutral-color);border-color:var(--status-neutral-border)}::ng-deep .status-available{background:var(--status-available-bg);color:var(--status-available-color);border-color:var(--status-available-border)}::ng-deep .status-unavailable{background:var(--status-unavailable-bg);color:var(--status-unavailable-color);border-color:var(--status-unavailable-border)}::ng-deep .status-busy{background:var(--status-busy-bg);color:var(--status-busy-color);border-color:var(--status-busy-border)}::ng-deep .status-offline{background:var(--status-offline-bg);color:var(--status-offline-color);border-color:var(--status-offline-border)}::ng-deep .actions-header-cell{padding:0!important}::ng-deep .actions-cell{padding:0!important;display:flex;align-items:center;justify-content:center;position:relative}::ng-deep .ag-row.ag-row-hover .actions-cell:after,::ng-deep .ag-row.ag-row-selected .actions-cell:after{content:"";position:absolute;right:0;top:0;bottom:0;width:4px;background:var(--primary-color)}.grid-loading{display:flex;flex-direction:column;align-items:center;justify-content:center;height:300px;color:var(--secondary-font-color);gap:16px}.grid-loading .loading-spinner{width:32px;height:32px;border:3px solid var(--primary-border);border-top:3px solid var(--primary-color);border-radius:50%;animation:spin 1s linear infinite}@keyframes spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.grid-empty{display:flex;flex-direction:column;align-items:center;justify-content:center;height:400px;padding:40px;text-align:center;color:var(--secondary-font-color)}.grid-empty .empty-icon{margin-bottom:16px;opacity:.6}.grid-empty h4{margin:0 0 8px;font-size:var(--primary-font-size);font-weight:var(--primary-font-weight);color:var(--primary-font-color)}.grid-empty p{margin:0 0 24px;font-size:var(--tertiary-font-size);color:var(--secondary-font-color);max-width:300px;line-height:1.5}.grid-empty .empty-action-btn{display:flex;align-items:center;gap:8px;padding:12px 20px;border:1px solid var(--primary-color);border-radius:var(--button-radius);background:var(--primary-color);color:var(--surface-color);font-size:var(--tertiary-font-size);font-weight:var(--secondary-font-weight);cursor:pointer;transition:all .3s ease}.grid-empty .empty-action-btn:hover{background:var(--primary-color);transform:translateY(-1px);box-shadow:var(--primary-shadow)}::ng-deep .ag-row-focus{background:var(--secondary-background-color)!important;border-left:3px solid var(--primary-color)!important}::ng-deep .clean-grid.ag-theme-clean{--ag-background-color: var(--surface-color);--ag-foreground-color: var(--primary-font-color);--ag-border-color: var(--primary-border);--ag-header-background-color: var(--page-background-color);--ag-header-foreground-color: var(--primary-font-color);--ag-odd-row-background-color: var(--surface-color);--ag-row-hover-color: var(--secondary-background-color);--ag-selected-row-background-color: rgba(24, 182, 178, .1);--ag-range-selection-background-color: rgba(24, 182, 178, .2);--ag-header-height: 56px;--ag-row-height: 52px;--ag-grid-size: 4px;--ag-icon-size: 16px;--ag-font-size: var(--tertiary-font-size);--ag-font-family: inherit;border:none!important;border-radius:0 0 var(--input-radius) var(--input-radius);box-shadow:none!important}::ng-deep .clean-grid .ag-header{background:linear-gradient(180deg,var(--page-background-color) 0%,var(--secondary-background-color) 100%);border-bottom:2px solid var(--primary-border);font-weight:var(--primary-font-weight)}::ng-deep .clean-grid .ag-header .ag-header-cell{border-right:1px solid var(--primary-border);padding:0 16px}::ng-deep .clean-grid .ag-header .ag-header-cell .ag-header-cell-label{font-weight:var(--primary-font-weight);color:var(--primary-font-color);font-size:var(--tertiary-font-size)}::ng-deep .clean-grid .ag-header .ag-header-cell:hover{background:#18b6b20d}::ng-deep .clean-grid .ag-header .ag-header-cell-resize{background:var(--primary-color);width:2px;opacity:.6}::ng-deep .clean-grid .ag-row{border-bottom:1px solid var(--primary-border);transition:all .2s ease}::ng-deep .clean-grid .ag-row:hover{background:var(--page-background-color)!important;box-shadow:inset 4px 0 0 var(--primary-color)}::ng-deep .clean-grid .ag-row.ag-row-selected{background:#18b6b214!important;border-color:var(--primary-color)}::ng-deep .clean-grid .ag-row:last-child{border-bottom:none}::ng-deep .clean-grid.has-row-selection .ag-row{cursor:pointer}::ng-deep .clean-grid.has-row-selection .ag-row.ag-row-selected{background:#18b6b226!important;border-left:4px solid var(--primary-color)!important;box-shadow:inset 0 0 0 1px #18b6b233,0 2px 8px #18b6b21a!important}::ng-deep .clean-grid.has-row-selection .ag-row.ag-row-selected .ag-cell{background-color:transparent!important;font-weight:var(--secondary-font-weight)}::ng-deep .clean-grid.has-row-selection .ag-row.ag-row-selected:hover{background:#18b6b22e!important;box-shadow:inset 0 0 0 1px #18b6b24d,0 4px 12px #18b6b226!important}::ng-deep .clean-grid.has-row-selection .ag-row.ag-row-focus.ag-row-selected{background:#18b6b226!important;border-left:4px solid var(--primary-color)!important}::ng-deep .clean-grid .ag-cell{display:flex!important;align-items:center!important;padding:0 16px;border-right:1px solid transparent;color:var(--primary-font-color);font-size:var(--tertiary-font-size);line-height:1.4}::ng-deep .clean-grid .ag-cell:focus{border:2px solid var(--primary-color)!important;outline:none;border-radius:4px}::ng-deep .clean-grid .ag-cell .ag-cell-value{display:flex!important;align-items:center!important;width:100%}::ng-deep .clean-grid .ag-center-cols-viewport{background:var(--surface-color)}::ng-deep .clean-grid .ag-root-wrapper,::ng-deep .clean-grid .ag-root-wrapper.ag-layout-auto-height.ag-ltr,::ng-deep .clean-grid .ag-root-wrapper-body{height:100%;border:none!important;box-shadow:none!important}::ng-deep .clean-grid .ag-body-viewport{overflow-y:scroll}::ng-deep .clean-grid .ag-body-viewport::-webkit-scrollbar{width:8px;height:8px}::ng-deep .clean-grid .ag-body-viewport::-webkit-scrollbar-track{background:var(--secondary-background-color);border-radius:4px}::ng-deep .clean-grid .ag-body-viewport::-webkit-scrollbar-thumb{background:var(--tertiary-color);border-radius:4px;transition:background .3s ease}::ng-deep .clean-grid .ag-body-viewport::-webkit-scrollbar-thumb:hover{background:var(--primary-color)}::ng-deep .clean-grid .ag-overlay-loading-wrapper{background:#ffffffe6;-webkit-backdrop-filter:blur(4px);backdrop-filter:blur(4px)}::ng-deep .clean-grid .ag-overlay-no-rows-wrapper{background:transparent}::ng-deep .clean-grid .ag-header-icon{color:var(--primary-color)}::ng-deep .clean-grid .ag-header-cell-filtered{background:#18b6b21a}::ng-deep .clean-grid .ag-header-cell-filtered .ag-header-cell-label{color:var(--primary-color);font-weight:600}::ng-deep .clean-grid .ag-selection-checkbox .ag-input-wrapper{background:var(--surface-color);border:2px solid var(--primary-border);border-radius:4px}::ng-deep .clean-grid .ag-selection-checkbox .ag-input-wrapper:after{color:var(--primary-color)}::ng-deep .clean-grid .ag-selection-checkbox input:checked+.ag-input-wrapper{background:var(--primary-color);border-color:var(--primary-color)}::ng-deep .clean-grid .ag-pinned-left-cols-container,::ng-deep .clean-grid .ag-pinned-right-cols-container,::ng-deep .clean-grid .ag-pinned-left-header,::ng-deep .clean-grid .ag-pinned-right-header{box-shadow:none!important}::ng-deep .clean-grid .ag-pinned-left-cols-container,::ng-deep .clean-grid .ag-pinned-left-header{border-right:none!important}::ng-deep .clean-grid .ag-pinned-right-cols-container,::ng-deep .clean-grid .ag-pinned-right-header{border-left:none!important}::ng-deep .clean-grid .clean-grid.ag-theme-clean .ag-cell.ag-cell-first-right-pinned{border-left:none!important}::ng-deep .mat-mdc-form-field-subscript-wrapper{display:none!important}::ng-deep .mat-mdc-tab-body-content{overflow:hidden!important}@media print{:host{background:none!important}.grid-toolbar,.grid-content,.grid-wrapper{background:#fff!important;box-shadow:none!important}.grid-wrapper:after{display:none!important}}\n']
    }]
  }], () => [{
    type: DialogboxService
  }, {
    type: Object,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }, {
    type: ApiConfigService
  }, {
    type: HttpClient
  }], {
    rowData: [{
      type: Input
    }],
    columnDefs: [{
      type: Input
    }],
    gridOptions: [{
      type: Input
    }],
    domLayout: [{
      type: Input
    }],
    animateRows: [{
      type: Input
    }],
    class: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    showHeader: [{
      type: Input
    }],
    searchPlaceholder: [{
      type: Input
    }],
    rightTooltemplateRef: [{
      type: Input
    }],
    cardTemplate: [{
      type: Input
    }],
    defaultViewMode: [{
      type: Input
    }],
    showAddButton: [{
      type: Input
    }],
    apiConfig: [{
      type: Input
    }],
    searchChange: [{
      type: Output
    }],
    rowClicked: [{
      type: Output
    }],
    addClick: [{
      type: Output
    }]
  });
})();
var NotesDialogComponent = class _NotesDialogComponent {
  constructor() {
    this.notes = "";
    this.dialogRef = inject(MatDialogRef);
    this.data = inject(MAT_DIALOG_DATA);
    this.notes = this.data.defaultValue || "";
  }
  onCancel() {
    this.dialogRef.close();
  }
  onSave() {
    if (this.notes.trim()) {
      this.dialogRef.close(this.notes.trim());
    }
  }
  canSave() {
    return this.notes.trim().length > 0;
  }
  static {
    this.ɵfac = function NotesDialogComponent_Factory(t) {
      return new (t || _NotesDialogComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _NotesDialogComponent,
      selectors: [["app-notes-dialog"]],
      standalone: true,
      features: [ɵɵStandaloneFeature],
      decls: 20,
      vars: 5,
      consts: [[1, "notes-dialog"], [1, "dialog-header"], [1, "dialog-title"], ["mat-icon-button", "", 1, "close-button", 3, "click"], [1, "dialog-content"], [1, "dialog-message"], ["appearance", "outline", 1, "notes-field"], ["matInput", "", "rows", "4", 1, "notes-textarea", 3, "ngModelChange", "ngModel", "placeholder"], [1, "dialog-actions"], ["mat-button", "", 3, "click"], ["mat-raised-button", "", "color", "primary", 3, "click", "disabled"]],
      template: function NotesDialogComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "div", 0)(1, "div", 1)(2, "h2", 2);
          ɵɵtext(3);
          ɵɵelementEnd();
          ɵɵelementStart(4, "button", 3);
          ɵɵlistener("click", function NotesDialogComponent_Template_button_click_4_listener() {
            return ctx.onCancel();
          });
          ɵɵelementStart(5, "mat-icon");
          ɵɵtext(6, "close");
          ɵɵelementEnd()()();
          ɵɵelementStart(7, "div", 4)(8, "p", 5);
          ɵɵtext(9);
          ɵɵelementEnd();
          ɵɵelementStart(10, "mat-form-field", 6)(11, "mat-label");
          ɵɵtext(12, "Notes");
          ɵɵelementEnd();
          ɵɵelementStart(13, "textarea", 7);
          ɵɵtwoWayListener("ngModelChange", function NotesDialogComponent_Template_textarea_ngModelChange_13_listener($event) {
            ɵɵtwoWayBindingSet(ctx.notes, $event) || (ctx.notes = $event);
            return $event;
          });
          ɵɵtext(14, "      ");
          ɵɵelementEnd()()();
          ɵɵelementStart(15, "div", 8)(16, "button", 9);
          ɵɵlistener("click", function NotesDialogComponent_Template_button_click_16_listener() {
            return ctx.onCancel();
          });
          ɵɵtext(17, " Cancel ");
          ɵɵelementEnd();
          ɵɵelementStart(18, "button", 10);
          ɵɵlistener("click", function NotesDialogComponent_Template_button_click_18_listener() {
            return ctx.onSave();
          });
          ɵɵtext(19, " Save Notes ");
          ɵɵelementEnd()()();
        }
        if (rf & 2) {
          ɵɵadvance(3);
          ɵɵtextInterpolate(ctx.data.title);
          ɵɵadvance(6);
          ɵɵtextInterpolate(ctx.data.message);
          ɵɵadvance(4);
          ɵɵtwoWayProperty("ngModel", ctx.notes);
          ɵɵproperty("placeholder", ctx.data.placeholder || "Enter your notes here...");
          ɵɵadvance(5);
          ɵɵproperty("disabled", !ctx.canSave());
        }
      },
      dependencies: [CommonModule, FormsModule, DefaultValueAccessor, NgControlStatus, NgModel, MatDialogModule, MatButtonModule, MatButton, MatIconButton, MatFormFieldModule, MatFormField, MatLabel, MatInputModule, MatInput, MatIconModule, MatIcon],
      styles: [".notes-dialog[_ngcontent-%COMP%]{padding:0;min-width:400px}.notes-dialog[_ngcontent-%COMP%]   .dialog-header[_ngcontent-%COMP%]{display:flex;justify-content:space-between;align-items:center;padding:1.5rem 1.5rem 1rem;border-bottom:1px solid #e2e8f0}.notes-dialog[_ngcontent-%COMP%]   .dialog-header[_ngcontent-%COMP%]   .dialog-title[_ngcontent-%COMP%]{margin:0;font-size:1.25rem;font-weight:600;color:#1e293b}.notes-dialog[_ngcontent-%COMP%]   .dialog-header[_ngcontent-%COMP%]   .close-button[_ngcontent-%COMP%]{color:#64748b}.notes-dialog[_ngcontent-%COMP%]   .dialog-header[_ngcontent-%COMP%]   .close-button[_ngcontent-%COMP%]:hover{background-color:#f1f5f9}.notes-dialog[_ngcontent-%COMP%]   .dialog-content[_ngcontent-%COMP%]{padding:1.5rem}.notes-dialog[_ngcontent-%COMP%]   .dialog-content[_ngcontent-%COMP%]   .dialog-message[_ngcontent-%COMP%]{margin:0 0 1rem;color:#475569;font-size:.875rem;line-height:1.5}.notes-dialog[_ngcontent-%COMP%]   .dialog-content[_ngcontent-%COMP%]   .notes-field[_ngcontent-%COMP%]{width:100%}.notes-dialog[_ngcontent-%COMP%]   .dialog-content[_ngcontent-%COMP%]   .notes-field[_ngcontent-%COMP%]   .notes-textarea[_ngcontent-%COMP%]{font-family:inherit;line-height:1.5;resize:vertical;min-height:100px}.notes-dialog[_ngcontent-%COMP%]   .dialog-actions[_ngcontent-%COMP%]{display:flex;justify-content:flex-end;gap:.75rem;padding:1rem 1.5rem 1.5rem;border-top:1px solid #e2e8f0}.notes-dialog[_ngcontent-%COMP%]   .dialog-actions[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{min-width:80px}"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NotesDialogComponent, [{
    type: Component,
    args: [{
      selector: "app-notes-dialog",
      standalone: true,
      imports: [CommonModule, FormsModule, MatDialogModule, MatButtonModule, MatFormFieldModule, MatInputModule, MatIconModule],
      template: `<div class="notes-dialog">
  <div class="dialog-header">
    <h2 class="dialog-title">{{ data.title }}</h2>
    <button mat-icon-button class="close-button" (click)="onCancel()">
      <mat-icon>close</mat-icon>
    </button>
  </div>
  
  <div class="dialog-content">
    <p class="dialog-message">{{ data.message }}</p>
    
    <mat-form-field class="notes-field" appearance="outline">
      <mat-label>Notes</mat-label>
      <textarea 
        matInput 
        [(ngModel)]="notes" 
        [placeholder]="data.placeholder || 'Enter your notes here...'"
        rows="4"
        class="notes-textarea">
      </textarea>
    </mat-form-field>
  </div>
  
  <div class="dialog-actions">
    <button mat-button (click)="onCancel()">
      Cancel
    </button>
    <button 
      mat-raised-button 
      color="primary" 
      [disabled]="!canSave()"
      (click)="onSave()">
      Save Notes
    </button>
  </div>
</div>

`,
      styles: [".notes-dialog{padding:0;min-width:400px}.notes-dialog .dialog-header{display:flex;justify-content:space-between;align-items:center;padding:1.5rem 1.5rem 1rem;border-bottom:1px solid #e2e8f0}.notes-dialog .dialog-header .dialog-title{margin:0;font-size:1.25rem;font-weight:600;color:#1e293b}.notes-dialog .dialog-header .close-button{color:#64748b}.notes-dialog .dialog-header .close-button:hover{background-color:#f1f5f9}.notes-dialog .dialog-content{padding:1.5rem}.notes-dialog .dialog-content .dialog-message{margin:0 0 1rem;color:#475569;font-size:.875rem;line-height:1.5}.notes-dialog .dialog-content .notes-field{width:100%}.notes-dialog .dialog-content .notes-field .notes-textarea{font-family:inherit;line-height:1.5;resize:vertical;min-height:100px}.notes-dialog .dialog-actions{display:flex;justify-content:flex-end;gap:.75rem;padding:1rem 1.5rem 1.5rem;border-top:1px solid #e2e8f0}.notes-dialog .dialog-actions button{min-width:80px}\n"]
    }]
  }], () => [], null);
})();
var ConfirmationDialogComponent = class _ConfirmationDialogComponent {
  constructor() {
    this.data = inject(DIALOG_DATA_TOKEN);
    this.destroy$ = new Subject();
  }
  ngOnInit() {
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  get displayMessage() {
    return this.data?.message || "Are you sure?";
  }
  get displayTitle() {
    return this.data?.title || "Confirm";
  }
  static {
    this.ɵfac = function ConfirmationDialogComponent_Factory(t) {
      return new (t || _ConfirmationDialogComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _ConfirmationDialogComponent,
      selectors: [["app-confirmation-dialog"]],
      standalone: true,
      features: [ɵɵStandaloneFeature],
      decls: 5,
      vars: 1,
      consts: [[1, "confirmation-dialog"], [1, "confirmation-content"], [1, "message-container"], [1, "confirmation-message"]],
      template: function ConfirmationDialogComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "div", 0)(1, "div", 1)(2, "div", 2)(3, "p", 3);
          ɵɵtext(4);
          ɵɵelementEnd()()()();
        }
        if (rf & 2) {
          ɵɵadvance(4);
          ɵɵtextInterpolate(ctx.displayMessage);
        }
      },
      dependencies: [CommonModule],
      styles: [".confirmation-dialog[_ngcontent-%COMP%]{padding:0}.confirmation-dialog[_ngcontent-%COMP%]   .confirmation-content[_ngcontent-%COMP%]{display:flex;flex-direction:column}.confirmation-dialog[_ngcontent-%COMP%]   .confirmation-content[_ngcontent-%COMP%]   .message-container[_ngcontent-%COMP%]{width:100%}.confirmation-dialog[_ngcontent-%COMP%]   .confirmation-content[_ngcontent-%COMP%]   .message-container[_ngcontent-%COMP%]   .confirmation-message[_ngcontent-%COMP%]{margin:0;font-size:16px;line-height:1.6;color:#1f2937;word-wrap:break-word;text-align:left}"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ConfirmationDialogComponent, [{
    type: Component,
    args: [{
      selector: "app-confirmation-dialog",
      standalone: true,
      imports: [CommonModule],
      template: '<div class="confirmation-dialog">\n  <div class="confirmation-content">\n    <div class="message-container">\n      <p class="confirmation-message">{{ displayMessage }}</p>\n    </div>\n  </div>\n</div>\n\n',
      styles: [".confirmation-dialog{padding:0}.confirmation-dialog .confirmation-content{display:flex;flex-direction:column}.confirmation-dialog .confirmation-content .message-container{width:100%}.confirmation-dialog .confirmation-content .message-container .confirmation-message{margin:0;font-size:16px;line-height:1.6;color:#1f2937;word-wrap:break-word;text-align:left}\n"]
    }]
  }], () => [], null);
})();
var StatusCellRendererComponent = class _StatusCellRendererComponent {
  constructor() {
    this.statusClass = "status-chip status-neutral";
    this.displayValue = "";
  }
  agInit(params) {
    const value = params.value ?? "";
    const field = params.statusField || params.colDef?.field;
    const mapping = params.statusMapping || this.getDefaultMapping(field);
    this.displayValue = value ? value.toString() : "";
    const valueStr = value ? value.toString().toLowerCase() : "";
    this.statusClass = `status-chip ${mapping[valueStr] || "status-neutral"}`;
  }
  getDefaultMapping(field) {
    if (field?.toLowerCase().includes("availability") || field?.toLowerCase().includes("available")) {
      return {
        "available": "status-available",
        "unavailable": "status-unavailable",
        "busy": "status-busy",
        "offline": "status-offline",
        "online": "status-available",
        "active": "status-available",
        "inactive": "status-offline"
      };
    }
    return {
      "active": "status-success",
      "inactive": "status-neutral",
      "pending": "status-warning",
      "approved": "status-success",
      "rejected": "status-danger",
      "cancelled": "status-danger",
      "completed": "status-success",
      "in progress": "status-info",
      "draft": "status-neutral",
      "published": "status-success",
      "archived": "status-neutral",
      "enabled": "status-success",
      "disabled": "status-neutral",
      "online": "status-success",
      "offline": "status-neutral",
      "available": "status-available",
      "unavailable": "status-unavailable",
      "busy": "status-busy"
    };
  }
  static {
    this.ɵfac = function StatusCellRendererComponent_Factory(t) {
      return new (t || _StatusCellRendererComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _StatusCellRendererComponent,
      selectors: [["app-status-cell-renderer"]],
      standalone: true,
      features: [ɵɵStandaloneFeature],
      decls: 2,
      vars: 3,
      template: function StatusCellRendererComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "span");
          ɵɵtext(1);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵclassMap(ctx.statusClass);
          ɵɵadvance();
          ɵɵtextInterpolate1(" ", ctx.displayValue, " ");
        }
      },
      dependencies: [CommonModule],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StatusCellRendererComponent, [{
    type: Component,
    args: [{
      selector: "app-status-cell-renderer",
      template: `
    <span [class]="statusClass">
      {{ displayValue }}
    </span>
  `,
      standalone: true,
      imports: [CommonModule]
    }]
  }], null, null);
})();
var ChipCellRendererComponent = class _ChipCellRendererComponent {
  constructor() {
    this.params = {};
    this.status = "";
    this.color = "";
    this.chipColors = CHIP_COLORS;
  }
  agInit(params) {
    this.params = params;
    this.status = params.value;
    this.color = this.chipColors[this.status] ?? "gray";
  }
  static {
    this.ɵfac = function ChipCellRendererComponent_Factory(t) {
      return new (t || _ChipCellRendererComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _ChipCellRendererComponent,
      selectors: [["app-chip-cell-renderer"]],
      standalone: true,
      features: [ɵɵStandaloneFeature],
      decls: 2,
      vars: 3,
      consts: [[1, "status-chip"]],
      template: function ChipCellRendererComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "div", 0);
          ɵɵtext(1);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵstyleProp("background-color", ctx.color);
          ɵɵadvance();
          ɵɵtextInterpolate(ctx.status);
        }
      },
      dependencies: [CommonModule],
      styles: [".status-chip[_ngcontent-%COMP%]{font-weight:500;font-size:1em;justify-content:center;border-radius:4em;padding:.5em 1em;color:#fff}"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChipCellRendererComponent, [{
    type: Component,
    args: [{
      selector: "app-chip-cell-renderer",
      standalone: true,
      imports: [CommonModule],
      template: '<div [style.background-color]="color" class="status-chip">{{ status }}</div> ',
      styles: [".status-chip{font-weight:500;font-size:1em;justify-content:center;border-radius:4em;padding:.5em 1em;color:#fff}\n"]
    }]
  }], null, null);
})();
var CheckboxComponent = class _CheckboxComponent {
  constructor() {
    this.label = "";
    this.disabled = false;
    this.required = false;
    this.labelTemplateRef = null;
    this.value = false;
    this.onChange = (_) => {
    };
    this.onTouched = () => {
    };
  }
  writeValue(value) {
    this.value = value;
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  onCheckboxChange(event) {
    this.value = event.checked;
    this.onChange(this.value);
    this.onTouched();
  }
  static {
    this.ɵfac = function CheckboxComponent_Factory(t) {
      return new (t || _CheckboxComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _CheckboxComponent,
      selectors: [["app-checkbox"]],
      inputs: {
        label: "label",
        disabled: "disabled",
        required: "required",
        labelTemplateRef: "labelTemplateRef"
      },
      standalone: true,
      features: [ɵɵProvidersFeature([{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => _CheckboxComponent),
        multi: true
      }]), ɵɵStandaloneFeature],
      decls: 3,
      vars: 4,
      consts: [[3, "change", "checked", "disabled", "required"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"]],
      template: function CheckboxComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "mat-checkbox", 0);
          ɵɵlistener("change", function CheckboxComponent_Template_mat_checkbox_change_0_listener($event) {
            return ctx.onCheckboxChange($event);
          });
          ɵɵtemplate(1, CheckboxComponent_Conditional_1_Template, 1, 5, "ng-container")(2, CheckboxComponent_Conditional_2_Template, 1, 1);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵproperty("checked", ctx.value)("disabled", ctx.disabled)("required", ctx.required);
          ɵɵadvance();
          ɵɵconditional(1, ctx.labelTemplateRef ? 1 : 2);
        }
      },
      dependencies: [CommonModule, NgTemplateOutlet, MatCheckboxModule, MatCheckbox],
      styles: ["[_nghost-%COMP%]{display:inline-flex;align-items:center}mat-checkbox[_ngcontent-%COMP%]{font-size:15px}"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckboxComponent, [{
    type: Component,
    args: [{
      selector: "app-checkbox",
      standalone: true,
      imports: [CommonModule, MatCheckboxModule],
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => CheckboxComponent),
        multi: true
      }],
      template: '<mat-checkbox\n  [checked]="value"\n  [disabled]="disabled"\n  [required]="required"\n  (change)="onCheckboxChange($event)">\n  @if (labelTemplateRef) {\n    <ng-container *ngTemplateOutlet="labelTemplateRef; context: { $implicit: label, label: label }"></ng-container>\n  } @else {\n    {{ label }}\n  }\n</mat-checkbox>',
      styles: [":host{display:inline-flex;align-items:center}mat-checkbox{font-size:15px}\n"]
    }]
  }], null, {
    label: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    required: [{
      type: Input
    }],
    labelTemplateRef: [{
      type: Input
    }]
  });
})();
var CalendarComponent = class _CalendarComponent {
  constructor() {
    this.events = [];
    this.selectedDate = /* @__PURE__ */ new Date();
    this.view = "month";
    this.viewDate = /* @__PURE__ */ new Date();
    this.showNavigation = true;
    this.showToday = true;
    this.allowDateSelection = true;
    this.highlightToday = true;
    this.showEventIndicators = true;
    this.locale = "en";
    this.dateSelected = new EventEmitter();
    this.eventClicked = new EventEmitter();
    this.monthChanged = new EventEmitter();
    this.viewChanged = new EventEmitter();
    this.calendarEvents = [];
    this.calendar = [];
    this.weekDays = ["S", "M", "T", "W", "T", "F", "S"];
    this.currentMonth = (/* @__PURE__ */ new Date()).getMonth();
    this.currentYear = (/* @__PURE__ */ new Date()).getFullYear();
  }
  ngOnInit() {
    this.convertEvents();
    this.generateCalendar();
  }
  ngOnChanges() {
    this.convertEvents();
    this.generateCalendar();
  }
  generateCalendar() {
    this.calendar = [];
    const firstDay = new Date(this.currentYear, this.currentMonth, 1);
    const lastDay = new Date(this.currentYear, this.currentMonth + 1, 0);
    const startDate = new Date(firstDay);
    const dayOfWeek = firstDay.getDay();
    startDate.setDate(startDate.getDate() - dayOfWeek);
    const weeks = Math.ceil((lastDay.getDate() + dayOfWeek) / 7);
    for (let week = 0; week < weeks; week++) {
      const weekDates = [];
      for (let day = 0; day < 7; day++) {
        const date = new Date(startDate);
        date.setDate(startDate.getDate() + week * 7 + day);
        weekDates.push(date);
      }
      this.calendar.push(weekDates);
    }
  }
  convertEvents() {
    this.calendarEvents = this.events.map((event) => ({
      id: event.id,
      title: event.title,
      start: new Date(event.start),
      end: event.end ? new Date(event.end) : new Date(event.start),
      description: event.description,
      color: event.color || this.getDefaultColor(event.type),
      allDay: event.allDay || false,
      meta: {
        type: event.type,
        originalEvent: event
      }
    }));
  }
  getDefaultColor(type) {
    switch (type) {
      case "appointment":
        return {
          primary: "#f44336",
          secondary: "#ffebee"
        };
      case "available":
        return {
          primary: "#4caf50",
          secondary: "#e8f5e8"
        };
      case "break":
        return {
          primary: "#ff9800",
          secondary: "#fff3e0"
        };
      case "leave":
        return {
          primary: "#f44336",
          secondary: "#ffebee"
        };
      default:
        return {
          primary: "#757575",
          secondary: "#f5f5f5"
        };
    }
  }
  onDateSelected(event) {
    this.selectedDate = event.date;
    this.dateSelected.emit(event.date);
  }
  onEventClicked(event) {
    this.eventClicked.emit(event.event.meta.originalEvent);
  }
  onViewChange(view) {
    this.view = view;
    this.viewChanged.emit(view);
  }
  onViewDateChange(date) {
    this.viewDate = date;
    this.currentMonth = date.getMonth();
    this.currentYear = date.getFullYear();
    this.generateCalendar();
    this.monthChanged.emit({
      year: date.getFullYear(),
      month: date.getMonth()
    });
  }
  onTodayClick() {
    this.viewDate = /* @__PURE__ */ new Date();
    this.selectedDate = /* @__PURE__ */ new Date();
    this.currentMonth = (/* @__PURE__ */ new Date()).getMonth();
    this.currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    this.generateCalendar();
  }
  previousMonth() {
    const newDate = new Date(this.currentYear, this.currentMonth - 1, 1);
    this.onViewDateChange(newDate);
  }
  nextMonth() {
    const newDate = new Date(this.currentYear, this.currentMonth + 1, 1);
    this.onViewDateChange(newDate);
  }
  isToday(date) {
    const today = /* @__PURE__ */ new Date();
    return date.getDate() === today.getDate() && date.getMonth() === today.getMonth() && date.getFullYear() === today.getFullYear();
  }
  isSelected(date) {
    return date.getDate() === this.selectedDate.getDate() && date.getMonth() === this.selectedDate.getMonth() && date.getFullYear() === this.selectedDate.getFullYear();
  }
  isCurrentMonth(date) {
    return date.getMonth() === this.currentMonth;
  }
  getEventsForDate(date) {
    return this.events.filter((event) => {
      const eventDate = new Date(event.start);
      return eventDate.getDate() === date.getDate() && eventDate.getMonth() === date.getMonth() && eventDate.getFullYear() === date.getFullYear();
    });
  }
  getEventColor(event) {
    if (event.color) return event.color;
    switch (event.type) {
      case "appointment":
        return {
          primary: "#f44336",
          secondary: "#ffebee"
        };
      case "available":
        return {
          primary: "#4caf50",
          secondary: "#e8f5e8"
        };
      case "break":
        return {
          primary: "#ff9800",
          secondary: "#fff3e0"
        };
      case "leave":
        return {
          primary: "#f44336",
          secondary: "#ffebee"
        };
      default:
        return {
          primary: "#757575",
          secondary: "#f5f5f5"
        };
    }
  }
  formatSelectedDate() {
    const options = {
      weekday: "short",
      month: "short",
      day: "numeric",
      year: "numeric"
    };
    return this.selectedDate.toLocaleDateString("en-US", options);
  }
  formatEventTime(event) {
    if (event.allDay) return "All-day";
    const startTime = new Date(event.start);
    const endTime = event.end ? new Date(event.end) : startTime;
    const startStr = startTime.toLocaleTimeString("en-US", {
      hour: "numeric",
      minute: "2-digit",
      hour12: true
    });
    if (event.end) {
      const endStr = endTime.toLocaleTimeString("en-US", {
        hour: "numeric",
        minute: "2-digit",
        hour12: true
      });
      return `${startStr} - ${endStr}`;
    }
    return startStr;
  }
  getMonthYearString() {
    return format(this.viewDate, "MMMM yyyy");
  }
  static {
    this.ɵfac = function CalendarComponent_Factory(t) {
      return new (t || _CalendarComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _CalendarComponent,
      selectors: [["app-calendar"]],
      inputs: {
        events: "events",
        selectedDate: "selectedDate",
        view: "view",
        viewDate: "viewDate",
        showNavigation: "showNavigation",
        showToday: "showToday",
        allowDateSelection: "allowDateSelection",
        highlightToday: "highlightToday",
        showEventIndicators: "showEventIndicators",
        locale: "locale"
      },
      outputs: {
        dateSelected: "dateSelected",
        eventClicked: "eventClicked",
        monthChanged: "monthChanged",
        viewChanged: "viewChanged"
      },
      standalone: true,
      features: [ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
      decls: 21,
      vars: 13,
      consts: [[1, "calendar-container"], [1, "calendar-header"], [1, "header-content"], [1, "month-year"], [1, "month-year-text"], [1, "navigation-controls"], ["type", "button", "appearance", "icon", 1, "nav-btn", 3, "btnClick", "text", "fontIcon"], ["type", "button", "appearance", "basic", 1, "today-btn", 3, "btnClick", "text"], ["class", "calendar-legend", 4, "ngIf"], [1, "calendar-events-container"], [1, "calendar-grid"], [1, "week-header"], ["class", "week-day", 4, "ngFor", "ngForOf"], [1, "calendar-body"], ["class", "calendar-week", 4, "ngFor", "ngForOf"], ["class", "events-panel", 4, "ngIf"], ["class", "no-events-panel", 4, "ngIf"], ["class", "events-list-bottom", 4, "ngIf"], ["class", "no-events-bottom", 4, "ngIf"], [1, "calendar-legend"], [1, "legend-item"], [1, "legend-dot", "available"], [1, "legend-text"], [1, "legend-dot", "appointment"], [1, "week-day"], [1, "calendar-week"], ["class", "calendar-day", 3, "today", "selected", "other-month", "clickable", "click", 4, "ngFor", "ngForOf"], [1, "calendar-day", 3, "click"], [1, "day-number"], ["class", "event-indicators", 4, "ngIf"], [1, "event-indicators"], ["class", "event-dot", 3, "class", "background-color", 4, "ngFor", "ngForOf"], [1, "event-dot"], [1, "events-panel"], [1, "date-header"], [1, "date-title"], [1, "events-panel-wrapper"], ["class", "event-item", 3, "border-left-color", "click", 4, "ngFor", "ngForOf"], [1, "event-item", 3, "click"], [1, "event-content"], [1, "event-title"], ["class", "event-description", 4, "ngIf"], [1, "event-time"], [4, "ngIf"], [1, "event-description"], [1, "no-events-panel"], [1, "events-list-bottom"], [1, "no-events-bottom"]],
      template: function CalendarComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "div", 0)(1, "div", 1)(2, "div", 2)(3, "div", 3)(4, "h2", 4);
          ɵɵtext(5);
          ɵɵelementEnd()();
          ɵɵelementStart(6, "div", 5)(7, "app-button", 6);
          ɵɵlistener("btnClick", function CalendarComponent_Template_app_button_btnClick_7_listener() {
            return ctx.previousMonth();
          });
          ɵɵelementEnd();
          ɵɵelementStart(8, "app-button", 7);
          ɵɵlistener("btnClick", function CalendarComponent_Template_app_button_btnClick_8_listener() {
            return ctx.onTodayClick();
          });
          ɵɵelementEnd();
          ɵɵelementStart(9, "app-button", 6);
          ɵɵlistener("btnClick", function CalendarComponent_Template_app_button_btnClick_9_listener() {
            return ctx.nextMonth();
          });
          ɵɵelementEnd()()()();
          ɵɵtemplate(10, CalendarComponent_div_10_Template, 9, 0, "div", 8);
          ɵɵelementStart(11, "div", 9)(12, "div", 10)(13, "div", 11);
          ɵɵtemplate(14, CalendarComponent_div_14_Template, 2, 1, "div", 12);
          ɵɵelementEnd();
          ɵɵelementStart(15, "div", 13);
          ɵɵtemplate(16, CalendarComponent_div_16_Template, 2, 1, "div", 14);
          ɵɵelementEnd()();
          ɵɵtemplate(17, CalendarComponent_div_17_Template, 6, 2, "div", 15)(18, CalendarComponent_div_18_Template, 3, 1, "div", 16);
          ɵɵelementEnd();
          ɵɵtemplate(19, CalendarComponent_div_19_Template, 5, 2, "div", 17)(20, CalendarComponent_div_20_Template, 3, 1, "div", 18);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵadvance(5);
          ɵɵtextInterpolate(ctx.getMonthYearString());
          ɵɵadvance(2);
          ɵɵproperty("text", "")("fontIcon", "chevron_left");
          ɵɵadvance();
          ɵɵproperty("text", "Today");
          ɵɵadvance();
          ɵɵproperty("text", "")("fontIcon", "chevron_right");
          ɵɵadvance();
          ɵɵproperty("ngIf", ctx.showEventIndicators);
          ɵɵadvance(4);
          ɵɵproperty("ngForOf", ctx.weekDays);
          ɵɵadvance(2);
          ɵɵproperty("ngForOf", ctx.calendar);
          ɵɵadvance();
          ɵɵproperty("ngIf", ctx.getEventsForDate(ctx.selectedDate).length > 0);
          ɵɵadvance();
          ɵɵproperty("ngIf", ctx.getEventsForDate(ctx.selectedDate).length === 0);
          ɵɵadvance();
          ɵɵproperty("ngIf", ctx.getEventsForDate(ctx.selectedDate).length > 0);
          ɵɵadvance();
          ɵɵproperty("ngIf", ctx.getEventsForDate(ctx.selectedDate).length === 0);
        }
      },
      dependencies: [CommonModule, NgForOf, NgIf, CalendarModule, MatButtonModule, MatIconModule, AppButtonComponent],
      styles: [".calendar-container[_ngcontent-%COMP%]{background:#fff;border-radius:8px;box-shadow:0 2px 8px #0000001a;overflow:hidden;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,sans-serif;max-width:100%;height:100%}.calendar-header[_ngcontent-%COMP%]{background:#fff;border-bottom:1px solid #e0e0e0;padding:16px 20px;height:4.5em}.calendar-header[_ngcontent-%COMP%]   .header-content[_ngcontent-%COMP%]{display:flex;justify-content:space-between;align-items:center}.calendar-header[_ngcontent-%COMP%]   .header-content[_ngcontent-%COMP%]   .month-year[_ngcontent-%COMP%]   .month-year-text[_ngcontent-%COMP%]{margin:0;font-size:18px;font-weight:600;color:#007aff}.calendar-header[_ngcontent-%COMP%]   .header-content[_ngcontent-%COMP%]   .navigation-controls[_ngcontent-%COMP%]{min-width:10em;display:flex;align-items:center;gap:8px}.calendar-header[_ngcontent-%COMP%]   .header-content[_ngcontent-%COMP%]   .navigation-controls[_ngcontent-%COMP%]   .nav-btn[_ngcontent-%COMP%]{min-width:3em;width:32px;height:32px;padding:0;color:#007aff}.calendar-header[_ngcontent-%COMP%]   .header-content[_ngcontent-%COMP%]   .navigation-controls[_ngcontent-%COMP%]   .nav-btn[_ngcontent-%COMP%]     .mat-mdc-button-touch-target{width:32px;height:32px}.calendar-header[_ngcontent-%COMP%]   .header-content[_ngcontent-%COMP%]   .navigation-controls[_ngcontent-%COMP%]   .today-btn[_ngcontent-%COMP%]{color:#007aff;font-weight:500;min-width:60px;font-size:14px}.calendar-legend[_ngcontent-%COMP%]{display:flex;justify-content:center;gap:20px;padding:8px 20px;background:#f8f9fa;border-bottom:1px solid #e0e0e0;height:2em}.calendar-legend[_ngcontent-%COMP%]   .legend-item[_ngcontent-%COMP%]{display:flex;align-items:center;gap:6px}.calendar-legend[_ngcontent-%COMP%]   .legend-item[_ngcontent-%COMP%]   .legend-dot[_ngcontent-%COMP%]{width:8px;height:8px;border-radius:50%}.calendar-legend[_ngcontent-%COMP%]   .legend-item[_ngcontent-%COMP%]   .legend-dot.available[_ngcontent-%COMP%]{background:#4caf50}.calendar-legend[_ngcontent-%COMP%]   .legend-item[_ngcontent-%COMP%]   .legend-dot.appointment[_ngcontent-%COMP%]{background:#f44336}.calendar-legend[_ngcontent-%COMP%]   .legend-item[_ngcontent-%COMP%]   .legend-text[_ngcontent-%COMP%]{font-size:12px;color:#666;font-weight:500}.calendar-events-container[_ngcontent-%COMP%]{display:flex;height:calc(100% - 6.6em)}.calendar-grid[_ngcontent-%COMP%]{flex:1;padding:0 20px 16px;min-width:60%}.calendar-grid[_ngcontent-%COMP%]   .week-header[_ngcontent-%COMP%]{display:grid;grid-template-columns:repeat(7,1fr);margin-bottom:8px}.calendar-grid[_ngcontent-%COMP%]   .week-header[_ngcontent-%COMP%]   .week-day[_ngcontent-%COMP%]{text-align:center;font-size:12px;font-weight:500;color:#8e8e93;padding:8px 0}.calendar-grid[_ngcontent-%COMP%]   .calendar-body[_ngcontent-%COMP%]   .calendar-week[_ngcontent-%COMP%]{display:grid;grid-template-columns:repeat(7,1fr);border-bottom:1px solid #F2F2F7}.calendar-grid[_ngcontent-%COMP%]   .calendar-body[_ngcontent-%COMP%]   .calendar-week[_ngcontent-%COMP%]:last-child{border-bottom:none}.calendar-grid[_ngcontent-%COMP%]   .calendar-body[_ngcontent-%COMP%]   .calendar-week[_ngcontent-%COMP%]   .calendar-day[_ngcontent-%COMP%]{min-height:40px;padding:4px;position:relative;display:flex;flex-direction:column;align-items:center;justify-content:center;cursor:pointer;transition:background-color .2s ease}.calendar-grid[_ngcontent-%COMP%]   .calendar-body[_ngcontent-%COMP%]   .calendar-week[_ngcontent-%COMP%]   .calendar-day[_ngcontent-%COMP%]:hover{background:#f2f2f7}.calendar-grid[_ngcontent-%COMP%]   .calendar-body[_ngcontent-%COMP%]   .calendar-week[_ngcontent-%COMP%]   .calendar-day.today[_ngcontent-%COMP%]   .day-number[_ngcontent-%COMP%], .calendar-grid[_ngcontent-%COMP%]   .calendar-body[_ngcontent-%COMP%]   .calendar-week[_ngcontent-%COMP%]   .calendar-day.selected[_ngcontent-%COMP%]   .day-number[_ngcontent-%COMP%]{background:#007aff;color:#fff;border-radius:50%;width:28px;height:28px;display:flex;align-items:center;justify-content:center;font-weight:600;font-size:14px}.calendar-grid[_ngcontent-%COMP%]   .calendar-body[_ngcontent-%COMP%]   .calendar-week[_ngcontent-%COMP%]   .calendar-day.other-month[_ngcontent-%COMP%]   .day-number[_ngcontent-%COMP%]{color:#c7c7cc}.calendar-grid[_ngcontent-%COMP%]   .calendar-body[_ngcontent-%COMP%]   .calendar-week[_ngcontent-%COMP%]   .calendar-day[_ngcontent-%COMP%]   .day-number[_ngcontent-%COMP%]{font-size:16px;font-weight:400;color:#000;margin-bottom:4px;width:28px;height:28px;display:flex;align-items:center;justify-content:center}.calendar-grid[_ngcontent-%COMP%]   .calendar-body[_ngcontent-%COMP%]   .calendar-week[_ngcontent-%COMP%]   .calendar-day[_ngcontent-%COMP%]   .event-indicators[_ngcontent-%COMP%]{display:flex;gap:2px;margin-top:2px;flex-wrap:wrap;justify-content:center}.calendar-grid[_ngcontent-%COMP%]   .calendar-body[_ngcontent-%COMP%]   .calendar-week[_ngcontent-%COMP%]   .calendar-day[_ngcontent-%COMP%]   .event-indicators[_ngcontent-%COMP%]   .event-dot[_ngcontent-%COMP%]{width:6px;height:6px;border-radius:50%;background:#8e8e93;transition:transform .2s ease}.calendar-grid[_ngcontent-%COMP%]   .calendar-body[_ngcontent-%COMP%]   .calendar-week[_ngcontent-%COMP%]   .calendar-day[_ngcontent-%COMP%]   .event-indicators[_ngcontent-%COMP%]   .event-dot[_ngcontent-%COMP%]:hover{transform:scale(1.2)}.calendar-grid[_ngcontent-%COMP%]   .calendar-body[_ngcontent-%COMP%]   .calendar-week[_ngcontent-%COMP%]   .calendar-day[_ngcontent-%COMP%]   .event-indicators[_ngcontent-%COMP%]   .event-dot.appointment[_ngcontent-%COMP%]{background:#f44336}.calendar-grid[_ngcontent-%COMP%]   .calendar-body[_ngcontent-%COMP%]   .calendar-week[_ngcontent-%COMP%]   .calendar-day[_ngcontent-%COMP%]   .event-indicators[_ngcontent-%COMP%]   .event-dot.available[_ngcontent-%COMP%]{background:#4caf50}.calendar-grid[_ngcontent-%COMP%]   .calendar-body[_ngcontent-%COMP%]   .calendar-week[_ngcontent-%COMP%]   .calendar-day[_ngcontent-%COMP%]   .event-indicators[_ngcontent-%COMP%]   .event-dot.break[_ngcontent-%COMP%]{background:#ff9800}.calendar-grid[_ngcontent-%COMP%]   .calendar-body[_ngcontent-%COMP%]   .calendar-week[_ngcontent-%COMP%]   .calendar-day[_ngcontent-%COMP%]   .event-indicators[_ngcontent-%COMP%]   .event-dot.leave[_ngcontent-%COMP%]{background:#f44336}.events-panel[_ngcontent-%COMP%]{width:35%;border-left:1px solid #F2F2F7;background:#fff;display:flex;flex-direction:column;height:100%}.events-panel-wrapper[_ngcontent-%COMP%]{height:calc(100% - 3.5em);overflow-y:scroll}.events-panel[_ngcontent-%COMP%]   .date-header[_ngcontent-%COMP%]{padding:.6em 1em .4em;border-bottom:1px solid #F2F2F7;height:2.5em}.events-panel[_ngcontent-%COMP%]   .date-header[_ngcontent-%COMP%]   .date-title[_ngcontent-%COMP%]{margin:0;font-size:16px;font-weight:600;color:#000}.events-panel[_ngcontent-%COMP%]   .event-item[_ngcontent-%COMP%]{padding:12px 20px;border-bottom:1px solid #F2F2F7;border-left:4px solid;cursor:pointer;transition:background-color .2s ease}.events-panel[_ngcontent-%COMP%]   .event-item[_ngcontent-%COMP%]:hover{background:#f2f2f7}.events-panel[_ngcontent-%COMP%]   .event-item[_ngcontent-%COMP%]:last-child{border-bottom:none}.events-panel[_ngcontent-%COMP%]   .event-item[_ngcontent-%COMP%]   .event-content[_ngcontent-%COMP%]   .event-title[_ngcontent-%COMP%]{font-size:16px;font-weight:500;color:#000;margin-bottom:4px}.events-panel[_ngcontent-%COMP%]   .event-item[_ngcontent-%COMP%]   .event-content[_ngcontent-%COMP%]   .event-description[_ngcontent-%COMP%]{font-size:14px;color:#8e8e93;margin-bottom:4px}.events-panel[_ngcontent-%COMP%]   .event-item[_ngcontent-%COMP%]   .event-content[_ngcontent-%COMP%]   .event-time[_ngcontent-%COMP%]{font-size:14px;color:#8e8e93}.no-events-panel[_ngcontent-%COMP%]{width:40%;border-left:1px solid #F2F2F7;padding:20px;text-align:center;background:#fff;display:flex;align-items:center;justify-content:center}.no-events-panel[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{margin:0;font-size:16px;color:#8e8e93}.events-list-bottom[_ngcontent-%COMP%]{display:none;border-top:1px solid #F2F2F7;background:#fff}.events-list-bottom[_ngcontent-%COMP%]   .date-header[_ngcontent-%COMP%]{padding:16px 20px 8px;border-bottom:1px solid #F2F2F7}.events-list-bottom[_ngcontent-%COMP%]   .date-header[_ngcontent-%COMP%]   .date-title[_ngcontent-%COMP%]{margin:0;font-size:16px;font-weight:600;color:#000}.events-list-bottom[_ngcontent-%COMP%]   .event-item[_ngcontent-%COMP%]{padding:12px 20px;border-bottom:1px solid #F2F2F7;border-left:4px solid;cursor:pointer;transition:background-color .2s ease}.events-list-bottom[_ngcontent-%COMP%]   .event-item[_ngcontent-%COMP%]:hover{background:#f2f2f7}.events-list-bottom[_ngcontent-%COMP%]   .event-item[_ngcontent-%COMP%]:last-child{border-bottom:none}.events-list-bottom[_ngcontent-%COMP%]   .event-item[_ngcontent-%COMP%]   .event-content[_ngcontent-%COMP%]   .event-title[_ngcontent-%COMP%]{font-size:16px;font-weight:500;color:#000;margin-bottom:4px}.events-list-bottom[_ngcontent-%COMP%]   .event-item[_ngcontent-%COMP%]   .event-content[_ngcontent-%COMP%]   .event-description[_ngcontent-%COMP%]{font-size:14px;color:#8e8e93;margin-bottom:4px}.events-list-bottom[_ngcontent-%COMP%]   .event-item[_ngcontent-%COMP%]   .event-content[_ngcontent-%COMP%]   .event-time[_ngcontent-%COMP%]{font-size:14px;color:#8e8e93}.no-events-bottom[_ngcontent-%COMP%]{display:none;border-top:1px solid #F2F2F7;padding:20px;text-align:center;background:#fff}.no-events-bottom[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{margin:0;font-size:16px;color:#8e8e93}@media (max-width: 768px){.calendar-container[_ngcontent-%COMP%]{border-radius:0;box-shadow:none;max-width:100%;height:100%}.calendar-events-container[_ngcontent-%COMP%]{flex-direction:column;height:100%}.calendar-grid[_ngcontent-%COMP%]{padding:0 16px 12px;min-width:auto}.calendar-grid[_ngcontent-%COMP%]   .calendar-body[_ngcontent-%COMP%]   .calendar-week[_ngcontent-%COMP%]   .calendar-day[_ngcontent-%COMP%]{min-height:35px}.calendar-grid[_ngcontent-%COMP%]   .calendar-body[_ngcontent-%COMP%]   .calendar-week[_ngcontent-%COMP%]   .calendar-day[_ngcontent-%COMP%]   .day-number[_ngcontent-%COMP%]{font-size:14px;width:24px;height:24px}.calendar-grid[_ngcontent-%COMP%]   .calendar-body[_ngcontent-%COMP%]   .calendar-week[_ngcontent-%COMP%]   .calendar-day.today[_ngcontent-%COMP%]   .day-number[_ngcontent-%COMP%], .calendar-grid[_ngcontent-%COMP%]   .calendar-body[_ngcontent-%COMP%]   .calendar-week[_ngcontent-%COMP%]   .calendar-day.selected[_ngcontent-%COMP%]   .day-number[_ngcontent-%COMP%]{width:24px;height:24px;font-size:12px}.events-panel[_ngcontent-%COMP%], .no-events-panel[_ngcontent-%COMP%]{display:none}.events-list-bottom[_ngcontent-%COMP%]{display:block}.events-list-bottom[_ngcontent-%COMP%]   .date-header[_ngcontent-%COMP%]{padding:12px 16px 6px}.events-list-bottom[_ngcontent-%COMP%]   .event-item[_ngcontent-%COMP%]{padding:10px 16px}.no-events-bottom[_ngcontent-%COMP%]{display:block;padding:16px}}@media (min-width: 769px) and (max-width: 1024px){.calendar-events-container[_ngcontent-%COMP%]{flex-direction:column;height:100%}.calendar-grid[_ngcontent-%COMP%]{min-width:auto}.events-panel[_ngcontent-%COMP%], .no-events-panel[_ngcontent-%COMP%]{display:none}.events-list-bottom[_ngcontent-%COMP%], .no-events-bottom[_ngcontent-%COMP%]{display:block}}@media (min-width: 1025px){.events-list-bottom[_ngcontent-%COMP%], .no-events-bottom[_ngcontent-%COMP%]{display:none}}@media (prefers-color-scheme: dark){.calendar-container[_ngcontent-%COMP%]{background:#1c1c1e;color:#fff}.calendar-header[_ngcontent-%COMP%]{background:#1c1c1e;border-bottom-color:#38383a}.calendar-header[_ngcontent-%COMP%]   .header-content[_ngcontent-%COMP%]   .month-year-text[_ngcontent-%COMP%]{color:#0a84ff}.calendar-legend[_ngcontent-%COMP%]{background:#2c2c2e;border-bottom-color:#38383a}.calendar-legend[_ngcontent-%COMP%]   .legend-item[_ngcontent-%COMP%]   .legend-text[_ngcontent-%COMP%], .calendar-grid[_ngcontent-%COMP%]   .week-header[_ngcontent-%COMP%]   .week-day[_ngcontent-%COMP%]{color:#8e8e93}.calendar-grid[_ngcontent-%COMP%]   .calendar-body[_ngcontent-%COMP%]   .calendar-week[_ngcontent-%COMP%]{border-bottom-color:#38383a}.calendar-grid[_ngcontent-%COMP%]   .calendar-body[_ngcontent-%COMP%]   .calendar-week[_ngcontent-%COMP%]   .calendar-day[_ngcontent-%COMP%]:hover{background:#2c2c2e}.calendar-grid[_ngcontent-%COMP%]   .calendar-body[_ngcontent-%COMP%]   .calendar-week[_ngcontent-%COMP%]   .calendar-day.today[_ngcontent-%COMP%]   .day-number[_ngcontent-%COMP%], .calendar-grid[_ngcontent-%COMP%]   .calendar-body[_ngcontent-%COMP%]   .calendar-week[_ngcontent-%COMP%]   .calendar-day.selected[_ngcontent-%COMP%]   .day-number[_ngcontent-%COMP%]{background:#0a84ff}.calendar-grid[_ngcontent-%COMP%]   .calendar-body[_ngcontent-%COMP%]   .calendar-week[_ngcontent-%COMP%]   .calendar-day.other-month[_ngcontent-%COMP%]   .day-number[_ngcontent-%COMP%]{color:#48484a}.calendar-grid[_ngcontent-%COMP%]   .calendar-body[_ngcontent-%COMP%]   .calendar-week[_ngcontent-%COMP%]   .calendar-day[_ngcontent-%COMP%]   .day-number[_ngcontent-%COMP%]{color:#fff}.events-panel[_ngcontent-%COMP%]{background:#1c1c1e;border-left-color:#38383a}.events-panel[_ngcontent-%COMP%]   .date-header[_ngcontent-%COMP%]{border-bottom-color:#38383a}.events-panel[_ngcontent-%COMP%]   .date-header[_ngcontent-%COMP%]   .date-title[_ngcontent-%COMP%]{color:#fff}.events-panel[_ngcontent-%COMP%]   .event-item[_ngcontent-%COMP%]{border-bottom-color:#38383a}.events-panel[_ngcontent-%COMP%]   .event-item[_ngcontent-%COMP%]:hover{background:#2c2c2e}.events-panel[_ngcontent-%COMP%]   .event-item[_ngcontent-%COMP%]   .event-content[_ngcontent-%COMP%]   .event-title[_ngcontent-%COMP%]{color:#fff}.events-panel[_ngcontent-%COMP%]   .event-item[_ngcontent-%COMP%]   .event-content[_ngcontent-%COMP%]   .event-description[_ngcontent-%COMP%], .events-panel[_ngcontent-%COMP%]   .event-item[_ngcontent-%COMP%]   .event-content[_ngcontent-%COMP%]   .event-time[_ngcontent-%COMP%]{color:#8e8e93}.no-events-panel[_ngcontent-%COMP%]{background:#1c1c1e;border-left-color:#38383a}.no-events-panel[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{color:#8e8e93}.events-list-bottom[_ngcontent-%COMP%]{background:#1c1c1e;border-top-color:#38383a}.events-list-bottom[_ngcontent-%COMP%]   .date-header[_ngcontent-%COMP%]{border-bottom-color:#38383a}.events-list-bottom[_ngcontent-%COMP%]   .date-header[_ngcontent-%COMP%]   .date-title[_ngcontent-%COMP%]{color:#fff}.events-list-bottom[_ngcontent-%COMP%]   .event-item[_ngcontent-%COMP%]{border-bottom-color:#38383a}.events-list-bottom[_ngcontent-%COMP%]   .event-item[_ngcontent-%COMP%]:hover{background:#2c2c2e}.events-list-bottom[_ngcontent-%COMP%]   .event-item[_ngcontent-%COMP%]   .event-content[_ngcontent-%COMP%]   .event-title[_ngcontent-%COMP%]{color:#fff}.events-list-bottom[_ngcontent-%COMP%]   .event-item[_ngcontent-%COMP%]   .event-content[_ngcontent-%COMP%]   .event-description[_ngcontent-%COMP%], .events-list-bottom[_ngcontent-%COMP%]   .event-item[_ngcontent-%COMP%]   .event-content[_ngcontent-%COMP%]   .event-time[_ngcontent-%COMP%]{color:#8e8e93}.no-events-bottom[_ngcontent-%COMP%]{background:#1c1c1e;border-top-color:#38383a}.no-events-bottom[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{color:#8e8e93}}"],
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarComponent, [{
    type: Component,
    args: [{
      selector: "app-calendar",
      standalone: true,
      imports: [CommonModule, CalendarModule, MatButtonModule, MatIconModule, AppButtonComponent],
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<div class="calendar-container">
  <!-- Calendar Header -->
  <div class="calendar-header">
    <div class="header-content">
      <div class="month-year">
        <h2 class="month-year-text">{{ getMonthYearString() }}</h2>
      </div>
      
      <div class="navigation-controls">
        <app-button
          type="button"
          appearance="icon"
          (btnClick)="previousMonth()"
          class="nav-btn"
          [text]="''"
          [fontIcon]="'chevron_left'">
        </app-button>
        
        <app-button
          type="button"
          appearance="basic"
          (btnClick)="onTodayClick()"
          class="today-btn"
          [text]="'Today'">
        </app-button>
        
        <app-button
          type="button"
          appearance="icon"
          (btnClick)="nextMonth()"
          class="nav-btn"
          [text]="''"
          [fontIcon]="'chevron_right'">
        </app-button>
      </div>
    </div>
  </div>

  <!-- Calendar Legend -->
  <div class="calendar-legend" *ngIf="showEventIndicators">
    <div class="legend-item">
      <div class="legend-dot available"></div>
      <span class="legend-text">Available</span>
    </div>
    <div class="legend-item">
      <div class="legend-dot appointment"></div>
      <span class="legend-text">Booked</span>
    </div>
  </div>

  <!-- Calendar and Events Container -->
  <div class="calendar-events-container">
    <!-- Calendar Grid -->
    <div class="calendar-grid">
      <!-- Week Days Header -->
      <div class="week-header">
        <div class="week-day" *ngFor="let day of weekDays">{{ day }}</div>
      </div>

      <!-- Calendar Days -->
      <div class="calendar-body">
        <div class="calendar-week" *ngFor="let week of calendar">
          <div 
            class="calendar-day"
            *ngFor="let date of week"
            [class.today]="isToday(date)"
            [class.selected]="isSelected(date)"
            [class.other-month]="!isCurrentMonth(date)"
            [class.clickable]="allowDateSelection"
            (click)="allowDateSelection ? onDateSelected({date: date}) : null">
            
            <div class="day-number">{{ date.getDate() }}</div>
            
            <!-- Event Indicators -->
            <div 
              class="event-indicators" 
              *ngIf="showEventIndicators && getEventsForDate(date).length > 0">
              <div 
                class="event-dot"
                *ngFor="let event of getEventsForDate(date).slice(0, 3)"
                [class]="'event-dot ' + (event.type || 'other')"
                [style.background-color]="getEventColor(event).primary">
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Events Panel (Right Side) -->
    <div class="events-panel" *ngIf="getEventsForDate(selectedDate).length > 0">
      <div class="date-header">
        <h3 class="date-title">{{ formatSelectedDate() }}</h3>
      </div>
      

      <div class="events-panel-wrapper">
        <div class="event-item" 
        *ngFor="let event of getEventsForDate(selectedDate)"
        (click)="onEventClicked({event: {meta: {originalEvent: event}}})"
        [style.border-left-color]="getEventColor(event).primary">
     <div class="event-content">
       <div class="event-title">{{ event.title }}</div>
       <div class="event-description" *ngIf="event.description">{{ event.description }}</div>
       <div class="event-time">
         <span *ngIf="event.allDay">All-day</span>
         <span *ngIf="!event.allDay">{{ formatEventTime(event) }}</span>
       </div>
     </div>
   </div>
      </div>
    </div>

    <!-- No Events Message (Right Side) -->
    <div class="no-events-panel" *ngIf="getEventsForDate(selectedDate).length === 0">
      <p>No events for {{ formatSelectedDate() }}</p>
    </div>
  </div>

  <!-- Events List (Bottom - Mobile/Compact) -->
  <div class="events-list-bottom" *ngIf="getEventsForDate(selectedDate).length > 0">
    <div class="date-header">
      <h3 class="date-title">{{ formatSelectedDate() }}</h3>
    </div>
    
    <div class="event-item" 
         *ngFor="let event of getEventsForDate(selectedDate)"
         (click)="onEventClicked({event: {meta: {originalEvent: event}}})"
         [style.border-left-color]="getEventColor(event).primary">
      <div class="event-content">
        <div class="event-title">{{ event.title }}</div>
        <div class="event-description" *ngIf="event.description">{{ event.description }}</div>
        <div class="event-time">
          <span *ngIf="event.allDay">All-day</span>
          <span *ngIf="!event.allDay">{{ formatEventTime(event) }}</span>
        </div>
      </div>
    </div>
  </div>

  <!-- No Events Message (Bottom) -->
  <div class="no-events-bottom" *ngIf="getEventsForDate(selectedDate).length === 0">
    <p>No events for {{ formatSelectedDate() }}</p>
  </div>
</div> `,
      styles: [".calendar-container{background:#fff;border-radius:8px;box-shadow:0 2px 8px #0000001a;overflow:hidden;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,sans-serif;max-width:100%;height:100%}.calendar-header{background:#fff;border-bottom:1px solid #e0e0e0;padding:16px 20px;height:4.5em}.calendar-header .header-content{display:flex;justify-content:space-between;align-items:center}.calendar-header .header-content .month-year .month-year-text{margin:0;font-size:18px;font-weight:600;color:#007aff}.calendar-header .header-content .navigation-controls{min-width:10em;display:flex;align-items:center;gap:8px}.calendar-header .header-content .navigation-controls .nav-btn{min-width:3em;width:32px;height:32px;padding:0;color:#007aff}.calendar-header .header-content .navigation-controls .nav-btn ::ng-deep .mat-mdc-button-touch-target{width:32px;height:32px}.calendar-header .header-content .navigation-controls .today-btn{color:#007aff;font-weight:500;min-width:60px;font-size:14px}.calendar-legend{display:flex;justify-content:center;gap:20px;padding:8px 20px;background:#f8f9fa;border-bottom:1px solid #e0e0e0;height:2em}.calendar-legend .legend-item{display:flex;align-items:center;gap:6px}.calendar-legend .legend-item .legend-dot{width:8px;height:8px;border-radius:50%}.calendar-legend .legend-item .legend-dot.available{background:#4caf50}.calendar-legend .legend-item .legend-dot.appointment{background:#f44336}.calendar-legend .legend-item .legend-text{font-size:12px;color:#666;font-weight:500}.calendar-events-container{display:flex;height:calc(100% - 6.6em)}.calendar-grid{flex:1;padding:0 20px 16px;min-width:60%}.calendar-grid .week-header{display:grid;grid-template-columns:repeat(7,1fr);margin-bottom:8px}.calendar-grid .week-header .week-day{text-align:center;font-size:12px;font-weight:500;color:#8e8e93;padding:8px 0}.calendar-grid .calendar-body .calendar-week{display:grid;grid-template-columns:repeat(7,1fr);border-bottom:1px solid #F2F2F7}.calendar-grid .calendar-body .calendar-week:last-child{border-bottom:none}.calendar-grid .calendar-body .calendar-week .calendar-day{min-height:40px;padding:4px;position:relative;display:flex;flex-direction:column;align-items:center;justify-content:center;cursor:pointer;transition:background-color .2s ease}.calendar-grid .calendar-body .calendar-week .calendar-day:hover{background:#f2f2f7}.calendar-grid .calendar-body .calendar-week .calendar-day.today .day-number,.calendar-grid .calendar-body .calendar-week .calendar-day.selected .day-number{background:#007aff;color:#fff;border-radius:50%;width:28px;height:28px;display:flex;align-items:center;justify-content:center;font-weight:600;font-size:14px}.calendar-grid .calendar-body .calendar-week .calendar-day.other-month .day-number{color:#c7c7cc}.calendar-grid .calendar-body .calendar-week .calendar-day .day-number{font-size:16px;font-weight:400;color:#000;margin-bottom:4px;width:28px;height:28px;display:flex;align-items:center;justify-content:center}.calendar-grid .calendar-body .calendar-week .calendar-day .event-indicators{display:flex;gap:2px;margin-top:2px;flex-wrap:wrap;justify-content:center}.calendar-grid .calendar-body .calendar-week .calendar-day .event-indicators .event-dot{width:6px;height:6px;border-radius:50%;background:#8e8e93;transition:transform .2s ease}.calendar-grid .calendar-body .calendar-week .calendar-day .event-indicators .event-dot:hover{transform:scale(1.2)}.calendar-grid .calendar-body .calendar-week .calendar-day .event-indicators .event-dot.appointment{background:#f44336}.calendar-grid .calendar-body .calendar-week .calendar-day .event-indicators .event-dot.available{background:#4caf50}.calendar-grid .calendar-body .calendar-week .calendar-day .event-indicators .event-dot.break{background:#ff9800}.calendar-grid .calendar-body .calendar-week .calendar-day .event-indicators .event-dot.leave{background:#f44336}.events-panel{width:35%;border-left:1px solid #F2F2F7;background:#fff;display:flex;flex-direction:column;height:100%}.events-panel-wrapper{height:calc(100% - 3.5em);overflow-y:scroll}.events-panel .date-header{padding:.6em 1em .4em;border-bottom:1px solid #F2F2F7;height:2.5em}.events-panel .date-header .date-title{margin:0;font-size:16px;font-weight:600;color:#000}.events-panel .event-item{padding:12px 20px;border-bottom:1px solid #F2F2F7;border-left:4px solid;cursor:pointer;transition:background-color .2s ease}.events-panel .event-item:hover{background:#f2f2f7}.events-panel .event-item:last-child{border-bottom:none}.events-panel .event-item .event-content .event-title{font-size:16px;font-weight:500;color:#000;margin-bottom:4px}.events-panel .event-item .event-content .event-description{font-size:14px;color:#8e8e93;margin-bottom:4px}.events-panel .event-item .event-content .event-time{font-size:14px;color:#8e8e93}.no-events-panel{width:40%;border-left:1px solid #F2F2F7;padding:20px;text-align:center;background:#fff;display:flex;align-items:center;justify-content:center}.no-events-panel p{margin:0;font-size:16px;color:#8e8e93}.events-list-bottom{display:none;border-top:1px solid #F2F2F7;background:#fff}.events-list-bottom .date-header{padding:16px 20px 8px;border-bottom:1px solid #F2F2F7}.events-list-bottom .date-header .date-title{margin:0;font-size:16px;font-weight:600;color:#000}.events-list-bottom .event-item{padding:12px 20px;border-bottom:1px solid #F2F2F7;border-left:4px solid;cursor:pointer;transition:background-color .2s ease}.events-list-bottom .event-item:hover{background:#f2f2f7}.events-list-bottom .event-item:last-child{border-bottom:none}.events-list-bottom .event-item .event-content .event-title{font-size:16px;font-weight:500;color:#000;margin-bottom:4px}.events-list-bottom .event-item .event-content .event-description{font-size:14px;color:#8e8e93;margin-bottom:4px}.events-list-bottom .event-item .event-content .event-time{font-size:14px;color:#8e8e93}.no-events-bottom{display:none;border-top:1px solid #F2F2F7;padding:20px;text-align:center;background:#fff}.no-events-bottom p{margin:0;font-size:16px;color:#8e8e93}@media (max-width: 768px){.calendar-container{border-radius:0;box-shadow:none;max-width:100%;height:100%}.calendar-events-container{flex-direction:column;height:100%}.calendar-grid{padding:0 16px 12px;min-width:auto}.calendar-grid .calendar-body .calendar-week .calendar-day{min-height:35px}.calendar-grid .calendar-body .calendar-week .calendar-day .day-number{font-size:14px;width:24px;height:24px}.calendar-grid .calendar-body .calendar-week .calendar-day.today .day-number,.calendar-grid .calendar-body .calendar-week .calendar-day.selected .day-number{width:24px;height:24px;font-size:12px}.events-panel,.no-events-panel{display:none}.events-list-bottom{display:block}.events-list-bottom .date-header{padding:12px 16px 6px}.events-list-bottom .event-item{padding:10px 16px}.no-events-bottom{display:block;padding:16px}}@media (min-width: 769px) and (max-width: 1024px){.calendar-events-container{flex-direction:column;height:100%}.calendar-grid{min-width:auto}.events-panel,.no-events-panel{display:none}.events-list-bottom,.no-events-bottom{display:block}}@media (min-width: 1025px){.events-list-bottom,.no-events-bottom{display:none}}@media (prefers-color-scheme: dark){.calendar-container{background:#1c1c1e;color:#fff}.calendar-header{background:#1c1c1e;border-bottom-color:#38383a}.calendar-header .header-content .month-year-text{color:#0a84ff}.calendar-legend{background:#2c2c2e;border-bottom-color:#38383a}.calendar-legend .legend-item .legend-text,.calendar-grid .week-header .week-day{color:#8e8e93}.calendar-grid .calendar-body .calendar-week{border-bottom-color:#38383a}.calendar-grid .calendar-body .calendar-week .calendar-day:hover{background:#2c2c2e}.calendar-grid .calendar-body .calendar-week .calendar-day.today .day-number,.calendar-grid .calendar-body .calendar-week .calendar-day.selected .day-number{background:#0a84ff}.calendar-grid .calendar-body .calendar-week .calendar-day.other-month .day-number{color:#48484a}.calendar-grid .calendar-body .calendar-week .calendar-day .day-number{color:#fff}.events-panel{background:#1c1c1e;border-left-color:#38383a}.events-panel .date-header{border-bottom-color:#38383a}.events-panel .date-header .date-title{color:#fff}.events-panel .event-item{border-bottom-color:#38383a}.events-panel .event-item:hover{background:#2c2c2e}.events-panel .event-item .event-content .event-title{color:#fff}.events-panel .event-item .event-content .event-description,.events-panel .event-item .event-content .event-time{color:#8e8e93}.no-events-panel{background:#1c1c1e;border-left-color:#38383a}.no-events-panel p{color:#8e8e93}.events-list-bottom{background:#1c1c1e;border-top-color:#38383a}.events-list-bottom .date-header{border-bottom-color:#38383a}.events-list-bottom .date-header .date-title{color:#fff}.events-list-bottom .event-item{border-bottom-color:#38383a}.events-list-bottom .event-item:hover{background:#2c2c2e}.events-list-bottom .event-item .event-content .event-title{color:#fff}.events-list-bottom .event-item .event-content .event-description,.events-list-bottom .event-item .event-content .event-time{color:#8e8e93}.no-events-bottom{background:#1c1c1e;border-top-color:#38383a}.no-events-bottom p{color:#8e8e93}}\n"]
    }]
  }], null, {
    events: [{
      type: Input
    }],
    selectedDate: [{
      type: Input
    }],
    view: [{
      type: Input
    }],
    viewDate: [{
      type: Input
    }],
    showNavigation: [{
      type: Input
    }],
    showToday: [{
      type: Input
    }],
    allowDateSelection: [{
      type: Input
    }],
    highlightToday: [{
      type: Input
    }],
    showEventIndicators: [{
      type: Input
    }],
    locale: [{
      type: Input
    }],
    dateSelected: [{
      type: Output
    }],
    eventClicked: [{
      type: Output
    }],
    monthChanged: [{
      type: Output
    }],
    viewChanged: [{
      type: Output
    }]
  });
})();
var ImageComponent = class _ImageComponent {
  constructor() {
    this.src = void 0;
    this.alt = "";
    this.width = "";
    this.height = "";
    this.class = "";
    this.style = "";
    this.loading = "lazy";
    this.decoding = "async";
    this.crossorigin = void 0;
    this.config = void 0;
    this.clickable = false;
    this.imageLoad = new EventEmitter();
    this.imageError = new EventEmitter();
    this.imageClick = new EventEmitter();
    this.cachedStyle = "";
    this.lastWidth = "";
    this.lastHeight = "";
    this.lastStyle = "";
  }
  ngOnInit() {
    if (this.config) {
      this.src = this.config.src || this.src;
      this.alt = this.config.alt || this.alt;
      this.width = this.config.width || this.width;
      this.height = this.config.height || this.height;
      this.class = this.config.class || this.class;
      this.style = this.config.style || this.style;
      this.loading = this.config.loading || this.loading;
      this.decoding = this.config.decoding || this.decoding;
      this.crossorigin = this.config.crossorigin || this.crossorigin;
    }
    this.updateCachedStyle();
  }
  ngOnChanges() {
    if (this.width !== this.lastWidth || this.height !== this.lastHeight || this.style !== this.lastStyle) {
      this.updateCachedStyle();
      this.lastWidth = this.width;
      this.lastHeight = this.height;
      this.lastStyle = this.style;
    }
  }
  updateCachedStyle() {
    let style2 = this.style || "";
    if (this.width) {
      style2 += `width: ${typeof this.width === "number" ? this.width + "px" : this.width}; `;
    }
    if (this.height) {
      style2 += `height: ${typeof this.height === "number" ? this.height + "px" : this.height}; `;
    }
    this.cachedStyle = style2.trim();
  }
  getImageStyle() {
    return this.cachedStyle;
  }
  onImageLoad(event) {
    this.imageLoad.emit(event);
  }
  onImageError(event) {
    this.imageError.emit(event);
  }
  onImageClick(event) {
    if (this.clickable) {
      this.imageClick.emit(event);
    }
  }
  static {
    this.ɵfac = function ImageComponent_Factory(t) {
      return new (t || _ImageComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _ImageComponent,
      selectors: [["app-image"]],
      inputs: {
        src: "src",
        alt: "alt",
        width: "width",
        height: "height",
        class: "class",
        style: "style",
        loading: "loading",
        decoding: "decoding",
        crossorigin: "crossorigin",
        config: "config",
        clickable: "clickable"
      },
      outputs: {
        imageLoad: "imageLoad",
        imageError: "imageError",
        imageClick: "imageClick"
      },
      standalone: true,
      features: [ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
      decls: 1,
      vars: 10,
      consts: [["role", "img", 3, "error", "load", "click", "src", "alt", "loading", "decoding"]],
      template: function ImageComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "img", 0);
          ɵɵlistener("error", function ImageComponent_Template_img_error_0_listener($event) {
            return ctx.onImageError($event);
          })("load", function ImageComponent_Template_img_load_0_listener($event) {
            return ctx.onImageLoad($event);
          })("click", function ImageComponent_Template_img_click_0_listener($event) {
            return ctx.onImageClick($event);
          });
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵstyleMap(ctx.cachedStyle);
          ɵɵclassMap(ctx.class + (ctx.clickable ? " clickable" : ""));
          ɵɵproperty("src", ctx.src, ɵɵsanitizeUrl)("alt", ctx.alt)("loading", ctx.loading)("decoding", ctx.decoding);
          ɵɵattribute("crossorigin", ctx.crossorigin)("aria-label", ctx.alt);
        }
      },
      dependencies: [CommonModule],
      styles: ["[_nghost-%COMP%]{display:inline-block}img[_ngcontent-%COMP%]{max-width:100%;height:auto;display:block;border-radius:4px;transition:opacity .3s ease,transform .2s ease}img[_ngcontent-%COMP%]:hover{transform:scale(1.02)}img.rounded[_ngcontent-%COMP%]{border-radius:8px}img.circle[_ngcontent-%COMP%]{border-radius:50%}img.shadow[_ngcontent-%COMP%]{box-shadow:0 2px 8px #0000001a}img.border[_ngcontent-%COMP%]{border:1px solid #e0e0e0}img.clickable[_ngcontent-%COMP%]{cursor:pointer}img.clickable[_ngcontent-%COMP%]:hover{transform:scale(1.05);box-shadow:0 4px 12px #00000026}img.loading[_ngcontent-%COMP%]{opacity:.7}img.error[_ngcontent-%COMP%]{opacity:.5;filter:grayscale(100%)}.responsive[_ngcontent-%COMP%]{width:100%;height:auto}.contain[_ngcontent-%COMP%]{object-fit:contain}.cover[_ngcontent-%COMP%]{object-fit:cover}.fill[_ngcontent-%COMP%]{object-fit:fill}.small[_ngcontent-%COMP%]{max-width:100px}.medium[_ngcontent-%COMP%]{max-width:200px}.large[_ngcontent-%COMP%]{max-width:400px}.xlarge[_ngcontent-%COMP%]{max-width:600px}.aspect-ratio-16-9[_ngcontent-%COMP%]{position:relative;width:100%;height:0;padding-bottom:56.25%}.aspect-ratio-16-9[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover}.aspect-ratio-4-3[_ngcontent-%COMP%]{position:relative;width:100%;height:0;padding-bottom:75%}.aspect-ratio-4-3[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover}.aspect-ratio-1-1[_ngcontent-%COMP%]{position:relative;width:100%;height:0;padding-bottom:100%}.aspect-ratio-1-1[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover}"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ImageComponent, [{
    type: Component,
    args: [{
      selector: "app-image",
      standalone: true,
      imports: [CommonModule],
      template: `<img 
  [src]="src" 
  [alt]="alt"
  [class]="class + (clickable ? ' clickable' : '')"
  [style]="cachedStyle"
  [loading]="loading"
  [decoding]="decoding"
  [attr.crossorigin]="crossorigin"
  (error)="onImageError($event)"
  (load)="onImageLoad($event)"
  (click)="onImageClick($event)"
  role="img"
  [attr.aria-label]="alt"> `,
      styles: [":host{display:inline-block}img{max-width:100%;height:auto;display:block;border-radius:4px;transition:opacity .3s ease,transform .2s ease}img:hover{transform:scale(1.02)}img.rounded{border-radius:8px}img.circle{border-radius:50%}img.shadow{box-shadow:0 2px 8px #0000001a}img.border{border:1px solid #e0e0e0}img.clickable{cursor:pointer}img.clickable:hover{transform:scale(1.05);box-shadow:0 4px 12px #00000026}img.loading{opacity:.7}img.error{opacity:.5;filter:grayscale(100%)}.responsive{width:100%;height:auto}.contain{object-fit:contain}.cover{object-fit:cover}.fill{object-fit:fill}.small{max-width:100px}.medium{max-width:200px}.large{max-width:400px}.xlarge{max-width:600px}.aspect-ratio-16-9{position:relative;width:100%;height:0;padding-bottom:56.25%}.aspect-ratio-16-9 img{position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover}.aspect-ratio-4-3{position:relative;width:100%;height:0;padding-bottom:75%}.aspect-ratio-4-3 img{position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover}.aspect-ratio-1-1{position:relative;width:100%;height:0;padding-bottom:100%}.aspect-ratio-1-1 img{position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover}\n"]
    }]
  }], null, {
    src: [{
      type: Input
    }],
    alt: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    class: [{
      type: Input
    }],
    style: [{
      type: Input
    }],
    loading: [{
      type: Input
    }],
    decoding: [{
      type: Input
    }],
    crossorigin: [{
      type: Input
    }],
    config: [{
      type: Input
    }],
    clickable: [{
      type: Input
    }],
    imageLoad: [{
      type: Output
    }],
    imageError: [{
      type: Output
    }],
    imageClick: [{
      type: Output
    }]
  });
})();
var UploadboxComponent = class _UploadboxComponent {
  constructor() {
    this.multiple = false;
    this.accept = "*/*";
    this.maxFileSize = 10 * 1024 * 1024;
    this.maxFiles = 5;
    this.autoUpload = true;
    this.showPreview = true;
    this.dragDropEnabled = true;
    this.placeholder = "Drop files here or click to browse";
    this.buttonText = "Choose Files";
    this.filesSelected = new EventEmitter();
    this.fileUploaded = new EventEmitter();
    this.uploadComplete = new EventEmitter();
    this.uploadError = new EventEmitter();
    this.fileRemoved = new EventEmitter();
    this.uploadedFiles = [];
    this.isDragOver = false;
    this.isUploading = false;
    this.fileMap = /* @__PURE__ */ new Map();
    this.snackBar = inject(MatSnackBar);
  }
  ngOnInit() {
  }
  onFileSelected(event) {
    const files = Array.from(event.target.files);
    this.handleFiles(files);
  }
  onDragOver(event) {
    event.preventDefault();
    event.stopPropagation();
    this.isDragOver = true;
  }
  onDragLeave(event) {
    event.preventDefault();
    event.stopPropagation();
    this.isDragOver = false;
  }
  onDrop(event) {
    event.preventDefault();
    event.stopPropagation();
    this.isDragOver = false;
    if (event.dataTransfer?.files) {
      const files = Array.from(event.dataTransfer.files);
      this.handleFiles(files);
    }
  }
  handleFiles(files) {
    if (this.uploadedFiles.length + files.length > this.maxFiles) {
      this.showError(`Maximum ${this.maxFiles} files allowed`);
      return;
    }
    const validFiles = [];
    files.forEach((file) => {
      if (this.validateFile(file)) {
        validFiles.push(file);
      }
    });
    if (validFiles.length === 0) {
      return;
    }
    this.filesSelected.emit(validFiles);
    validFiles.forEach((file) => {
      const uploadedFile = {
        id: this.generateId(),
        name: file.name,
        size: file.size,
        type: file.type,
        url: "",
        uploadedAt: /* @__PURE__ */ new Date(),
        uploadedBy: "user",
        isActive: true,
        status: "pending"
      };
      this.uploadedFiles.push(uploadedFile);
      this.fileMap.set(uploadedFile.id, file);
      if (this.autoUpload) {
        this.uploadFile(file, uploadedFile);
      }
    });
  }
  validateFile(file) {
    if (file.size > this.maxFileSize) {
      this.showError(`File ${file.name} is too large. Maximum size is ${this.formatFileSize(this.maxFileSize)}`);
      return false;
    }
    if (this.accept !== "*/*") {
      const acceptedTypes = this.accept.split(",").map((type) => type.trim());
      const isValidType = acceptedTypes.some((type) => {
        if (type.endsWith("/*")) {
          return file.type.startsWith(type.replace("/*", ""));
        }
        return file.type === type || file.name.toLowerCase().endsWith(type.replace("*", ""));
      });
      if (!isValidType) {
        this.showError(`File type not allowed for ${file.name}`);
        return false;
      }
    }
    return true;
  }
  uploadFile(file, uploadedFile) {
    return __async(this, null, function* () {
      uploadedFile.status = "uploading";
      uploadedFile.progress = 0;
      try {
        if (this.uploadUrl) {
          yield this.simulateUpload(file, uploadedFile);
        } else {
          uploadedFile.url = URL.createObjectURL(file);
          uploadedFile.status = "completed";
          uploadedFile.progress = 100;
        }
        this.fileUploaded.emit(uploadedFile);
        this.showSuccess(`File ${file.name} uploaded successfully`);
      } catch (error) {
        uploadedFile.status = "error";
        uploadedFile.error = error instanceof Error ? error.message : "Upload failed";
        this.uploadError.emit({
          file,
          error: uploadedFile.error
        });
        this.showError(`Failed to upload ${file.name}`);
      }
    });
  }
  simulateUpload(file, uploadedFile) {
    return __async(this, null, function* () {
      return new Promise((resolve, reject) => {
        let progress = 0;
        const interval2 = setInterval(() => {
          progress += Math.random() * 30;
          if (progress >= 100) {
            progress = 100;
            clearInterval(interval2);
            uploadedFile.progress = progress;
            uploadedFile.status = "completed";
            uploadedFile.url = URL.createObjectURL(file);
            resolve();
          } else {
            uploadedFile.progress = progress;
          }
        }, 200);
      });
    });
  }
  removeFile(file) {
    const index = this.uploadedFiles.findIndex((f) => f.id === file.id);
    if (index !== -1) {
      this.uploadedFiles.splice(index, 1);
      this.fileRemoved.emit(file);
      if (file.url) {
        URL.revokeObjectURL(file.url);
      }
      this.fileMap.delete(file.id);
    }
  }
  uploadAll() {
    this.uploadedFiles.filter((file) => file.status === "pending").forEach((file) => {
      const originalFile = this.getOriginalFile(file);
      if (originalFile) {
        this.uploadFile(originalFile, file);
      }
    });
  }
  getOriginalFile(uploadedFile) {
    return this.fileMap.get(uploadedFile.id) || null;
  }
  hasPendingFiles() {
    return this.uploadedFiles.some((file) => file.status === "pending");
  }
  previewFile(file) {
    if (file.url) {
      window.open(file.url, "_blank");
    }
  }
  generateId() {
    return Math.random().toString(36).substr(2, 9);
  }
  formatFileSize(bytes) {
    if (bytes === 0) return "0 Bytes";
    const k = 1024;
    const sizes = ["Bytes", "KB", "MB", "GB"];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  }
  showSuccess(message2) {
    this.snackBar.open(message2, "Close", {
      duration: 3e3,
      panelClass: ["success-snackbar"]
    });
  }
  showError(message2) {
    this.snackBar.open(message2, "Close", {
      duration: 5e3,
      panelClass: ["error-snackbar"]
    });
  }
  getFileIcon(fileType) {
    if (fileType.startsWith("image/")) return "image";
    if (fileType.startsWith("video/")) return "video_file";
    if (fileType.startsWith("audio/")) return "audio_file";
    if (fileType.includes("pdf")) return "picture_as_pdf";
    if (fileType.includes("word") || fileType.includes("document")) return "description";
    if (fileType.includes("excel") || fileType.includes("spreadsheet")) return "table_chart";
    if (fileType.includes("powerpoint") || fileType.includes("presentation")) return "slideshow";
    return "insert_drive_file";
  }
  getFileStatusColor(status) {
    switch (status) {
      case "completed":
        return "#4caf50";
      case "uploading":
        return "#2196f3";
      case "error":
        return "#f44336";
      default:
        return "#9e9e9e";
    }
  }
  static {
    this.ɵfac = function UploadboxComponent_Factory(t) {
      return new (t || _UploadboxComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _UploadboxComponent,
      selectors: [["app-uploadbox"]],
      inputs: {
        multiple: "multiple",
        accept: "accept",
        maxFileSize: "maxFileSize",
        maxFiles: "maxFiles",
        uploadUrl: "uploadUrl",
        autoUpload: "autoUpload",
        showPreview: "showPreview",
        dragDropEnabled: "dragDropEnabled",
        placeholder: "placeholder",
        buttonText: "buttonText"
      },
      outputs: {
        filesSelected: "filesSelected",
        fileUploaded: "fileUploaded",
        uploadComplete: "uploadComplete",
        uploadError: "uploadError",
        fileRemoved: "fileRemoved"
      },
      standalone: true,
      features: [ɵɵStandaloneFeature],
      decls: 13,
      vars: 13,
      consts: [["fileInput", ""], [1, "uploadbox-container"], [1, "upload-area", 3, "dragover", "dragleave", "drop", "click"], [1, "upload-content"], [1, "upload-icon", 3, "fontIcon"], [1, "upload-title"], [1, "upload-subtitle"], ["type", "button", "appearance", "raised", 1, "upload-button", 3, "btnClick", "text"], [1, "button-icon", 3, "fontIcon"], ["type", "file", 2, "display", "none", 3, "change", "multiple", "accept"], ["class", "file-list", 4, "ngIf"], [1, "file-list"], [1, "file-list-title"], [1, "file-items"], ["class", "file-item", 3, "uploading", "completed", "error", 4, "ngFor", "ngForOf"], ["class", "upload-actions", 4, "ngIf"], [1, "file-item"], [1, "file-content"], [1, "file-icon"], [1, "file-type-icon", 3, "fontIcon"], [1, "file-info"], [1, "file-name"], [1, "file-details"], [1, "file-size"], [1, "file-type"], ["class", "upload-progress", 3, "value", 4, "ngIf"], [1, "file-status"], [1, "status-indicator"], [1, "status-text"], ["class", "progress-text", 4, "ngIf"], ["class", "error-message", 4, "ngIf"], [1, "file-actions"], ["type", "button", "appearance", "icon", "fontIcon", "visibility", "class", "preview-button", 3, "btnClick", 4, "ngIf"], ["type", "button", "appearance", "icon", "fontIcon", "delete", 1, "remove-button", 3, "btnClick"], [1, "upload-progress", 3, "value"], [1, "progress-text"], [1, "error-message"], ["type", "button", "appearance", "icon", "fontIcon", "visibility", 1, "preview-button", 3, "btnClick"], [1, "upload-actions"], ["type", "button", "appearance", "raised", "text", "Upload All Files", 1, "upload-all-button", 3, "btnClick", "disabled"]],
      template: function UploadboxComponent_Template(rf, ctx) {
        if (rf & 1) {
          const _r1 = ɵɵgetCurrentView();
          ɵɵelementStart(0, "div", 1)(1, "div", 2);
          ɵɵlistener("dragover", function UploadboxComponent_Template_div_dragover_1_listener($event) {
            ɵɵrestoreView(_r1);
            return ɵɵresetView(ctx.onDragOver($event));
          })("dragleave", function UploadboxComponent_Template_div_dragleave_1_listener($event) {
            ɵɵrestoreView(_r1);
            return ɵɵresetView(ctx.onDragLeave($event));
          })("drop", function UploadboxComponent_Template_div_drop_1_listener($event) {
            ɵɵrestoreView(_r1);
            return ɵɵresetView(ctx.onDrop($event));
          })("click", function UploadboxComponent_Template_div_click_1_listener() {
            ɵɵrestoreView(_r1);
            const fileInput_r2 = ɵɵreference(11);
            return ɵɵresetView(fileInput_r2.click());
          });
          ɵɵelementStart(2, "div", 3);
          ɵɵelement(3, "app-icon", 4);
          ɵɵelementStart(4, "h3", 5);
          ɵɵtext(5);
          ɵɵelementEnd();
          ɵɵelementStart(6, "p", 6);
          ɵɵtext(7);
          ɵɵelementEnd();
          ɵɵelementStart(8, "app-button", 7);
          ɵɵlistener("btnClick", function UploadboxComponent_Template_app_button_btnClick_8_listener($event) {
            ɵɵrestoreView(_r1);
            const fileInput_r2 = ɵɵreference(11);
            fileInput_r2.click();
            return ɵɵresetView($event.stopPropagation());
          });
          ɵɵelement(9, "app-icon", 8);
          ɵɵelementEnd();
          ɵɵelementStart(10, "input", 9, 0);
          ɵɵlistener("change", function UploadboxComponent_Template_input_change_10_listener($event) {
            ɵɵrestoreView(_r1);
            return ɵɵresetView(ctx.onFileSelected($event));
          });
          ɵɵelementEnd()()();
          ɵɵtemplate(12, UploadboxComponent_div_12_Template, 6, 4, "div", 10);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵadvance();
          ɵɵclassProp("drag-over", ctx.isDragOver)("disabled", !ctx.dragDropEnabled);
          ɵɵadvance(2);
          ɵɵproperty("fontIcon", "cloud_upload");
          ɵɵadvance(2);
          ɵɵtextInterpolate(ctx.placeholder);
          ɵɵadvance(2);
          ɵɵtextInterpolate2(" Maximum file size: ", ctx.formatFileSize(ctx.maxFileSize), " | Max files: ", ctx.maxFiles, " ");
          ɵɵadvance();
          ɵɵproperty("text", ctx.buttonText);
          ɵɵadvance();
          ɵɵproperty("fontIcon", "add");
          ɵɵadvance();
          ɵɵproperty("multiple", ctx.multiple)("accept", ctx.accept);
          ɵɵadvance(2);
          ɵɵproperty("ngIf", ctx.uploadedFiles.length > 0);
        }
      },
      dependencies: [CommonModule, NgForOf, NgIf, DecimalPipe, TitleCasePipe, MatIconModule, MatButtonModule, MatProgressBarModule, MatProgressBar, MatCardModule, MatCard, MatTooltipModule, IconComponent, AppButtonComponent],
      styles: [".uploadbox-container[_ngcontent-%COMP%]{width:100%;max-width:800px;margin:0 auto}.upload-area[_ngcontent-%COMP%]{border:2px dashed #e0e0e0;border-radius:12px;padding:40px 20px;text-align:center;background:#fafafa;transition:all .3s ease;cursor:pointer;margin-bottom:20px}.upload-area[_ngcontent-%COMP%]:hover{border-color:#2196f3;background:#f3f8ff}.upload-area.drag-over[_ngcontent-%COMP%]{border-color:#2196f3;background:#e3f2fd;transform:scale(1.02)}.upload-area.disabled[_ngcontent-%COMP%]{opacity:.6;cursor:not-allowed}.upload-area.disabled[_ngcontent-%COMP%]:hover{border-color:#e0e0e0;background:#fafafa;transform:none}.upload-content[_ngcontent-%COMP%]   .upload-icon[_ngcontent-%COMP%]{font-size:48px;color:#2196f3;margin-bottom:16px}.upload-content[_ngcontent-%COMP%]   .upload-title[_ngcontent-%COMP%]{margin:0 0 8px;font-size:18px;font-weight:500;color:#333}.upload-content[_ngcontent-%COMP%]   .upload-subtitle[_ngcontent-%COMP%]{margin:0 0 24px;font-size:14px;color:#666;line-height:1.4}.upload-content[_ngcontent-%COMP%]   .upload-button[_ngcontent-%COMP%]   .button-icon[_ngcontent-%COMP%]{margin-right:8px}.file-list[_ngcontent-%COMP%]   .file-list-title[_ngcontent-%COMP%]{margin:0 0 16px;font-size:16px;font-weight:500;color:#333}.file-items[_ngcontent-%COMP%]{display:flex;flex-direction:column;gap:12px;max-height:18em;overflow-y:scroll;overflow-x:hidden;padding-right:.5em}.file-item[_ngcontent-%COMP%]{border:1px solid #e0e0e0;border-radius:8px;transition:all .3s ease}.file-item[_ngcontent-%COMP%]:hover{box-shadow:0 2px 8px #0000001a}.file-item.uploading[_ngcontent-%COMP%]{border-color:#2196f3;background:#f3f8ff}.file-item.completed[_ngcontent-%COMP%]{border-color:#4caf50;background:#f1f8e9}.file-item.error[_ngcontent-%COMP%]{border-color:#f44336;background:#ffebee}.file-content[_ngcontent-%COMP%]{display:flex;align-items:center;gap:16px;padding:16px}.file-icon[_ngcontent-%COMP%]{flex-shrink:0;width:48px;height:48px;border-radius:8px;background:#f5f5f5;display:flex;align-items:center;justify-content:center}.file-icon[_ngcontent-%COMP%]   .file-type-icon[_ngcontent-%COMP%]{font-size:24px;color:#666}.file-info[_ngcontent-%COMP%]{flex:1;min-width:0}.file-info[_ngcontent-%COMP%]   .file-name[_ngcontent-%COMP%]{font-size:14px;font-weight:500;color:#333;margin-bottom:4px;word-break:break-word}.file-info[_ngcontent-%COMP%]   .file-details[_ngcontent-%COMP%]{display:flex;gap:16px;margin-bottom:8px}.file-info[_ngcontent-%COMP%]   .file-details[_ngcontent-%COMP%]   .file-size[_ngcontent-%COMP%], .file-info[_ngcontent-%COMP%]   .file-details[_ngcontent-%COMP%]   .file-type[_ngcontent-%COMP%]{font-size:12px;color:#666}.file-info[_ngcontent-%COMP%]   .upload-progress[_ngcontent-%COMP%]{margin-bottom:8px}.file-info[_ngcontent-%COMP%]   .file-status[_ngcontent-%COMP%]{display:flex;align-items:center;gap:8px}.file-info[_ngcontent-%COMP%]   .file-status[_ngcontent-%COMP%]   .status-indicator[_ngcontent-%COMP%]{width:8px;height:8px;border-radius:50%}.file-info[_ngcontent-%COMP%]   .file-status[_ngcontent-%COMP%]   .status-text[_ngcontent-%COMP%]{font-size:12px;font-weight:500;color:#666}.file-info[_ngcontent-%COMP%]   .file-status[_ngcontent-%COMP%]   .progress-text[_ngcontent-%COMP%]{font-size:12px;color:#2196f3;font-weight:500}.file-info[_ngcontent-%COMP%]   .error-message[_ngcontent-%COMP%]{font-size:12px;color:#f44336;margin-top:4px}.file-actions[_ngcontent-%COMP%]{display:flex;gap:8px;flex-shrink:0}.file-actions[_ngcontent-%COMP%]   .preview-button[_ngcontent-%COMP%], .file-actions[_ngcontent-%COMP%]   .remove-button[_ngcontent-%COMP%]{width:32px;height:32px;line-height:32px}.file-actions[_ngcontent-%COMP%]   .preview-button[_ngcontent-%COMP%]     .mat-icon, .file-actions[_ngcontent-%COMP%]   .remove-button[_ngcontent-%COMP%]     .mat-icon{font-size:18px}.file-actions[_ngcontent-%COMP%]   .preview-button[_ngcontent-%COMP%]{color:#2196f3}.file-actions[_ngcontent-%COMP%]   .remove-button[_ngcontent-%COMP%]{color:#f44336}.upload-actions[_ngcontent-%COMP%]{margin-top:20px;text-align:center}.upload-actions[_ngcontent-%COMP%]   .button-icon[_ngcontent-%COMP%]{margin-right:8px}@media (max-width: 768px){.uploadbox-container[_ngcontent-%COMP%]{padding:0 16px}.upload-area[_ngcontent-%COMP%]{padding:24px 16px}.upload-area[_ngcontent-%COMP%]   .upload-content[_ngcontent-%COMP%]   .upload-icon[_ngcontent-%COMP%]{font-size:36px}.upload-area[_ngcontent-%COMP%]   .upload-content[_ngcontent-%COMP%]   .upload-title[_ngcontent-%COMP%]{font-size:16px}.upload-area[_ngcontent-%COMP%]   .upload-content[_ngcontent-%COMP%]   .upload-subtitle[_ngcontent-%COMP%]{font-size:13px}.file-content[_ngcontent-%COMP%]{padding:12px;gap:12px}.file-icon[_ngcontent-%COMP%]{width:40px;height:40px}.file-icon[_ngcontent-%COMP%]   .file-type-icon[_ngcontent-%COMP%]{font-size:20px}.file-info[_ngcontent-%COMP%]   .file-name[_ngcontent-%COMP%]{font-size:13px}.file-info[_ngcontent-%COMP%]   .file-details[_ngcontent-%COMP%]{font-size:11px}.file-actions[_ngcontent-%COMP%]   .preview-button[_ngcontent-%COMP%], .file-actions[_ngcontent-%COMP%]   .remove-button[_ngcontent-%COMP%]{width:28px;height:28px;line-height:28px}.file-actions[_ngcontent-%COMP%]   .preview-button[_ngcontent-%COMP%]     .mat-icon, .file-actions[_ngcontent-%COMP%]   .remove-button[_ngcontent-%COMP%]     .mat-icon{font-size:16px}}@media (prefers-color-scheme: dark){.upload-area[_ngcontent-%COMP%]{border-color:#424242;background:#1e1e1e}.upload-area[_ngcontent-%COMP%]:hover{border-color:#64b5f6;background:#1a237e}.upload-area.drag-over[_ngcontent-%COMP%]{border-color:#64b5f6;background:#0d47a1}.upload-content[_ngcontent-%COMP%]   .upload-icon[_ngcontent-%COMP%]{color:#64b5f6}.upload-content[_ngcontent-%COMP%]   .upload-title[_ngcontent-%COMP%]{color:#fff}.upload-content[_ngcontent-%COMP%]   .upload-subtitle[_ngcontent-%COMP%]{color:#b0b0b0}.file-list-title[_ngcontent-%COMP%]{color:#fff}.file-item[_ngcontent-%COMP%]{border-color:#424242;background:#1e1e1e}.file-item.uploading[_ngcontent-%COMP%]{border-color:#64b5f6;background:#1a237e}.file-item.completed[_ngcontent-%COMP%]{border-color:#66bb6a;background:#1b5e20}.file-item.error[_ngcontent-%COMP%]{border-color:#ef5350;background:#b71c1c}.file-icon[_ngcontent-%COMP%]{background:#2d2d2d}.file-icon[_ngcontent-%COMP%]   .file-type-icon[_ngcontent-%COMP%]{color:#b0b0b0}.file-info[_ngcontent-%COMP%]   .file-name[_ngcontent-%COMP%]{color:#fff}.file-info[_ngcontent-%COMP%]   .file-details[_ngcontent-%COMP%]   .file-size[_ngcontent-%COMP%], .file-info[_ngcontent-%COMP%]   .file-details[_ngcontent-%COMP%]   .file-type[_ngcontent-%COMP%], .file-info[_ngcontent-%COMP%]   .file-status[_ngcontent-%COMP%]   .status-text[_ngcontent-%COMP%]{color:#b0b0b0}.file-info[_ngcontent-%COMP%]   .file-status[_ngcontent-%COMP%]   .progress-text[_ngcontent-%COMP%]{color:#64b5f6}.file-info[_ngcontent-%COMP%]   .error-message[_ngcontent-%COMP%]{color:#ef5350}}"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UploadboxComponent, [{
    type: Component,
    args: [{
      selector: "app-uploadbox",
      standalone: true,
      imports: [CommonModule, MatIconModule, MatButtonModule, MatProgressBarModule, MatCardModule, MatTooltipModule, IconComponent, AppButtonComponent],
      template: `<div class="uploadbox-container">
  <!-- Drag and Drop Area -->
  <div 
    class="upload-area"
    [class.drag-over]="isDragOver"
    [class.disabled]="!dragDropEnabled"
    (dragover)="onDragOver($event)"
    (dragleave)="onDragLeave($event)"
    (drop)="onDrop($event)"
    (click)="fileInput.click()">
    
    <div class="upload-content">
      <app-icon 
        [fontIcon]="'cloud_upload'" 
        class="upload-icon">
      </app-icon>
      
      <h3 class="upload-title">{{ placeholder }}</h3>
      
      <p class="upload-subtitle">
        Maximum file size: {{ formatFileSize(maxFileSize) }} | 
        Max files: {{ maxFiles }}
      </p>
      
      <app-button
        type="button"
        appearance="raised"
        [text]="buttonText"
        (btnClick)="fileInput.click(); $event.stopPropagation()"
        class="upload-button">
        <app-icon [fontIcon]="'add'" class="button-icon"></app-icon>
      </app-button>
      
      <input 
        #fileInput
        type="file"
        [multiple]="multiple"
        [accept]="accept"
        (change)="onFileSelected($event)"
        style="display: none;">
    </div>
  </div>

  <!-- File List -->
  <div class="file-list" *ngIf="uploadedFiles.length > 0">
    <h4 class="file-list-title">Uploaded Files ({{ uploadedFiles.length }}/{{ maxFiles }})</h4>
    
    <div class="file-items">
      <mat-card 
        *ngFor="let file of uploadedFiles" 
        class="file-item"
        [class.uploading]="file.status === 'uploading'"
        [class.completed]="file.status === 'completed'"
        [class.error]="file.status === 'error'">
        
        <div class="file-content">
          <!-- File Icon -->
          <div class="file-icon">
            <app-icon 
              [fontIcon]="getFileIcon(file.type)" 
              class="file-type-icon">
            </app-icon>
          </div>
          
          <!-- File Info -->
          <div class="file-info">
            <div class="file-name">{{ file.name }}</div>
            <div class="file-details">
              <span class="file-size">{{ formatFileSize(file.size) }}</span>
              <span class="file-type">{{ file.type }}</span>
            </div>
            
            <!-- Progress Bar -->
            <mat-progress-bar 
              *ngIf="file.status === 'uploading'"
              [value]="file.progress || 0"
              class="upload-progress">
            </mat-progress-bar>
            
            <!-- Status -->
            <div class="file-status">
              <span 
                class="status-indicator"
                [style.background-color]="getFileStatusColor(file.status)">
              </span>
              <span class="status-text">{{ file.status | titlecase }}</span>
              <span *ngIf="file.progress && file.status === 'uploading'" class="progress-text">
                {{ file.progress | number:'1.0-0' }}%
              </span>
            </div>
            
            <!-- Error Message -->
            <div *ngIf="file.error" class="error-message">
              {{ file.error }}
            </div>
          </div>
          
          <!-- Actions -->
          <div class="file-actions">
            <!-- Preview Button -->
            <app-button
              *ngIf="showPreview && file.url && file.status === 'completed'"
              type="button"
              appearance="icon"
              fontIcon="visibility"
              (btnClick)="previewFile(file)"
              class="preview-button">
            </app-button>
            
            <!-- Remove Button -->
            <app-button
              type="button"
              appearance="icon"
              fontIcon="delete"
              (btnClick)="removeFile(file)"
              class="remove-button">
            </app-button>
          </div>
        </div>
      </mat-card>
    </div>
    
    <!-- Upload All Button -->
    <div class="upload-actions" *ngIf="hasPendingFiles()">
      <app-button
        type="button"
        appearance="raised"
        text="Upload All Files"
        [disabled]="isUploading"
        (btnClick)="uploadAll()"
        class="upload-all-button">
        <app-icon [fontIcon]="'cloud_upload'" class="button-icon"></app-icon>
      </app-button>
    </div>
  </div>
</div> `,
      styles: [".uploadbox-container{width:100%;max-width:800px;margin:0 auto}.upload-area{border:2px dashed #e0e0e0;border-radius:12px;padding:40px 20px;text-align:center;background:#fafafa;transition:all .3s ease;cursor:pointer;margin-bottom:20px}.upload-area:hover{border-color:#2196f3;background:#f3f8ff}.upload-area.drag-over{border-color:#2196f3;background:#e3f2fd;transform:scale(1.02)}.upload-area.disabled{opacity:.6;cursor:not-allowed}.upload-area.disabled:hover{border-color:#e0e0e0;background:#fafafa;transform:none}.upload-content .upload-icon{font-size:48px;color:#2196f3;margin-bottom:16px}.upload-content .upload-title{margin:0 0 8px;font-size:18px;font-weight:500;color:#333}.upload-content .upload-subtitle{margin:0 0 24px;font-size:14px;color:#666;line-height:1.4}.upload-content .upload-button .button-icon{margin-right:8px}.file-list .file-list-title{margin:0 0 16px;font-size:16px;font-weight:500;color:#333}.file-items{display:flex;flex-direction:column;gap:12px;max-height:18em;overflow-y:scroll;overflow-x:hidden;padding-right:.5em}.file-item{border:1px solid #e0e0e0;border-radius:8px;transition:all .3s ease}.file-item:hover{box-shadow:0 2px 8px #0000001a}.file-item.uploading{border-color:#2196f3;background:#f3f8ff}.file-item.completed{border-color:#4caf50;background:#f1f8e9}.file-item.error{border-color:#f44336;background:#ffebee}.file-content{display:flex;align-items:center;gap:16px;padding:16px}.file-icon{flex-shrink:0;width:48px;height:48px;border-radius:8px;background:#f5f5f5;display:flex;align-items:center;justify-content:center}.file-icon .file-type-icon{font-size:24px;color:#666}.file-info{flex:1;min-width:0}.file-info .file-name{font-size:14px;font-weight:500;color:#333;margin-bottom:4px;word-break:break-word}.file-info .file-details{display:flex;gap:16px;margin-bottom:8px}.file-info .file-details .file-size,.file-info .file-details .file-type{font-size:12px;color:#666}.file-info .upload-progress{margin-bottom:8px}.file-info .file-status{display:flex;align-items:center;gap:8px}.file-info .file-status .status-indicator{width:8px;height:8px;border-radius:50%}.file-info .file-status .status-text{font-size:12px;font-weight:500;color:#666}.file-info .file-status .progress-text{font-size:12px;color:#2196f3;font-weight:500}.file-info .error-message{font-size:12px;color:#f44336;margin-top:4px}.file-actions{display:flex;gap:8px;flex-shrink:0}.file-actions .preview-button,.file-actions .remove-button{width:32px;height:32px;line-height:32px}.file-actions .preview-button ::ng-deep .mat-icon,.file-actions .remove-button ::ng-deep .mat-icon{font-size:18px}.file-actions .preview-button{color:#2196f3}.file-actions .remove-button{color:#f44336}.upload-actions{margin-top:20px;text-align:center}.upload-actions .button-icon{margin-right:8px}@media (max-width: 768px){.uploadbox-container{padding:0 16px}.upload-area{padding:24px 16px}.upload-area .upload-content .upload-icon{font-size:36px}.upload-area .upload-content .upload-title{font-size:16px}.upload-area .upload-content .upload-subtitle{font-size:13px}.file-content{padding:12px;gap:12px}.file-icon{width:40px;height:40px}.file-icon .file-type-icon{font-size:20px}.file-info .file-name{font-size:13px}.file-info .file-details{font-size:11px}.file-actions .preview-button,.file-actions .remove-button{width:28px;height:28px;line-height:28px}.file-actions .preview-button ::ng-deep .mat-icon,.file-actions .remove-button ::ng-deep .mat-icon{font-size:16px}}@media (prefers-color-scheme: dark){.upload-area{border-color:#424242;background:#1e1e1e}.upload-area:hover{border-color:#64b5f6;background:#1a237e}.upload-area.drag-over{border-color:#64b5f6;background:#0d47a1}.upload-content .upload-icon{color:#64b5f6}.upload-content .upload-title{color:#fff}.upload-content .upload-subtitle{color:#b0b0b0}.file-list-title{color:#fff}.file-item{border-color:#424242;background:#1e1e1e}.file-item.uploading{border-color:#64b5f6;background:#1a237e}.file-item.completed{border-color:#66bb6a;background:#1b5e20}.file-item.error{border-color:#ef5350;background:#b71c1c}.file-icon{background:#2d2d2d}.file-icon .file-type-icon{color:#b0b0b0}.file-info .file-name{color:#fff}.file-info .file-details .file-size,.file-info .file-details .file-type,.file-info .file-status .status-text{color:#b0b0b0}.file-info .file-status .progress-text{color:#64b5f6}.file-info .error-message{color:#ef5350}}\n"]
    }]
  }], null, {
    multiple: [{
      type: Input
    }],
    accept: [{
      type: Input
    }],
    maxFileSize: [{
      type: Input
    }],
    maxFiles: [{
      type: Input
    }],
    uploadUrl: [{
      type: Input
    }],
    autoUpload: [{
      type: Input
    }],
    showPreview: [{
      type: Input
    }],
    dragDropEnabled: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    buttonText: [{
      type: Input
    }],
    filesSelected: [{
      type: Output
    }],
    fileUploaded: [{
      type: Output
    }],
    uploadComplete: [{
      type: Output
    }],
    uploadError: [{
      type: Output
    }],
    fileRemoved: [{
      type: Output
    }]
  });
})();
var PageBodyDirective = class _PageBodyDirective {
  static {
    this.ɵfac = function PageBodyDirective_Factory(t) {
      return new (t || _PageBodyDirective)();
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _PageBodyDirective,
      selectors: [["", "page-body", ""]],
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PageBodyDirective, [{
    type: Directive,
    args: [{
      selector: "[page-body]",
      standalone: true
    }]
  }], null, null);
})();
var FooterDirective = class _FooterDirective {
  static {
    this.ɵfac = function FooterDirective_Factory(t) {
      return new (t || _FooterDirective)();
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _FooterDirective,
      selectors: [["", "footer", ""]],
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FooterDirective, [{
    type: Directive,
    args: [{
      selector: "[footer]",
      standalone: true
    }]
  }], null, null);
})();
var PageComponent = class _PageComponent {
  constructor(coreEvent) {
    this.coreEvent = coreEvent;
    this.breadcrumb = null;
    this.isFooter = false;
  }
  ngOnChanges(changes) {
    if ("breadcrumb" in changes) {
      this.syncBreadcrumb();
    }
  }
  ngOnDestroy() {
    this.coreEvent.clearBreadcrumb();
  }
  syncBreadcrumb() {
    if (this.breadcrumb && this.breadcrumb.length > 0) {
      this.coreEvent.setBreadcrumb(this.breadcrumb);
    } else {
      this.coreEvent.clearBreadcrumb();
    }
  }
  static {
    this.ɵfac = function PageComponent_Factory(t) {
      return new (t || _PageComponent)(ɵɵdirectiveInject(CoreEventService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _PageComponent,
      selectors: [["app-page"]],
      contentQueries: function PageComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          ɵɵcontentQuery(dirIndex, _c52, 5);
          ɵɵcontentQuery(dirIndex, _c62, 5);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.pageBodyTemplate = _t.first);
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
        }
      },
      inputs: {
        breadcrumb: "breadcrumb",
        isFooter: "isFooter"
      },
      standalone: true,
      features: [ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
      ngContentSelectors: _c82,
      decls: 5,
      vars: 3,
      consts: [[1, "page-container"], [1, "page-body"], [1, "page-footer"], [4, "ngTemplateOutlet"]],
      template: function PageComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef(_c72);
          ɵɵelementStart(0, "div", 0)(1, "div", 1);
          ɵɵtemplate(2, PageComponent_Conditional_2_Template, 1, 1, "ng-container")(3, PageComponent_Conditional_3_Template, 1, 0);
          ɵɵelementEnd();
          ɵɵtemplate(4, PageComponent_Conditional_4_Template, 3, 2, "div", 2);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵadvance();
          ɵɵattribute("page-body", true);
          ɵɵadvance();
          ɵɵconditional(2, ctx.pageBodyTemplate ? 2 : 3);
          ɵɵadvance(2);
          ɵɵconditional(4, ctx.isFooter ? 4 : -1);
        }
      },
      dependencies: [CommonModule, NgTemplateOutlet, MatIconModule, MatButtonModule, RouterModule],
      styles: [".page-container[_ngcontent-%COMP%]{display:flex;flex-direction:column;height:100%;width:100%}.breadcrumb-nav[_ngcontent-%COMP%]{padding:12px 16px;background-color:#f5f5f5;border-bottom:1px solid #e0e0e0}.breadcrumb-list[_ngcontent-%COMP%]{display:flex;align-items:center;list-style:none;margin:0;padding:0;flex-wrap:wrap;gap:4px}.breadcrumb-item[_ngcontent-%COMP%]{display:flex;align-items:center;gap:4px}.breadcrumb-link[_ngcontent-%COMP%]{display:flex;align-items:center;gap:4px;color:#1976d2;text-decoration:none;font-size:14px;transition:color .2s}.breadcrumb-link[_ngcontent-%COMP%]:hover{color:#1565c0;text-decoration:underline}.breadcrumb-current[_ngcontent-%COMP%]{display:flex;align-items:center;gap:4px;color:#424242;font-size:14px;font-weight:500}.breadcrumb-icon[_ngcontent-%COMP%]{font-size:16px;width:16px;height:16px}.breadcrumb-separator[_ngcontent-%COMP%]{margin:0 8px;color:#9e9e9e;font-size:14px}.page-body[_ngcontent-%COMP%]{flex:1;overflow-y:auto}.page-footer[_ngcontent-%COMP%]{padding:16px;background-color:#fafafa;border-top:1px solid #e0e0e0}"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PageComponent, [{
    type: Component,
    args: [{
      selector: "app-page",
      standalone: true,
      imports: [CommonModule, MatIconModule, MatButtonModule, RouterModule, IconComponent, PageBodyDirective, FooterDirective],
      template: '<div class="page-container">\n  <!-- Page Body Content -->\n  <div class="page-body" [attr.page-body]="true">\n    @if (pageBodyTemplate) {\n      <ng-container *ngTemplateOutlet="pageBodyTemplate"></ng-container>\n    } @else {\n      <ng-content select="[page-body]"></ng-content>\n    }\n  </div>\n\n  <!-- Footer Content -->\n  @if (isFooter) {\n    <div class="page-footer" [attr.footer]="true">\n      @if (footerTemplate) {\n        <ng-container *ngTemplateOutlet="footerTemplate"></ng-container>\n      } @else {\n        <ng-content select="[footer]"></ng-content>\n      }\n    </div>\n  }\n</div>\n\n',
      styles: [".page-container{display:flex;flex-direction:column;height:100%;width:100%}.breadcrumb-nav{padding:12px 16px;background-color:#f5f5f5;border-bottom:1px solid #e0e0e0}.breadcrumb-list{display:flex;align-items:center;list-style:none;margin:0;padding:0;flex-wrap:wrap;gap:4px}.breadcrumb-item{display:flex;align-items:center;gap:4px}.breadcrumb-link{display:flex;align-items:center;gap:4px;color:#1976d2;text-decoration:none;font-size:14px;transition:color .2s}.breadcrumb-link:hover{color:#1565c0;text-decoration:underline}.breadcrumb-current{display:flex;align-items:center;gap:4px;color:#424242;font-size:14px;font-weight:500}.breadcrumb-icon{font-size:16px;width:16px;height:16px}.breadcrumb-separator{margin:0 8px;color:#9e9e9e;font-size:14px}.page-body{flex:1;overflow-y:auto}.page-footer{padding:16px;background-color:#fafafa;border-top:1px solid #e0e0e0}\n"]
    }]
  }], () => [{
    type: CoreEventService
  }], {
    breadcrumb: [{
      type: Input
    }],
    isFooter: [{
      type: Input
    }],
    pageBodyTemplate: [{
      type: ContentChild,
      args: ["pageBody"]
    }],
    footerTemplate: [{
      type: ContentChild,
      args: ["footer"]
    }]
  });
})();
var GridListFiltersComponent = class _GridListFiltersComponent {
  constructor() {
    this.fields = [];
    this.operators = [];
    this.operatorsMap = {};
    this.valuesMap = {};
    this.title = "Filter Data";
    this.buttonText = "Filter";
    this.buttonIcon = "filter_list";
    this.filtersApplied = new EventEmitter();
    this.filtersCleared = new EventEmitter();
    this.dialog = inject(MatDialog);
    this.dialogboxService = inject(DialogboxService);
    this.appliedFiltersCount = 0;
  }
  openFiltersDialog() {
    const dialogRef = this.dialogboxService.openDialog(FilterComponent, {
      title: this.title,
      width: "600px",
      data: {
        fields: this.fields,
        operators: this.operators,
        operatorsMap: this.operatorsMap,
        valuesMap: this.valuesMap,
        title: this.title
      }
    });
    dialogRef.afterClosed().subscribe((result) => {
      if (result && result.filters) {
        this.appliedFiltersCount = result.filters.length;
        this.filtersApplied.emit(result.filters);
      }
    });
  }
  clearFilters() {
    this.appliedFiltersCount = 0;
    this.filtersCleared.emit();
  }
  static {
    this.ɵfac = function GridListFiltersComponent_Factory(t) {
      return new (t || _GridListFiltersComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _GridListFiltersComponent,
      selectors: [["app-grid-list-filters"]],
      inputs: {
        fields: "fields",
        operators: "operators",
        operatorsMap: "operatorsMap",
        valuesMap: "valuesMap",
        title: "title",
        buttonText: "buttonText",
        buttonIcon: "buttonIcon"
      },
      outputs: {
        filtersApplied: "filtersApplied",
        filtersCleared: "filtersCleared"
      },
      standalone: true,
      features: [ɵɵStandaloneFeature],
      decls: 3,
      vars: 5,
      consts: [[1, "grid-filters-container"], ["appearance", "raised", "color", "primary", 3, "btnClick", "text", "fontIcon"], [1, "filter-badge"], ["text", "Clear", "fontIcon", "clear", "appearance", "flat", "color", "warn", 3, "btnClick"]],
      template: function GridListFiltersComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "div", 0)(1, "app-button", 1);
          ɵɵlistener("btnClick", function GridListFiltersComponent_Template_app_button_btnClick_1_listener() {
            return ctx.openFiltersDialog();
          });
          ɵɵelementEnd();
          ɵɵtemplate(2, GridListFiltersComponent_Conditional_2_Template, 3, 3);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵadvance();
          ɵɵclassMap("filter-button");
          ɵɵproperty("text", ctx.buttonText)("fontIcon", ctx.buttonIcon);
          ɵɵadvance();
          ɵɵconditional(2, ctx.appliedFiltersCount > 0 ? 2 : -1);
        }
      },
      dependencies: [CommonModule, MatButtonModule, MatIconModule, AppButtonComponent],
      styles: [".grid-filters-container[_ngcontent-%COMP%]{display:flex;align-items:center;gap:8px}.filter-button[_ngcontent-%COMP%]{margin-right:8px}.filter-badge[_ngcontent-%COMP%]{display:inline-flex;align-items:center;justify-content:center;min-width:20px;height:20px;padding:0 6px;background-color:#f44336;color:#fff;border-radius:10px;font-size:12px;font-weight:500}.clear-button[_ngcontent-%COMP%]{margin-left:4px}"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridListFiltersComponent, [{
    type: Component,
    args: [{
      selector: "app-grid-list-filters",
      standalone: true,
      imports: [CommonModule, MatButtonModule, MatIconModule, AppButtonComponent],
      template: `<div class="grid-filters-container">
  <app-button
    [text]="buttonText"
    [fontIcon]="buttonIcon"
    appearance="raised"
    color="primary"
    (btnClick)="openFiltersDialog()"
    [class]="'filter-button'"
  ></app-button>
  
  @if (appliedFiltersCount > 0) {
    <span class="filter-badge">{{ appliedFiltersCount }}</span>
    <app-button
      text="Clear"
      fontIcon="clear"
      appearance="flat"
      color="warn"
      (btnClick)="clearFilters()"
      [class]="'clear-button'"
    ></app-button>
  }
</div>

`,
      styles: [".grid-filters-container{display:flex;align-items:center;gap:8px}.filter-button{margin-right:8px}.filter-badge{display:inline-flex;align-items:center;justify-content:center;min-width:20px;height:20px;padding:0 6px;background-color:#f44336;color:#fff;border-radius:10px;font-size:12px;font-weight:500}.clear-button{margin-left:4px}\n"]
    }]
  }], null, {
    fields: [{
      type: Input
    }],
    operators: [{
      type: Input
    }],
    operatorsMap: [{
      type: Input
    }],
    valuesMap: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    buttonText: [{
      type: Input
    }],
    buttonIcon: [{
      type: Input
    }],
    filtersApplied: [{
      type: Output
    }],
    filtersCleared: [{
      type: Output
    }]
  });
})();
var DividerComponent = class _DividerComponent {
  constructor() {
    this.vertical = false;
    this.spacing = "medium";
    this.color = "#e0e0e0";
    this.thickness = "1px";
    this.margin = "16px 0";
  }
  static {
    this.ɵfac = function DividerComponent_Factory(t) {
      return new (t || _DividerComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _DividerComponent,
      selectors: [["app-divider"]],
      inputs: {
        vertical: "vertical",
        spacing: "spacing",
        color: "color",
        thickness: "thickness",
        margin: "margin"
      },
      standalone: true,
      features: [ɵɵStandaloneFeature],
      decls: 1,
      vars: 16,
      consts: [[1, "divider"]],
      template: function DividerComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelement(0, "div", 0);
        }
        if (rf & 2) {
          ɵɵstyleProp("border-color", ctx.color)("border-width", ctx.thickness)("margin", ctx.margin);
          ɵɵclassProp("vertical", ctx.vertical)("horizontal", !ctx.vertical)("spacing-small", ctx.spacing === "small")("spacing-medium", ctx.spacing === "medium")("spacing-large", ctx.spacing === "large");
        }
      },
      dependencies: [CommonModule],
      styles: [".divider[_ngcontent-%COMP%]{display:block;border:none}.divider.horizontal[_ngcontent-%COMP%]{width:100%;border-top:1px solid #e0e0e0;margin:16px 0}.divider.vertical[_ngcontent-%COMP%]{width:1px;height:100%;border-left:1px solid #e0e0e0;margin:0 16px;display:inline-block}.spacing-small.horizontal[_ngcontent-%COMP%]{margin:8px 0}.spacing-small.vertical[_ngcontent-%COMP%]{margin:0 8px}.spacing-medium.horizontal[_ngcontent-%COMP%]{margin:16px 0}.spacing-medium.vertical[_ngcontent-%COMP%]{margin:0 16px}.spacing-large.horizontal[_ngcontent-%COMP%]{margin:24px 0}.spacing-large.vertical[_ngcontent-%COMP%]{margin:0 24px}"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DividerComponent, [{
    type: Component,
    args: [{
      selector: "app-divider",
      standalone: true,
      imports: [CommonModule],
      template: `<div 
  class="divider" 
  [class.vertical]="vertical"
  [class.horizontal]="!vertical"
  [class.spacing-small]="spacing === 'small'"
  [class.spacing-medium]="spacing === 'medium'"
  [class.spacing-large]="spacing === 'large'"
  [style.border-color]="color"
  [style.border-width]="thickness"
  [style.margin]="margin"
></div>

`,
      styles: [".divider{display:block;border:none}.divider.horizontal{width:100%;border-top:1px solid #e0e0e0;margin:16px 0}.divider.vertical{width:1px;height:100%;border-left:1px solid #e0e0e0;margin:0 16px;display:inline-block}.spacing-small.horizontal{margin:8px 0}.spacing-small.vertical{margin:0 8px}.spacing-medium.horizontal{margin:16px 0}.spacing-medium.vertical{margin:0 16px}.spacing-large.horizontal{margin:24px 0}.spacing-large.vertical{margin:0 24px}\n"]
    }]
  }], null, {
    vertical: [{
      type: Input
    }],
    spacing: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    thickness: [{
      type: Input
    }],
    margin: [{
      type: Input
    }]
  });
})();
var LoaderComponent = class _LoaderComponent {
  constructor() {
    this.type = "spinner";
    this.mode = "indeterminate";
    this.value = 0;
    this.diameter = 50;
    this.strokeWidth = 4;
    this.color = "primary";
    this.message = "";
    this.overlay = false;
    this.fullScreen = false;
  }
  static {
    this.ɵfac = function LoaderComponent_Factory(t) {
      return new (t || _LoaderComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _LoaderComponent,
      selectors: [["app-loader"]],
      inputs: {
        type: "type",
        mode: "mode",
        value: "value",
        diameter: "diameter",
        strokeWidth: "strokeWidth",
        color: "color",
        message: "message",
        overlay: "overlay",
        fullScreen: "fullScreen"
      },
      standalone: true,
      features: [ɵɵStandaloneFeature],
      decls: 2,
      vars: 1,
      consts: [[1, "loader-overlay", 3, "full-screen"], [1, "loader-overlay"], [1, "loader-content"], [3, "diameter", "strokeWidth", "color", "mode", "value"], [1, "loader-message"], [3, "mode", "value", "color"], [1, "loader-inline"]],
      template: function LoaderComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵtemplate(0, LoaderComponent_Conditional_0_Template, 5, 4, "div", 0)(1, LoaderComponent_Conditional_1_Template, 4, 2);
        }
        if (rf & 2) {
          ɵɵconditional(0, ctx.overlay || ctx.fullScreen ? 0 : 1);
        }
      },
      dependencies: [CommonModule, MatProgressSpinnerModule, MatProgressSpinner, MatProgressBarModule, MatProgressBar],
      styles: [".loader-overlay[_ngcontent-%COMP%]{position:absolute;inset:0;background-color:#fffc;display:flex;align-items:center;justify-content:center;z-index:1000}.loader-overlay.full-screen[_ngcontent-%COMP%]{position:fixed;inset:0;background-color:#00000080}.loader-content[_ngcontent-%COMP%]{display:flex;flex-direction:column;align-items:center;gap:16px}.loader-inline[_ngcontent-%COMP%]{display:flex;flex-direction:column;align-items:center;gap:16px;padding:16px}.loader-message[_ngcontent-%COMP%]{margin:0;color:#424242;font-size:14px;text-align:center}.loader-overlay.full-screen[_ngcontent-%COMP%]   .loader-message[_ngcontent-%COMP%]{color:#fff}"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LoaderComponent, [{
    type: Component,
    args: [{
      selector: "app-loader",
      standalone: true,
      imports: [CommonModule, MatProgressSpinnerModule, MatProgressBarModule],
      template: `@if (overlay || fullScreen) {
  <div class="loader-overlay" [class.full-screen]="fullScreen">
    <div class="loader-content">
      @if (type === 'spinner' || type === 'circular') {
        <mat-spinner
          [diameter]="diameter"
          [strokeWidth]="strokeWidth"
          [color]="color"
          [mode]="mode"
          [value]="value"
        ></mat-spinner>
      } @else if (type === 'bar') {
        <mat-progress-bar
          [mode]="mode"
          [value]="value"
          [color]="color"
        ></mat-progress-bar>
      }
      @if (message) {
        <p class="loader-message">{{ message }}</p>
      }
    </div>
  </div>
} @else {
  <div class="loader-inline">
    @if (type === 'spinner' || type === 'circular') {
      <mat-spinner
        [diameter]="diameter"
        [strokeWidth]="strokeWidth"
        [color]="color"
        [mode]="mode"
        [value]="value"
      ></mat-spinner>
    } @else if (type === 'bar') {
      <mat-progress-bar
        [mode]="mode"
        [value]="value"
        [color]="color"
      ></mat-progress-bar>
    }
    @if (message) {
      <p class="loader-message">{{ message }}</p>
    }
  </div>
}

`,
      styles: [".loader-overlay{position:absolute;inset:0;background-color:#fffc;display:flex;align-items:center;justify-content:center;z-index:1000}.loader-overlay.full-screen{position:fixed;inset:0;background-color:#00000080}.loader-content{display:flex;flex-direction:column;align-items:center;gap:16px}.loader-inline{display:flex;flex-direction:column;align-items:center;gap:16px;padding:16px}.loader-message{margin:0;color:#424242;font-size:14px;text-align:center}.loader-overlay.full-screen .loader-message{color:#fff}\n"]
    }]
  }], null, {
    type: [{
      type: Input
    }],
    mode: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    diameter: [{
      type: Input
    }],
    strokeWidth: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    message: [{
      type: Input
    }],
    overlay: [{
      type: Input
    }],
    fullScreen: [{
      type: Input
    }]
  });
})();
var JsonReflectComponent = class _JsonReflectComponent {
  constructor() {
    this.json = {};
    this.editable = true;
    this.showControls = true;
    this.height = "400px";
    this.jsonChange = new EventEmitter();
    this.save = new EventEmitter();
    this.cancel = new EventEmitter();
    this.jsonString = "";
    this.isEditing = false;
    this.errorMessage = "";
  }
  ngOnInit() {
    this.updateJsonString();
  }
  ngOnChanges(changes) {
    if (changes["json"] && !this.isEditing) {
      this.updateJsonString();
    }
  }
  updateJsonString() {
    try {
      this.jsonString = JSON.stringify(this.json, null, 2);
      this.errorMessage = "";
    } catch (error) {
      this.jsonString = "";
      this.errorMessage = "Invalid JSON";
    }
  }
  toggleEdit() {
    if (this.editable) {
      this.isEditing = !this.isEditing;
      if (!this.isEditing) {
        this.updateJsonString();
      }
    }
  }
  onJsonChange() {
    try {
      const parsed = JSON.parse(this.jsonString);
      this.json = parsed;
      this.errorMessage = "";
      this.jsonChange.emit(parsed);
    } catch (error) {
      this.errorMessage = "Invalid JSON format";
    }
  }
  onSave() {
    try {
      const parsed = JSON.parse(this.jsonString);
      this.json = parsed;
      this.errorMessage = "";
      this.isEditing = false;
      this.save.emit(parsed);
    } catch (error) {
      this.errorMessage = "Invalid JSON format. Cannot save.";
    }
  }
  onCancel() {
    this.updateJsonString();
    this.isEditing = false;
    this.errorMessage = "";
    this.cancel.emit();
  }
  formatJson() {
    try {
      const parsed = JSON.parse(this.jsonString);
      this.jsonString = JSON.stringify(parsed, null, 2);
      this.errorMessage = "";
    } catch (error) {
      this.errorMessage = "Invalid JSON format";
    }
  }
  static {
    this.ɵfac = function JsonReflectComponent_Factory(t) {
      return new (t || _JsonReflectComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _JsonReflectComponent,
      selectors: [["app-json-reflect"]],
      inputs: {
        json: "json",
        editable: "editable",
        showControls: "showControls",
        height: "height"
      },
      outputs: {
        jsonChange: "jsonChange",
        save: "save",
        cancel: "cancel"
      },
      standalone: true,
      features: [ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
      decls: 5,
      vars: 5,
      consts: [[1, "json-reflect-container"], [1, "json-controls"], [1, "error-message"], ["placeholder", "Enter JSON here...", 1, "json-editor", 3, "ngModel"], ["text", "Edit", "fontIcon", "edit", "appearance", "raised", "color", "primary"], ["text", "Edit", "fontIcon", "edit", "appearance", "raised", "color", "primary", 3, "btnClick"], ["text", "Save", "fontIcon", "save", "appearance", "raised", "color", "primary", 3, "btnClick"], ["text", "Cancel", "fontIcon", "cancel", "appearance", "flat", "color", "warn", 3, "btnClick"], ["text", "Format", "fontIcon", "code", "appearance", "flat", 3, "btnClick"], ["placeholder", "Enter JSON here...", 1, "json-editor", 3, "ngModelChange", "input", "ngModel"], [1, "json-viewer"]],
      template: function JsonReflectComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "div", 0);
          ɵɵtemplate(1, JsonReflectComponent_Conditional_1_Template, 3, 1, "div", 1)(2, JsonReflectComponent_Conditional_2_Template, 2, 1, "div", 2)(3, JsonReflectComponent_Conditional_3_Template, 1, 1, "textarea", 3)(4, JsonReflectComponent_Conditional_4_Template, 2, 1);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵstyleProp("height", ctx.height);
          ɵɵadvance();
          ɵɵconditional(1, ctx.showControls && ctx.editable ? 1 : -1);
          ɵɵadvance();
          ɵɵconditional(2, ctx.errorMessage ? 2 : -1);
          ɵɵadvance();
          ɵɵconditional(3, ctx.isEditing && ctx.editable ? 3 : 4);
        }
      },
      dependencies: [CommonModule, FormsModule, DefaultValueAccessor, NgControlStatus, NgModel, MatButtonModule, MatIconModule, MatInputModule, MatFormFieldModule, AppButtonComponent],
      styles: [".json-reflect-container[_ngcontent-%COMP%]{display:flex;flex-direction:column;border:1px solid #e0e0e0;border-radius:4px;overflow:hidden}.json-controls[_ngcontent-%COMP%]{display:flex;gap:8px;padding:8px;background-color:#f5f5f5;border-bottom:1px solid #e0e0e0}.error-message[_ngcontent-%COMP%]{padding:8px 16px;background-color:#ffebee;color:#c62828;font-size:14px;border-bottom:1px solid #e0e0e0}.json-editor[_ngcontent-%COMP%]{flex:1;padding:16px;font-family:Courier New,monospace;font-size:14px;line-height:1.5;border:none;outline:none;resize:none;background-color:#fafafa}.json-viewer[_ngcontent-%COMP%]{flex:1;padding:16px;margin:0;font-family:Courier New,monospace;font-size:14px;line-height:1.5;overflow:auto;background-color:#fafafa;white-space:pre-wrap;word-wrap:break-word}"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(JsonReflectComponent, [{
    type: Component,
    args: [{
      selector: "app-json-reflect",
      standalone: true,
      imports: [CommonModule, FormsModule, MatButtonModule, MatIconModule, MatInputModule, MatFormFieldModule, AppButtonComponent],
      template: '<div class="json-reflect-container" [style.height]="height">\n  @if (showControls && editable) {\n    <div class="json-controls">\n      @if (!isEditing) {\n        <app-button\n          text="Edit"\n          fontIcon="edit"\n          appearance="raised"\n          color="primary"\n          (btnClick)="toggleEdit()"\n        ></app-button>\n      } @else {\n        <app-button\n          text="Save"\n          fontIcon="save"\n          appearance="raised"\n          color="primary"\n          (btnClick)="onSave()"\n        ></app-button>\n        <app-button\n          text="Cancel"\n          fontIcon="cancel"\n          appearance="flat"\n          color="warn"\n          (btnClick)="onCancel()"\n        ></app-button>\n        <app-button\n          text="Format"\n          fontIcon="code"\n          appearance="flat"\n          (btnClick)="formatJson()"\n        ></app-button>\n      }\n    </div>\n  }\n\n  @if (errorMessage) {\n    <div class="error-message">{{ errorMessage }}</div>\n  }\n\n  @if (isEditing && editable) {\n    <textarea\n      class="json-editor"\n      [(ngModel)]="jsonString"\n      (input)="onJsonChange()"\n      placeholder="Enter JSON here..."\n    ></textarea>\n  } @else {\n    <pre class="json-viewer">{{ jsonString }}</pre>\n  }\n</div>\n\n',
      styles: [".json-reflect-container{display:flex;flex-direction:column;border:1px solid #e0e0e0;border-radius:4px;overflow:hidden}.json-controls{display:flex;gap:8px;padding:8px;background-color:#f5f5f5;border-bottom:1px solid #e0e0e0}.error-message{padding:8px 16px;background-color:#ffebee;color:#c62828;font-size:14px;border-bottom:1px solid #e0e0e0}.json-editor{flex:1;padding:16px;font-family:Courier New,monospace;font-size:14px;line-height:1.5;border:none;outline:none;resize:none;background-color:#fafafa}.json-viewer{flex:1;padding:16px;margin:0;font-family:Courier New,monospace;font-size:14px;line-height:1.5;overflow:auto;background-color:#fafafa;white-space:pre-wrap;word-wrap:break-word}\n"]
    }]
  }], null, {
    json: [{
      type: Input
    }],
    editable: [{
      type: Input
    }],
    showControls: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    jsonChange: [{
      type: Output
    }],
    save: [{
      type: Output
    }],
    cancel: [{
      type: Output
    }]
  });
})();
var PdfViewerComponent = class _PdfViewerComponent {
  constructor(sanitizer) {
    this.sanitizer = sanitizer;
    this.src = null;
    this.height = "600px";
    this.width = "100%";
    this.showToolbar = true;
    this.downloadFileName = "document.pdf";
    this.safeSrc = null;
    this.pdfUrl = "";
  }
  ngOnInit() {
    this.updatePdfSource();
  }
  ngOnChanges(changes) {
    if (changes["src"]) {
      this.updatePdfSource();
    }
  }
  updatePdfSource() {
    if (!this.src) {
      this.safeSrc = null;
      this.pdfUrl = "";
      return;
    }
    if (typeof this.src === "string") {
      this.pdfUrl = this.src;
      this.safeSrc = this.sanitizer.bypassSecurityTrustResourceUrl(this.src);
    } else if (this.src instanceof ArrayBuffer) {
      const blob = new Blob([this.src], {
        type: "application/pdf"
      });
      const url = URL.createObjectURL(blob);
      this.pdfUrl = url;
      this.safeSrc = this.sanitizer.bypassSecurityTrustResourceUrl(url);
    }
  }
  downloadPdf() {
    if (this.pdfUrl) {
      const link = document.createElement("a");
      link.href = this.pdfUrl;
      link.download = this.downloadFileName;
      link.click();
    }
  }
  printPdf() {
    if (this.pdfUrl) {
      const printWindow = window.open(this.pdfUrl, "_blank");
      if (printWindow) {
        printWindow.onload = () => {
          printWindow.print();
        };
      }
    }
  }
  static {
    this.ɵfac = function PdfViewerComponent_Factory(t) {
      return new (t || _PdfViewerComponent)(ɵɵdirectiveInject(DomSanitizer));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _PdfViewerComponent,
      selectors: [["app-pdf-viewer"]],
      inputs: {
        src: "src",
        height: "height",
        width: "width",
        showToolbar: "showToolbar",
        downloadFileName: "downloadFileName"
      },
      standalone: true,
      features: [ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
      decls: 4,
      vars: 6,
      consts: [[1, "pdf-viewer-container"], [1, "pdf-toolbar"], [1, "pdf-iframe", 3, "src", "height"], ["text", "Download", "fontIcon", "download", "appearance", "flat", "color", "primary", 3, "btnClick"], ["text", "Print", "fontIcon", "print", "appearance", "flat", "color", "primary", 3, "btnClick"], [1, "pdf-iframe", 3, "src"], [1, "pdf-placeholder"]],
      template: function PdfViewerComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "div", 0);
          ɵɵtemplate(1, PdfViewerComponent_Conditional_1_Template, 3, 0, "div", 1)(2, PdfViewerComponent_Conditional_2_Template, 1, 3, "iframe", 2)(3, PdfViewerComponent_Conditional_3_Template, 3, 0);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵstyleProp("width", ctx.width)("height", ctx.height);
          ɵɵadvance();
          ɵɵconditional(1, ctx.showToolbar ? 1 : -1);
          ɵɵadvance();
          ɵɵconditional(2, ctx.safeSrc ? 2 : 3);
        }
      },
      dependencies: [CommonModule, MatButtonModule, MatIconModule, AppButtonComponent],
      styles: [".pdf-viewer-container[_ngcontent-%COMP%]{display:flex;flex-direction:column;border:1px solid #e0e0e0;border-radius:4px;overflow:hidden}.pdf-toolbar[_ngcontent-%COMP%]{display:flex;gap:8px;padding:8px;background-color:#f5f5f5;border-bottom:1px solid #e0e0e0}.pdf-iframe[_ngcontent-%COMP%]{width:100%;border:none;flex:1}.pdf-placeholder[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center;height:100%;color:#9e9e9e;font-size:16px}"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PdfViewerComponent, [{
    type: Component,
    args: [{
      selector: "app-pdf-viewer",
      standalone: true,
      imports: [CommonModule, MatButtonModule, MatIconModule, AppButtonComponent],
      template: `<div class="pdf-viewer-container" [style.width]="width" [style.height]="height">
  @if (showToolbar) {
    <div class="pdf-toolbar">
      <app-button
        text="Download"
        fontIcon="download"
        appearance="flat"
        color="primary"
        (btnClick)="downloadPdf()"
      ></app-button>
      <app-button
        text="Print"
        fontIcon="print"
        appearance="flat"
        color="primary"
        (btnClick)="printPdf()"
      ></app-button>
    </div>
  }

  @if (safeSrc) {
    <iframe
      [src]="safeSrc"
      class="pdf-iframe"
      [style.height]="showToolbar ? 'calc(' + height + ' - 48px)' : height"
    ></iframe>
  } @else {
    <div class="pdf-placeholder">
      <p>No PDF to display</p>
    </div>
  }
</div>

`,
      styles: [".pdf-viewer-container{display:flex;flex-direction:column;border:1px solid #e0e0e0;border-radius:4px;overflow:hidden}.pdf-toolbar{display:flex;gap:8px;padding:8px;background-color:#f5f5f5;border-bottom:1px solid #e0e0e0}.pdf-iframe{width:100%;border:none;flex:1}.pdf-placeholder{display:flex;align-items:center;justify-content:center;height:100%;color:#9e9e9e;font-size:16px}\n"]
    }]
  }], () => [{
    type: DomSanitizer
  }], {
    src: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    showToolbar: [{
      type: Input
    }],
    downloadFileName: [{
      type: Input
    }]
  });
})();
var QrCodeGeneratorComponent = class _QrCodeGeneratorComponent {
  constructor() {
    this.data = "";
    this.size = 200;
    this.errorCorrectionLevel = "M";
    this.showInput = true;
    this.showDownload = true;
    this.qrGenerated = new EventEmitter();
    this.qrCodeDataUrl = "";
    this.inputData = "";
  }
  ngOnInit() {
    this.inputData = this.data;
    if (this.data) {
      this.generateQRCode();
    }
  }
  ngOnChanges(changes) {
    if (changes["data"] && this.data) {
      this.inputData = this.data;
      this.generateQRCode();
    }
  }
  generateQRCode() {
    if (!this.inputData) {
      this.qrCodeDataUrl = "";
      return;
    }
    const qrApiUrl = `https://api.qrserver.com/v1/create-qr-code/?size=${this.size}x${this.size}&data=${encodeURIComponent(this.inputData)}&ecc=${this.errorCorrectionLevel}`;
    this.qrCodeDataUrl = qrApiUrl;
    this.qrGenerated.emit(this.qrCodeDataUrl);
  }
  onInputChange() {
    this.generateQRCode();
  }
  downloadQRCode() {
    if (this.qrCodeDataUrl) {
      const link = document.createElement("a");
      link.href = this.qrCodeDataUrl;
      link.download = "qrcode.png";
      link.click();
    }
  }
  static {
    this.ɵfac = function QrCodeGeneratorComponent_Factory(t) {
      return new (t || _QrCodeGeneratorComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _QrCodeGeneratorComponent,
      selectors: [["app-qr-code-generator"]],
      inputs: {
        data: "data",
        size: "size",
        errorCorrectionLevel: "errorCorrectionLevel",
        showInput: "showInput",
        showDownload: "showDownload"
      },
      outputs: {
        qrGenerated: "qrGenerated"
      },
      standalone: true,
      features: [ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
      decls: 5,
      vars: 3,
      consts: [[1, "qr-code-container"], [1, "qr-input-section"], [1, "qr-code-display"], [1, "qr-actions"], ["appearance", "outline", 1, "full-width"], ["matInput", "", "placeholder", "Enter text or URL", 3, "ngModelChange", "ngModel"], ["alt", "QR Code", 3, "src"], [1, "qr-placeholder"], ["text", "Download", "fontIcon", "download", "appearance", "raised", "color", "primary", 3, "btnClick"]],
      template: function QrCodeGeneratorComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "div", 0);
          ɵɵtemplate(1, QrCodeGeneratorComponent_Conditional_1_Template, 5, 1, "div", 1)(2, QrCodeGeneratorComponent_Conditional_2_Template, 2, 5, "div", 2)(3, QrCodeGeneratorComponent_Conditional_3_Template, 3, 0)(4, QrCodeGeneratorComponent_Conditional_4_Template, 2, 0, "div", 3);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵadvance();
          ɵɵconditional(1, ctx.showInput ? 1 : -1);
          ɵɵadvance();
          ɵɵconditional(2, ctx.qrCodeDataUrl ? 2 : 3);
          ɵɵadvance(2);
          ɵɵconditional(4, ctx.showDownload && ctx.qrCodeDataUrl ? 4 : -1);
        }
      },
      dependencies: [CommonModule, MatButtonModule, MatInputModule, MatInput, MatFormField, MatLabel, MatFormFieldModule, FormsModule, DefaultValueAccessor, NgControlStatus, NgModel, AppButtonComponent],
      styles: [".qr-code-container[_ngcontent-%COMP%]{display:flex;flex-direction:column;align-items:center;gap:16px;padding:16px}.qr-input-section[_ngcontent-%COMP%]{width:100%;max-width:400px}.full-width[_ngcontent-%COMP%]{width:100%}.qr-code-display[_ngcontent-%COMP%]{display:flex;justify-content:center;align-items:center;padding:16px;background-color:#fff;border:1px solid #e0e0e0;border-radius:4px}.qr-placeholder[_ngcontent-%COMP%]{padding:32px;text-align:center;color:#9e9e9e}.qr-actions[_ngcontent-%COMP%]{display:flex;gap:8px}"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(QrCodeGeneratorComponent, [{
    type: Component,
    args: [{
      selector: "app-qr-code-generator",
      standalone: true,
      imports: [CommonModule, MatButtonModule, MatInputModule, MatFormFieldModule, FormsModule, AppButtonComponent],
      template: '<div class="qr-code-container">\n  @if (showInput) {\n    <div class="qr-input-section">\n      <mat-form-field appearance="outline" class="full-width">\n        <mat-label>Enter data for QR code</mat-label>\n        <input\n          matInput\n          [(ngModel)]="inputData"\n          (ngModelChange)="onInputChange()"\n          placeholder="Enter text or URL"\n        />\n      </mat-form-field>\n    </div>\n  }\n\n  @if (qrCodeDataUrl) {\n    <div class="qr-code-display">\n      <img [src]="qrCodeDataUrl" [style.width.px]="size" [style.height.px]="size" alt="QR Code" />\n    </div>\n  } @else {\n    <div class="qr-placeholder">\n      <p>Enter data to generate QR code</p>\n    </div>\n  }\n\n  @if (showDownload && qrCodeDataUrl) {\n    <div class="qr-actions">\n      <app-button\n        text="Download"\n        fontIcon="download"\n        appearance="raised"\n        color="primary"\n        (btnClick)="downloadQRCode()"\n      ></app-button>\n    </div>\n  }\n</div>\n\n',
      styles: [".qr-code-container{display:flex;flex-direction:column;align-items:center;gap:16px;padding:16px}.qr-input-section{width:100%;max-width:400px}.full-width{width:100%}.qr-code-display{display:flex;justify-content:center;align-items:center;padding:16px;background-color:#fff;border:1px solid #e0e0e0;border-radius:4px}.qr-placeholder{padding:32px;text-align:center;color:#9e9e9e}.qr-actions{display:flex;gap:8px}\n"]
    }]
  }], null, {
    data: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    errorCorrectionLevel: [{
      type: Input
    }],
    showInput: [{
      type: Input
    }],
    showDownload: [{
      type: Input
    }],
    qrGenerated: [{
      type: Output
    }]
  });
})();
var RichTextEditorComponent = class _RichTextEditorComponent {
  constructor() {
    this.placeholder = "Enter text here...";
    this.height = "300px";
    this.showToolbar = true;
    this.contentChange = new EventEmitter();
    this.content = "";
    this.onChange = (value) => {
    };
    this.onTouched = () => {
    };
  }
  writeValue(value) {
    this.content = value || "";
    if (this.getEditorElement()) {
      this.getEditorElement().innerHTML = this.content;
    }
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  onContentChange() {
    const editor = this.getEditorElement();
    if (editor) {
      this.content = editor.innerHTML;
      this.onChange(this.content);
      this.contentChange.emit(this.content);
    }
  }
  executeCommand(command, value = "") {
    document.execCommand(command, false, value);
    this.onContentChange();
    this.getEditorElement()?.focus();
  }
  getEditorElement() {
    return document.getElementById("rich-text-editor-content");
  }
  formatText(command) {
    this.executeCommand(command);
  }
  insertLink() {
    const url = prompt("Enter URL:");
    if (url) {
      this.executeCommand("createLink", url);
    }
  }
  insertImage() {
    const url = prompt("Enter image URL:");
    if (url) {
      this.executeCommand("insertImage", url);
    }
  }
  static {
    this.ɵfac = function RichTextEditorComponent_Factory(t) {
      return new (t || _RichTextEditorComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _RichTextEditorComponent,
      selectors: [["app-rich-text-editor"]],
      inputs: {
        placeholder: "placeholder",
        height: "height",
        showToolbar: "showToolbar"
      },
      outputs: {
        contentChange: "contentChange"
      },
      standalone: true,
      features: [ɵɵProvidersFeature([{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => _RichTextEditorComponent),
        multi: true
      }]), ɵɵStandaloneFeature],
      decls: 3,
      vars: 4,
      consts: [[1, "rich-text-editor-container"], [1, "editor-toolbar"], ["id", "rich-text-editor-content", "contenteditable", "true", 1, "editor-content", 3, "input", "blur"], [1, "toolbar-group"], ["appearance", "icon", "type", "button", "title", "Bold", 3, "btnClick", "fontIcon"], ["appearance", "icon", "type", "button", "title", "Italic", 3, "btnClick", "fontIcon"], ["appearance", "icon", "type", "button", "title", "Underline", 3, "btnClick", "fontIcon"], ["appearance", "icon", "type", "button", "title", "Align Left", 3, "btnClick", "fontIcon"], ["appearance", "icon", "type", "button", "title", "Align Center", 3, "btnClick", "fontIcon"], ["appearance", "icon", "type", "button", "title", "Align Right", 3, "btnClick", "fontIcon"], ["appearance", "icon", "type", "button", "title", "Bullet List", 3, "btnClick", "fontIcon"], ["appearance", "icon", "type", "button", "title", "Numbered List", 3, "btnClick", "fontIcon"], ["appearance", "icon", "type", "button", "title", "Insert Link", 3, "btnClick", "fontIcon"], ["appearance", "icon", "type", "button", "title", "Insert Image", 3, "btnClick", "fontIcon"]],
      template: function RichTextEditorComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "div", 0);
          ɵɵtemplate(1, RichTextEditorComponent_Conditional_1_Template, 15, 30, "div", 1);
          ɵɵelementStart(2, "div", 2);
          ɵɵlistener("input", function RichTextEditorComponent_Template_div_input_2_listener() {
            return ctx.onContentChange();
          })("blur", function RichTextEditorComponent_Template_div_blur_2_listener() {
            return ctx.onTouched();
          });
          ɵɵelementEnd()();
        }
        if (rf & 2) {
          ɵɵadvance();
          ɵɵconditional(1, ctx.showToolbar ? 1 : -1);
          ɵɵadvance();
          ɵɵstyleProp("height", ctx.height);
          ɵɵattribute("placeholder", ctx.placeholder);
        }
      },
      dependencies: [CommonModule, FormsModule, AppButtonComponent],
      styles: [".rich-text-editor-container[_ngcontent-%COMP%]{border:1px solid #e0e0e0;border-radius:4px;overflow:hidden}.editor-toolbar[_ngcontent-%COMP%]{display:flex;gap:8px;padding:8px;background-color:#f5f5f5;border-bottom:1px solid #e0e0e0;flex-wrap:wrap}.toolbar-group[_ngcontent-%COMP%]{display:flex;gap:4px;padding-right:8px;border-right:1px solid #e0e0e0}.toolbar-group[_ngcontent-%COMP%]:last-child{border-right:none}.toolbar-group[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center;width:32px;height:32px;border:none;background-color:transparent;cursor:pointer;border-radius:4px;transition:background-color .2s}.toolbar-group[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:hover{background-color:#e0e0e0}.toolbar-group[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{font-size:20px;width:20px;height:20px;color:#424242}.editor-content[_ngcontent-%COMP%]{padding:16px;outline:none;overflow-y:auto;min-height:100px;font-family:Arial,sans-serif;font-size:14px;line-height:1.5}.editor-content[_ngcontent-%COMP%]:empty:before{content:attr(placeholder);color:#9e9e9e}"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RichTextEditorComponent, [{
    type: Component,
    args: [{
      selector: "app-rich-text-editor",
      standalone: true,
      imports: [CommonModule, FormsModule, AppButtonComponent],
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => RichTextEditorComponent),
        multi: true
      }],
      template: `<div class="rich-text-editor-container">
  @if (showToolbar) {
    <div class="editor-toolbar">
      <div class="toolbar-group">
        <app-button appearance="icon" type="button" [fontIcon]="'format_bold'" (btnClick)="formatText('bold')" [class]="'toolbar-button'" title="Bold"></app-button>
        <app-button appearance="icon" type="button" [fontIcon]="'format_italic'" (btnClick)="formatText('italic')" [class]="'toolbar-button'" title="Italic"></app-button>
        <app-button appearance="icon" type="button" [fontIcon]="'format_underlined'" (btnClick)="formatText('underline')" [class]="'toolbar-button'" title="Underline"></app-button>
      </div>
      
      <div class="toolbar-group">
        <app-button appearance="icon" type="button" [fontIcon]="'format_align_left'" (btnClick)="formatText('justifyLeft')" [class]="'toolbar-button'" title="Align Left"></app-button>
        <app-button appearance="icon" type="button" [fontIcon]="'format_align_center'" (btnClick)="formatText('justifyCenter')" [class]="'toolbar-button'" title="Align Center"></app-button>
        <app-button appearance="icon" type="button" [fontIcon]="'format_align_right'" (btnClick)="formatText('justifyRight')" [class]="'toolbar-button'" title="Align Right"></app-button>
      </div>

      <div class="toolbar-group">
        <app-button appearance="icon" type="button" [fontIcon]="'format_list_bulleted'" (btnClick)="formatText('insertUnorderedList')" [class]="'toolbar-button'" title="Bullet List"></app-button>
        <app-button appearance="icon" type="button" [fontIcon]="'format_list_numbered'" (btnClick)="formatText('insertOrderedList')" [class]="'toolbar-button'" title="Numbered List"></app-button>
      </div>

      <div class="toolbar-group">
        <app-button appearance="icon" type="button" [fontIcon]="'link'" (btnClick)="insertLink()" [class]="'toolbar-button'" title="Insert Link"></app-button>
        <app-button appearance="icon" type="button" [fontIcon]="'image'" (btnClick)="insertImage()" [class]="'toolbar-button'" title="Insert Image"></app-button>
      </div>
    </div>
  }

  <div
    id="rich-text-editor-content"
    class="editor-content"
    [style.height]="height"
    contenteditable="true"
    [attr.placeholder]="placeholder"
    (input)="onContentChange()"
    (blur)="onTouched()"
  ></div>
</div>

`,
      styles: [".rich-text-editor-container{border:1px solid #e0e0e0;border-radius:4px;overflow:hidden}.editor-toolbar{display:flex;gap:8px;padding:8px;background-color:#f5f5f5;border-bottom:1px solid #e0e0e0;flex-wrap:wrap}.toolbar-group{display:flex;gap:4px;padding-right:8px;border-right:1px solid #e0e0e0}.toolbar-group:last-child{border-right:none}.toolbar-group button{display:flex;align-items:center;justify-content:center;width:32px;height:32px;border:none;background-color:transparent;cursor:pointer;border-radius:4px;transition:background-color .2s}.toolbar-group button:hover{background-color:#e0e0e0}.toolbar-group button mat-icon{font-size:20px;width:20px;height:20px;color:#424242}.editor-content{padding:16px;outline:none;overflow-y:auto;min-height:100px;font-family:Arial,sans-serif;font-size:14px;line-height:1.5}.editor-content:empty:before{content:attr(placeholder);color:#9e9e9e}\n"]
    }]
  }], null, {
    placeholder: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    showToolbar: [{
      type: Input
    }],
    contentChange: [{
      type: Output
    }]
  });
})();
var SliderComponent = class _SliderComponent {
  constructor() {
    this.min = 0;
    this.max = 100;
    this.step = 1;
    this.value = 0;
    this.points = [];
    this.showValue = true;
    this.showInput = false;
    this.disabled = false;
    this.vertical = false;
    this.color = "primary";
    this.valueChange = new EventEmitter();
    this.change = new EventEmitter();
  }
  onValueChange(event) {
    const newValue = typeof event === "number" ? event : event?.value ?? event?.target?.value ?? this.value;
    this.value = newValue;
    this.valueChange.emit(newValue);
    this.change.emit(newValue);
  }
  getPointPosition(point) {
    return (point.value - this.min) / (this.max - this.min) * 100;
  }
  static {
    this.ɵfac = function SliderComponent_Factory(t) {
      return new (t || _SliderComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _SliderComponent,
      selectors: [["app-slider"]],
      inputs: {
        min: "min",
        max: "max",
        step: "step",
        value: "value",
        points: "points",
        showValue: "showValue",
        showInput: "showInput",
        disabled: "disabled",
        vertical: "vertical",
        color: "color"
      },
      outputs: {
        valueChange: "valueChange",
        change: "change"
      },
      standalone: true,
      features: [ɵɵStandaloneFeature],
      decls: 8,
      vars: 13,
      consts: [[1, "slider-container"], [1, "slider-wrapper"], [1, "slider-control", 3, "min", "max", "step", "disabled", "color"], ["matSliderThumb", "", 3, "valueChange", "value"], [1, "slider-points"], [1, "slider-info"], [1, "slider-value"], ["appearance", "outline", 1, "value-input"], [1, "slider-point", 3, "left", "bottom", "color", "title"], [1, "slider-point", 3, "title"], [1, "point-marker"], [1, "point-label"], ["matInput", "", "type", "number", 3, "ngModelChange", "min", "max", "step", "ngModel", "disabled"]],
      template: function SliderComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "div", 0)(1, "div", 1)(2, "mat-slider", 2)(3, "input", 3);
          ɵɵlistener("valueChange", function SliderComponent_Template_input_valueChange_3_listener($event) {
            return ctx.onValueChange($event);
          });
          ɵɵelementEnd()();
          ɵɵtemplate(4, SliderComponent_Conditional_4_Template, 3, 0, "div", 4);
          ɵɵelementEnd();
          ɵɵelementStart(5, "div", 5);
          ɵɵtemplate(6, SliderComponent_Conditional_6_Template, 2, 1, "span", 6)(7, SliderComponent_Conditional_7_Template, 2, 5, "mat-form-field", 7);
          ɵɵelementEnd()();
        }
        if (rf & 2) {
          ɵɵclassProp("vertical", ctx.vertical);
          ɵɵadvance(2);
          ɵɵclassProp("vertical", ctx.vertical);
          ɵɵproperty("min", ctx.min)("max", ctx.max)("step", ctx.step)("disabled", ctx.disabled)("color", ctx.color);
          ɵɵadvance();
          ɵɵproperty("value", ctx.value);
          ɵɵadvance();
          ɵɵconditional(4, ctx.points && ctx.points.length > 0 ? 4 : -1);
          ɵɵadvance(2);
          ɵɵconditional(6, ctx.showValue ? 6 : -1);
          ɵɵadvance();
          ɵɵconditional(7, ctx.showInput ? 7 : -1);
        }
      },
      dependencies: [CommonModule, FormsModule, DefaultValueAccessor, NumberValueAccessor, NgControlStatus, MinValidator, MaxValidator, NgModel, MatSliderModule, MatSlider, MatSliderThumb, MatInputModule, MatInput, MatFormField, MatFormFieldModule],
      styles: [".slider-container[_ngcontent-%COMP%]{display:flex;flex-direction:column;gap:8px;padding:16px}.slider-container.vertical[_ngcontent-%COMP%]{flex-direction:row;align-items:center;gap:16px}.slider-wrapper[_ngcontent-%COMP%]{position:relative;flex:1;width:100%}.slider-control[_ngcontent-%COMP%]{width:100%}.slider-points[_ngcontent-%COMP%]{position:absolute;inset:0;pointer-events:none}.slider-point[_ngcontent-%COMP%]{position:absolute;display:flex;flex-direction:column;align-items:center;transform:translate(-50%)}.point-marker[_ngcontent-%COMP%]{width:8px;height:8px;border-radius:50%;background-color:currentColor;margin-bottom:4px}.point-label[_ngcontent-%COMP%]{font-size:12px;white-space:nowrap}.slider-info[_ngcontent-%COMP%]{display:flex;align-items:center;gap:8px;justify-content:space-between}.slider-value[_ngcontent-%COMP%]{font-size:14px;font-weight:500;color:#424242}.value-input[_ngcontent-%COMP%]{width:80px}.vertical[_ngcontent-%COMP%]   .slider-point[_ngcontent-%COMP%]{transform:translateY(50%);flex-direction:row;left:0}.vertical[_ngcontent-%COMP%]   .point-marker[_ngcontent-%COMP%]{margin-right:4px;margin-bottom:0}"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SliderComponent, [{
    type: Component,
    args: [{
      selector: "app-slider",
      standalone: true,
      imports: [CommonModule, FormsModule, MatSliderModule, MatInputModule, MatFormFieldModule],
      template: '<div class="slider-container" [class.vertical]="vertical">\n  <div class="slider-wrapper">\n    <mat-slider\n      [min]="min"\n      [max]="max"\n      [step]="step"\n      [disabled]="disabled"\n      [color]="color"\n      class="slider-control"\n      [class.vertical]="vertical"\n    >\n      <input matSliderThumb [value]="value" (valueChange)="onValueChange($event)">\n    </mat-slider>\n\n    @if (points && points.length > 0) {\n      <div class="slider-points">\n        @for (point of points; track $index) {\n          <div\n            class="slider-point"\n            [style.left.%]="getPointPosition(point)"\n            [style.bottom.%]="vertical ? getPointPosition(point) : 0"\n            [style.color]="point.color"\n            [title]="point.label || point.value.toString()"\n          >\n            <div class="point-marker"></div>\n            @if (point.label) {\n              <span class="point-label">{{ point.label }}</span>\n            }\n          </div>\n        }\n      </div>\n    }\n  </div>\n\n  <div class="slider-info">\n    @if (showValue) {\n      <span class="slider-value">{{ value }}</span>\n    }\n    @if (showInput) {\n      <mat-form-field appearance="outline" class="value-input">\n        <input\n          matInput\n          type="number"\n          [min]="min"\n          [max]="max"\n          [step]="step"\n          [(ngModel)]="value"\n          (ngModelChange)="onValueChange($event)"\n          [disabled]="disabled"\n        />\n      </mat-form-field>\n    }\n  </div>\n</div>\n\n',
      styles: [".slider-container{display:flex;flex-direction:column;gap:8px;padding:16px}.slider-container.vertical{flex-direction:row;align-items:center;gap:16px}.slider-wrapper{position:relative;flex:1;width:100%}.slider-control{width:100%}.slider-points{position:absolute;inset:0;pointer-events:none}.slider-point{position:absolute;display:flex;flex-direction:column;align-items:center;transform:translate(-50%)}.point-marker{width:8px;height:8px;border-radius:50%;background-color:currentColor;margin-bottom:4px}.point-label{font-size:12px;white-space:nowrap}.slider-info{display:flex;align-items:center;gap:8px;justify-content:space-between}.slider-value{font-size:14px;font-weight:500;color:#424242}.value-input{width:80px}.vertical .slider-point{transform:translateY(50%);flex-direction:row;left:0}.vertical .point-marker{margin-right:4px;margin-bottom:0}\n"]
    }]
  }], null, {
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    step: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    points: [{
      type: Input
    }],
    showValue: [{
      type: Input
    }],
    showInput: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    vertical: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    change: [{
      type: Output
    }]
  });
})();
var TooltipDirective = class _TooltipDirective {
  constructor(elementRef, renderer) {
    this.elementRef = elementRef;
    this.renderer = renderer;
    this.appTooltip = "";
    this.tooltipPosition = "below";
    this.tooltipShowDelay = 0;
    this.tooltipHideDelay = 0;
    this.tooltipDisabled = false;
  }
  ngOnInit() {
    if (this.appTooltip && !this.tooltipDisabled) {
      this.renderer.setAttribute(this.elementRef.nativeElement, "matTooltip", this.appTooltip);
      this.renderer.setAttribute(this.elementRef.nativeElement, "matTooltipPosition", this.tooltipPosition);
      this.renderer.setAttribute(this.elementRef.nativeElement, "matTooltipShowDelay", this.tooltipShowDelay.toString());
      this.renderer.setAttribute(this.elementRef.nativeElement, "matTooltipHideDelay", this.tooltipHideDelay.toString());
    }
  }
  ngOnDestroy() {
  }
  static {
    this.ɵfac = function TooltipDirective_Factory(t) {
      return new (t || _TooltipDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _TooltipDirective,
      selectors: [["", "appTooltip", ""]],
      inputs: {
        appTooltip: "appTooltip",
        tooltipPosition: "tooltipPosition",
        tooltipShowDelay: "tooltipShowDelay",
        tooltipHideDelay: "tooltipHideDelay",
        tooltipDisabled: "tooltipDisabled"
      },
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TooltipDirective, [{
    type: Directive,
    args: [{
      selector: "[appTooltip]",
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }], {
    appTooltip: [{
      type: Input
    }],
    tooltipPosition: [{
      type: Input
    }],
    tooltipShowDelay: [{
      type: Input
    }],
    tooltipHideDelay: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }]
  });
})();
var uniqueId = 0;
var ButtonCheckboxComponent = class _ButtonCheckboxComponent {
  constructor() {
    this.label = "";
    this.icon = "";
    this.id = `app-button-checkbox-${uniqueId++}`;
    this.disabled = false;
    this.value = false;
    this.onChange = () => {
    };
    this.onTouched = () => {
    };
  }
  onInputChange(event) {
    const target = event.target;
    this.value = target.checked;
    this.onChange(this.value);
    this.onTouched();
  }
  // ControlValueAccessor
  writeValue(value) {
    this.value = !!value;
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  static {
    this.ɵfac = function ButtonCheckboxComponent_Factory(t) {
      return new (t || _ButtonCheckboxComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _ButtonCheckboxComponent,
      selectors: [["app-button-checkbox"]],
      inputs: {
        label: "label",
        icon: "icon",
        id: "id",
        disabled: "disabled"
      },
      standalone: true,
      features: [ɵɵProvidersFeature([{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => _ButtonCheckboxComponent),
        multi: true
      }]), ɵɵStandaloneFeature],
      decls: 6,
      vars: 7,
      consts: [[1, "button-checkbox", 3, "appTooltip"], ["type", "checkbox", 1, "button-checkbox-wrapper", 3, "change", "id", "checked", "disabled"], [1, "button-checkbox-label", 3, "for"], [3, "fontIcon", "color", "size", 4, "ngIf"], [3, "fontIcon", "color", "size"]],
      template: function ButtonCheckboxComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "div", 0)(1, "input", 1);
          ɵɵlistener("change", function ButtonCheckboxComponent_Template_input_change_1_listener($event) {
            return ctx.onInputChange($event);
          });
          ɵɵelementEnd();
          ɵɵelementStart(2, "label", 2);
          ɵɵtemplate(3, ButtonCheckboxComponent_app_icon_3_Template, 1, 3, "app-icon", 3);
          ɵɵelementStart(4, "span");
          ɵɵtext(5);
          ɵɵelementEnd()()();
        }
        if (rf & 2) {
          ɵɵproperty("appTooltip", ctx.label);
          ɵɵadvance();
          ɵɵproperty("id", ctx.id)("checked", ctx.value)("disabled", ctx.disabled);
          ɵɵadvance();
          ɵɵproperty("for", ctx.id);
          ɵɵadvance();
          ɵɵproperty("ngIf", ctx.icon);
          ɵɵadvance(2);
          ɵɵtextInterpolate(ctx.label);
        }
      },
      dependencies: [CommonModule, NgIf, IconComponent, TooltipDirective],
      styles: [".button-checkbox[_ngcontent-%COMP%]{position:relative;display:block;max-width:100%}.button-checkbox-wrapper[_ngcontent-%COMP%]{position:absolute;opacity:0;cursor:pointer;height:0;width:0}.button-checkbox-wrapper[_ngcontent-%COMP%]:checked + .button-checkbox-label[_ngcontent-%COMP%]{background:var(--primary-color);color:#fff}.button-checkbox-wrapper[_ngcontent-%COMP%]:checked + .button-checkbox-label[_ngcontent-%COMP%]   app-icon[_ngcontent-%COMP%]{color:#fff}.button-checkbox-label[_ngcontent-%COMP%]{display:flex;align-items:center;gap:.5em;padding:.5em .8em;background:#f8fafc;border:2px solid #e2e8f0;border-radius:.7em;cursor:pointer;transition:all .3s cubic-bezier(.4,0,.2,1);color:#1e293b;max-width:100%}.button-checkbox-label[_ngcontent-%COMP%]:hover{background:#f1f5f9;border-color:#cbd5e1;transform:translateY(-1px);box-shadow:0 4px 12px #0000001a}.button-checkbox-label[_ngcontent-%COMP%]   app-icon[_ngcontent-%COMP%]{color:#3b82f6;transition:color .3s ease}.button-checkbox-label[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{font-size:.9em;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ButtonCheckboxComponent, [{
    type: Component,
    args: [{
      selector: "app-button-checkbox",
      standalone: true,
      imports: [CommonModule, IconComponent, TooltipDirective],
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => ButtonCheckboxComponent),
        multi: true
      }],
      template: `<div class="button-checkbox" [appTooltip]="label">
  <input
    type="checkbox"
    class="button-checkbox-wrapper"
    [id]="id"
    [checked]="value"
    [disabled]="disabled"
    (change)="onInputChange($event)"
  />
  <label [for]="id" class="button-checkbox-label">
    <app-icon *ngIf="icon" [fontIcon]="icon" [color]="value?'var(--primary-text-color)':''" [size]="20"></app-icon>
    <span>{{ label }}</span>
  </label>
</div>
`,
      styles: [".button-checkbox{position:relative;display:block;max-width:100%}.button-checkbox-wrapper{position:absolute;opacity:0;cursor:pointer;height:0;width:0}.button-checkbox-wrapper:checked+.button-checkbox-label{background:var(--primary-color);color:#fff}.button-checkbox-wrapper:checked+.button-checkbox-label app-icon{color:#fff}.button-checkbox-label{display:flex;align-items:center;gap:.5em;padding:.5em .8em;background:#f8fafc;border:2px solid #e2e8f0;border-radius:.7em;cursor:pointer;transition:all .3s cubic-bezier(.4,0,.2,1);color:#1e293b;max-width:100%}.button-checkbox-label:hover{background:#f1f5f9;border-color:#cbd5e1;transform:translateY(-1px);box-shadow:0 4px 12px #0000001a}.button-checkbox-label app-icon{color:#3b82f6;transition:color .3s ease}.button-checkbox-label span{font-size:.9em;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}\n"]
    }]
  }], null, {
    label: [{
      type: Input
    }],
    icon: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }]
  });
})();
var StepperComponent = class _StepperComponent {
  constructor() {
    this.orientation = "horizontal";
    this.linear = false;
    this.selectedIndex = 0;
  }
  static {
    this.ɵfac = function StepperComponent_Factory(t) {
      return new (t || _StepperComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _StepperComponent,
      selectors: [["app-stepper"]],
      inputs: {
        orientation: "orientation",
        linear: "linear",
        selectedIndex: "selectedIndex"
      },
      standalone: true,
      features: [ɵɵStandaloneFeature],
      ngContentSelectors: _c113,
      decls: 2,
      vars: 3,
      consts: [[1, "app-stepper", 3, "orientation", "linear", "selectedIndex"]],
      template: function StepperComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef();
          ɵɵelementStart(0, "mat-stepper", 0);
          ɵɵprojection(1);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵproperty("orientation", ctx.orientation)("linear", ctx.linear)("selectedIndex", ctx.selectedIndex);
        }
      },
      dependencies: [CommonModule, MatStepperModule, MatStepper, FormsModule, ReactiveFormsModule],
      styles: [".app-stepper[_ngcontent-%COMP%]{width:100%}"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StepperComponent, [{
    type: Component,
    args: [{
      selector: "app-stepper",
      standalone: true,
      imports: [CommonModule, MatStepperModule, FormsModule, ReactiveFormsModule],
      template: '<mat-stepper\n  [orientation]="orientation"\n  [linear]="linear"\n  [selectedIndex]="selectedIndex"\n  class="app-stepper"\n>\n  <ng-content></ng-content>\n</mat-stepper>\n\n',
      styles: [".app-stepper{width:100%}\n"]
    }]
  }], null, {
    orientation: [{
      type: Input
    }],
    linear: [{
      type: Input
    }],
    selectedIndex: [{
      type: Input
    }]
  });
})();
var StepComponent = class _StepComponent {
  constructor() {
    this.label = "";
    this.optional = false;
    this.completed = false;
    this.state = "number";
  }
  static {
    this.ɵfac = function StepComponent_Factory(t) {
      return new (t || _StepComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _StepComponent,
      selectors: [["app-step"]],
      inputs: {
        label: "label",
        optional: "optional",
        completed: "completed",
        state: "state"
      },
      standalone: true,
      features: [ɵɵStandaloneFeature],
      ngContentSelectors: _c113,
      decls: 2,
      vars: 4,
      consts: [[3, "label", "optional", "completed", "state"]],
      template: function StepComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef();
          ɵɵelementStart(0, "mat-step", 0);
          ɵɵprojection(1);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵproperty("label", ctx.label)("optional", ctx.optional)("completed", ctx.completed)("state", ctx.state);
        }
      },
      dependencies: [CommonModule, MatStepperModule, MatStep],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StepComponent, [{
    type: Component,
    args: [{
      selector: "app-step",
      standalone: true,
      imports: [CommonModule, MatStepperModule],
      template: `
    <mat-step [label]="label" [optional]="optional" [completed]="completed" [state]="state">
      <ng-content></ng-content>
    </mat-step>
  `
    }]
  }], null, {
    label: [{
      type: Input
    }],
    optional: [{
      type: Input
    }],
    completed: [{
      type: Input
    }],
    state: [{
      type: Input
    }]
  });
})();
var TabComponent = class _TabComponent {
  constructor() {
    this.label = "";
    this.disabled = false;
  }
  static {
    this.ɵfac = function TabComponent_Factory(t) {
      return new (t || _TabComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _TabComponent,
      selectors: [["app-tab"]],
      viewQuery: function TabComponent_Query(rf, ctx) {
        if (rf & 1) {
          ɵɵviewQuery(_c92, 7);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.content = _t.first);
        }
      },
      inputs: {
        label: "label",
        disabled: "disabled"
      },
      standalone: true,
      features: [ɵɵStandaloneFeature],
      ngContentSelectors: _c113,
      decls: 2,
      vars: 0,
      consts: [["tabContent", ""]],
      template: function TabComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef();
          ɵɵtemplate(0, TabComponent_ng_template_0_Template, 1, 0, "ng-template", null, 0, ɵɵtemplateRefExtractor);
        }
      },
      dependencies: [CommonModule, MatTabsModule],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TabComponent, [{
    type: Component,
    args: [{
      selector: "app-tab",
      standalone: true,
      imports: [CommonModule, MatTabsModule],
      template: `
    <ng-template #tabContent>
      <ng-content></ng-content>
    </ng-template>
  `
    }]
  }], null, {
    label: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    content: [{
      type: ViewChild,
      args: ["tabContent", {
        static: true
      }]
    }]
  });
})();
var TabsComponent = class _TabsComponent {
  constructor() {
    this.selectedIndex = 0;
    this.animationDuration = "500ms";
    this.dynamicHeight = false;
    this.color = "primary";
  }
  ngAfterContentInit() {
  }
  static {
    this.ɵfac = function TabsComponent_Factory(t) {
      return new (t || _TabsComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _TabsComponent,
      selectors: [["app-tabs"]],
      contentQueries: function TabsComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          ɵɵcontentQuery(dirIndex, TabComponent, 4);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabs = _t);
        }
      },
      inputs: {
        selectedIndex: "selectedIndex",
        animationDuration: "animationDuration",
        dynamicHeight: "dynamicHeight",
        backgroundColor: "backgroundColor",
        color: "color"
      },
      standalone: true,
      features: [ɵɵStandaloneFeature],
      decls: 2,
      vars: 7,
      consts: [[1, "app-tabs", 3, "selectedIndex", "animationDuration", "dynamicHeight", "color"], [3, "label", "disabled", 4, "ngFor", "ngForOf"], [3, "label", "disabled"], [4, "ngTemplateOutlet"]],
      template: function TabsComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "mat-tab-group", 0);
          ɵɵtemplate(1, TabsComponent_mat_tab_1_Template, 2, 3, "mat-tab", 1);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵstyleProp("background-color", ctx.backgroundColor);
          ɵɵproperty("selectedIndex", ctx.selectedIndex)("animationDuration", ctx.animationDuration)("dynamicHeight", ctx.dynamicHeight)("color", ctx.color);
          ɵɵadvance();
          ɵɵproperty("ngForOf", ctx.tabs);
        }
      },
      dependencies: [CommonModule, NgForOf, NgTemplateOutlet, MatTabsModule, MatTab, MatTabGroup],
      styles: [".app-tabs[_ngcontent-%COMP%]{width:100%;height:100%}"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TabsComponent, [{
    type: Component,
    args: [{
      selector: "app-tabs",
      standalone: true,
      imports: [CommonModule, MatTabsModule, TabComponent],
      template: '<mat-tab-group\n  [selectedIndex]="selectedIndex"\n  [animationDuration]="animationDuration"\n  [dynamicHeight]="dynamicHeight"\n  [color]="color"\n  class="app-tabs"\n  [style.backgroundColor]="backgroundColor"\n>\n  <mat-tab *ngFor="let tab of tabs" [label]="tab.label" [disabled]="tab.disabled">\n    <ng-container *ngTemplateOutlet="tab.content"></ng-container>\n  </mat-tab>\n</mat-tab-group>\n\n',
      styles: [".app-tabs{width:100%;height:100%}\n"]
    }]
  }], null, {
    selectedIndex: [{
      type: Input
    }],
    animationDuration: [{
      type: Input
    }],
    dynamicHeight: [{
      type: Input
    }],
    backgroundColor: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    tabs: [{
      type: ContentChildren,
      args: [TabComponent]
    }]
  });
})();
var ToggleButtonComponent = class _ToggleButtonComponent {
  constructor() {
    this.options = [];
    this.value = null;
    this.multiple = false;
    this.appearance = "standard";
    this.vertical = false;
    this.valueChange = new EventEmitter();
    this.buttonClick = new EventEmitter();
    this.selectedValues = [];
  }
  ngOnInit() {
    if (this.multiple) {
      this.selectedValues = Array.isArray(this.value) ? [...this.value] : [];
    }
  }
  onToggleChange(value) {
    if (this.multiple) {
      this.selectedValues = Array.isArray(value) ? value : [value];
      this.valueChange.emit(this.selectedValues);
    } else {
      this.value = value;
      this.valueChange.emit(value);
      const option = this.options.find((opt) => opt.value === value);
      if (option) {
        this.buttonClick.emit({
          value,
          option
        });
      }
    }
  }
  onClick(option) {
    if (!option.disabled) {
      if (this.multiple) {
        const index = this.selectedValues.indexOf(option.value);
        if (index > -1) {
          this.selectedValues.splice(index, 1);
        } else {
          this.selectedValues.push(option.value);
        }
        this.valueChange.emit([...this.selectedValues]);
        this.buttonClick.emit({
          value: option.value,
          option
        });
      } else {
        this.value = option.value;
        this.valueChange.emit(option.value);
        this.buttonClick.emit({
          value: option.value,
          option
        });
      }
    }
  }
  isSelected(option) {
    if (this.multiple) {
      return this.selectedValues.includes(option.value);
    }
    return this.value === option.value;
  }
  static {
    this.ɵfac = function ToggleButtonComponent_Factory(t) {
      return new (t || _ToggleButtonComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _ToggleButtonComponent,
      selectors: [["app-toggle-button"]],
      inputs: {
        options: "options",
        value: "value",
        multiple: "multiple",
        appearance: "appearance",
        vertical: "vertical"
      },
      outputs: {
        valueChange: "valueChange",
        buttonClick: "buttonClick"
      },
      standalone: true,
      features: [ɵɵStandaloneFeature],
      decls: 2,
      vars: 1,
      consts: [[1, "toggle-group", 3, "value", "multiple", "appearance", "vertical"], [1, "toggle-group", 3, "change", "value", "multiple", "appearance", "vertical"], [3, "value", "disabled"], [3, "fontIcon"], [1, "toggle-buttons"], [3, "text", "fontIcon", "color", "appearance", "disabled", "selected"], [3, "btnClick", "text", "fontIcon", "color", "appearance", "disabled"]],
      template: function ToggleButtonComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵtemplate(0, ToggleButtonComponent_Conditional_0_Template, 3, 4, "mat-button-toggle-group", 0)(1, ToggleButtonComponent_Conditional_1_Template, 3, 2);
        }
        if (rf & 2) {
          ɵɵconditional(0, ctx.multiple ? 0 : 1);
        }
      },
      dependencies: [CommonModule, MatButtonToggleModule, MatButtonToggleGroup, MatButtonToggle, MatButtonModule, AppButtonComponent, IconComponent],
      styles: [".toggle-group[_ngcontent-%COMP%]{display:flex;flex-wrap:wrap;gap:8px}.toggle-buttons[_ngcontent-%COMP%]{display:flex;gap:8px;flex-wrap:wrap}.toggle-buttons.vertical[_ngcontent-%COMP%]{flex-direction:column}.toggle-buttons[_ngcontent-%COMP%]   app-button.selected[_ngcontent-%COMP%]{opacity:1}"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ToggleButtonComponent, [{
    type: Component,
    args: [{
      selector: "app-toggle-button",
      standalone: true,
      imports: [CommonModule, MatButtonToggleModule, MatButtonModule, AppButtonComponent, IconComponent],
      template: `@if (multiple) {
  <mat-button-toggle-group
    [value]="selectedValues"
    [multiple]="true"
    [appearance]="appearance"
    [vertical]="vertical"
    (change)="onToggleChange($event.value)"
    class="toggle-group"
  >
    @for (option of options; track option.value) {
      <mat-button-toggle [value]="option.value" [disabled]="option.disabled">
        @if (option.icon) {
          <app-icon [fontIcon]="option.icon"></app-icon>
        }
        <span>{{ option.label }}</span>
      </mat-button-toggle>
    }
  </mat-button-toggle-group>
} @else {
  <div class="toggle-buttons" [class.vertical]="vertical">
    @for (option of options; track option.value) {
      <app-button
        [text]="option.label"
        [fontIcon]="option.icon || ''"
        [color]="option.color || (isSelected(option) ? 'primary' : 'secondary')"
        [appearance]="isSelected(option) ? 'raised' : 'flat'"
        [disabled]="option.disabled || false"
        (btnClick)="onClick(option)"
        [class.selected]="isSelected(option)"
      ></app-button>
    }
  </div>
}

`,
      styles: [".toggle-group{display:flex;flex-wrap:wrap;gap:8px}.toggle-buttons{display:flex;gap:8px;flex-wrap:wrap}.toggle-buttons.vertical{flex-direction:column}.toggle-buttons app-button.selected{opacity:1}\n"]
    }]
  }], null, {
    options: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    multiple: [{
      type: Input
    }],
    appearance: [{
      type: Input
    }],
    vertical: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    buttonClick: [{
      type: Output
    }]
  });
})();
var TreeStructureComponent = class _TreeStructureComponent {
  constructor() {
    this.data = [];
    this.expandable = true;
    this.showIcons = true;
    this.nodeSelect = new EventEmitter();
    this.treeControl = new FlatTreeControl((node) => node.level, (node) => node.expandable);
    this.treeFlattener = new MatTreeFlattener((node, level) => ({
      expandable: !!node.children && node.children.length > 0,
      name: node.name,
      level,
      icon: node.icon,
      data: node.data
    }), (node) => node.level, (node) => node.expandable, (node) => node.children);
    this.dataSource = new MatTreeFlatDataSource(this.treeControl, this.treeFlattener);
    this.hasChild = (_, node) => node.expandable;
  }
  ngOnInit() {
    this.dataSource.data = this.data;
  }
  ngOnChanges(changes) {
    if (changes["data"]) {
      this.dataSource.data = this.data;
    }
  }
  onNodeClick(node) {
    const treeNode = {
      name: node.name,
      icon: node.icon,
      data: node.data
    };
    this.nodeSelect.emit(treeNode);
  }
  static {
    this.ɵfac = function TreeStructureComponent_Factory(t) {
      return new (t || _TreeStructureComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _TreeStructureComponent,
      selectors: [["app-tree-structure"]],
      inputs: {
        data: "data",
        expandable: "expandable",
        showIcons: "showIcons"
      },
      outputs: {
        nodeSelect: "nodeSelect"
      },
      standalone: true,
      features: [ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
      decls: 3,
      vars: 3,
      consts: [[1, "tree-structure", 3, "dataSource", "treeControl"], ["matTreeNodePadding", "", 4, "matTreeNodeDef"], ["matTreeNodePadding", "", 4, "matTreeNodeDef", "matTreeNodeDefWhen"], ["matTreeNodePadding", ""], ["mat-icon-button", "", "disabled", ""], [1, "node-icon", 3, "fontIcon"], [1, "node-label", 3, "click"], ["mat-icon-button", "", "matTreeNodeToggle", ""], [1, "mat-icon-rtl-mirror"]],
      template: function TreeStructureComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "mat-tree", 0);
          ɵɵtemplate(1, TreeStructureComponent_mat_tree_node_1_Template, 5, 2, "mat-tree-node", 1)(2, TreeStructureComponent_mat_tree_node_2_Template, 7, 4, "mat-tree-node", 2);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵproperty("dataSource", ctx.dataSource)("treeControl", ctx.treeControl);
          ɵɵadvance(2);
          ɵɵproperty("matTreeNodeDefWhen", ctx.hasChild);
        }
      },
      dependencies: [CommonModule, MatTreeModule, MatTreeNodeDef, MatTreeNodePadding, MatTreeNodeToggle, MatTree, MatTreeNode, MatIconModule, MatIcon, MatButtonModule, MatIconButton, IconComponent],
      styles: [".tree-structure[_ngcontent-%COMP%]{background-color:transparent}.node-label[_ngcontent-%COMP%]{cursor:pointer;padding:4px 8px;border-radius:4px;transition:background-color .2s}.node-label[_ngcontent-%COMP%]:hover{background-color:#f5f5f5}.node-icon[_ngcontent-%COMP%]{margin-right:8px;font-size:20px;width:20px;height:20px}"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TreeStructureComponent, [{
    type: Component,
    args: [{
      selector: "app-tree-structure",
      standalone: true,
      imports: [CommonModule, MatTreeModule, MatIconModule, MatButtonModule, IconComponent],
      template: `<mat-tree [dataSource]="dataSource" [treeControl]="treeControl" class="tree-structure">
  <mat-tree-node *matTreeNodeDef="let node" matTreeNodePadding>
    <button mat-icon-button disabled></button>
    @if (showIcons && node.icon) {
      <app-icon [fontIcon]="node.icon" class="node-icon"></app-icon>
    }
    <span class="node-label" (click)="onNodeClick(node)">{{ node.name }}</span>
  </mat-tree-node>

  <mat-tree-node *matTreeNodeDef="let node; when: hasChild" matTreeNodePadding>
    <button mat-icon-button matTreeNodeToggle [attr.aria-label]="'Toggle ' + node.name">
      <mat-icon class="mat-icon-rtl-mirror">
        {{ treeControl.isExpanded(node) ? 'expand_more' : 'chevron_right' }}
      </mat-icon>
    </button>
    @if (showIcons && node.icon) {
      <app-icon [fontIcon]="node.icon" class="node-icon"></app-icon>
    }
    <span class="node-label" (click)="onNodeClick(node)">{{ node.name }}</span>
  </mat-tree-node>
</mat-tree>

`,
      styles: [".tree-structure{background-color:transparent}.node-label{cursor:pointer;padding:4px 8px;border-radius:4px;transition:background-color .2s}.node-label:hover{background-color:#f5f5f5}.node-icon{margin-right:8px;font-size:20px;width:20px;height:20px}\n"]
    }]
  }], null, {
    data: [{
      type: Input
    }],
    expandable: [{
      type: Input
    }],
    showIcons: [{
      type: Input
    }],
    nodeSelect: [{
      type: Output
    }]
  });
})();
var RadioButtonComponent = class _RadioButtonComponent {
  constructor() {
    this.options = [];
    this.value = null;
    this.label = "";
    this.name = "";
    this.color = "primary";
    this.disabled = false;
    this.vertical = false;
    this.labelTemplateRef = null;
    this.valueChange = new EventEmitter();
    this.onChange = (value) => {
    };
    this.onTouched = () => {
    };
  }
  writeValue(value) {
    this.value = value;
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  onSelectionChange(value) {
    this.value = value;
    this.onChange(value);
    this.onTouched();
    this.valueChange.emit(value);
  }
  static {
    this.ɵfac = function RadioButtonComponent_Factory(t) {
      return new (t || _RadioButtonComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _RadioButtonComponent,
      selectors: [["app-radio-button"]],
      inputs: {
        options: "options",
        value: "value",
        label: "label",
        name: "name",
        color: "color",
        disabled: "disabled",
        vertical: "vertical",
        labelTemplateRef: "labelTemplateRef"
      },
      outputs: {
        valueChange: "valueChange"
      },
      standalone: true,
      features: [ɵɵProvidersFeature([{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => _RadioButtonComponent),
        multi: true
      }]), ɵɵStandaloneFeature],
      decls: 6,
      vars: 9,
      consts: [[1, "radio-button-container"], [1, "radio-group", 3, "ngModelChange", "change", "ngModel", "name", "color", "disabled"], [3, "value", "disabled"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "radio-group-label"]],
      template: function RadioButtonComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "div", 0);
          ɵɵtemplate(1, RadioButtonComponent_Conditional_1_Template, 1, 5, "ng-container")(2, RadioButtonComponent_Conditional_2_Template, 2, 1);
          ɵɵelementStart(3, "mat-radio-group", 1);
          ɵɵtwoWayListener("ngModelChange", function RadioButtonComponent_Template_mat_radio_group_ngModelChange_3_listener($event) {
            ɵɵtwoWayBindingSet(ctx.value, $event) || (ctx.value = $event);
            return $event;
          });
          ɵɵlistener("change", function RadioButtonComponent_Template_mat_radio_group_change_3_listener($event) {
            return ctx.onSelectionChange($event.value);
          });
          ɵɵrepeaterCreate(4, RadioButtonComponent_For_5_Template, 2, 3, "mat-radio-button", 2, _forTrack0);
          ɵɵelementEnd()();
        }
        if (rf & 2) {
          ɵɵclassProp("vertical", ctx.vertical);
          ɵɵadvance();
          ɵɵconditional(1, ctx.labelTemplateRef ? 1 : ctx.label ? 2 : -1);
          ɵɵadvance(2);
          ɵɵclassProp("vertical", ctx.vertical);
          ɵɵtwoWayProperty("ngModel", ctx.value);
          ɵɵproperty("name", ctx.name)("color", ctx.color)("disabled", ctx.disabled);
          ɵɵadvance();
          ɵɵrepeater(ctx.options);
        }
      },
      dependencies: [CommonModule, NgTemplateOutlet, FormsModule, NgControlStatus, NgModel, MatRadioModule, MatRadioGroup, MatRadioButton, MatFormFieldModule],
      styles: [".radio-button-container[_ngcontent-%COMP%]{display:flex;flex-direction:column;gap:8px}.radio-group-label[_ngcontent-%COMP%]{font-size:14px;font-weight:500;color:#424242}.radio-group[_ngcontent-%COMP%]{display:flex;gap:16px;flex-wrap:wrap}.radio-group.vertical[_ngcontent-%COMP%]{flex-direction:column;gap:8px}"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioButtonComponent, [{
    type: Component,
    args: [{
      selector: "app-radio-button",
      standalone: true,
      imports: [CommonModule, FormsModule, MatRadioModule, MatFormFieldModule],
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => RadioButtonComponent),
        multi: true
      }],
      template: '<div class="radio-button-container" [class.vertical]="vertical">\n  @if (labelTemplateRef) {\n    <ng-container *ngTemplateOutlet="labelTemplateRef; context: { $implicit: label, label: label }"></ng-container>\n  } @else if (label) {\n    <label class="radio-group-label">{{ label }}</label>\n  }\n  <mat-radio-group\n    [(ngModel)]="value"\n    [name]="name"\n    [color]="color"\n    [disabled]="disabled"\n    (change)="onSelectionChange($event.value)"\n    class="radio-group"\n    [class.vertical]="vertical"\n  >\n    @for (option of options; track option.value) {\n      <mat-radio-button [value]="option.value" [disabled]="option.disabled || disabled">\n        {{ option.label }}\n      </mat-radio-button>\n    }\n  </mat-radio-group>\n</div>\n\n',
      styles: [".radio-button-container{display:flex;flex-direction:column;gap:8px}.radio-group-label{font-size:14px;font-weight:500;color:#424242}.radio-group{display:flex;gap:16px;flex-wrap:wrap}.radio-group.vertical{flex-direction:column;gap:8px}\n"]
    }]
  }], null, {
    options: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    vertical: [{
      type: Input
    }],
    labelTemplateRef: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }]
  });
})();
var CarouselComponent = class _CarouselComponent {
  constructor() {
    this.items = [];
    this.height = "400px";
    this.width = "100%";
    this.autoPlay = false;
    this.autoPlayInterval = 3e3;
    this.showIndicators = true;
    this.showControls = true;
    this.loop = true;
    this.itemChange = new EventEmitter();
    this.currentIndex = 0;
  }
  ngOnInit() {
    if (this.autoPlay && this.items.length > 1) {
      this.startAutoPlay();
    }
  }
  ngOnChanges(changes) {
    if (changes["items"] && this.items.length > 0) {
      if (this.currentIndex >= this.items.length) {
        this.currentIndex = 0;
      }
    }
    if (changes["autoPlay"]) {
      if (this.autoPlay) {
        this.startAutoPlay();
      } else {
        this.stopAutoPlay();
      }
    }
  }
  ngOnDestroy() {
    this.stopAutoPlay();
  }
  startAutoPlay() {
    this.stopAutoPlay();
    if (this.autoPlay && this.items.length > 1) {
      this.autoPlayTimer = setInterval(() => {
        this.next();
      }, this.autoPlayInterval);
    }
  }
  stopAutoPlay() {
    if (this.autoPlayTimer) {
      clearInterval(this.autoPlayTimer);
      this.autoPlayTimer = null;
    }
  }
  next() {
    if (this.currentIndex < this.items.length - 1) {
      this.currentIndex++;
    } else if (this.loop) {
      this.currentIndex = 0;
    }
    this.emitItemChange();
  }
  previous() {
    if (this.currentIndex > 0) {
      this.currentIndex--;
    } else if (this.loop) {
      this.currentIndex = this.items.length - 1;
    }
    this.emitItemChange();
  }
  goTo(index) {
    if (index >= 0 && index < this.items.length) {
      this.currentIndex = index;
      this.emitItemChange();
    }
  }
  emitItemChange() {
    if (this.items[this.currentIndex]) {
      this.itemChange.emit({
        index: this.currentIndex,
        item: this.items[this.currentIndex]
      });
    }
  }
  get currentItem() {
    return this.items[this.currentIndex] || null;
  }
  static {
    this.ɵfac = function CarouselComponent_Factory(t) {
      return new (t || _CarouselComponent)();
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _CarouselComponent,
      selectors: [["app-carousel"]],
      contentQueries: function CarouselComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          ɵɵcontentQuery(dirIndex, _c102, 5);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.itemTemplate = _t.first);
        }
      },
      inputs: {
        items: "items",
        height: "height",
        width: "width",
        autoPlay: "autoPlay",
        autoPlayInterval: "autoPlayInterval",
        showIndicators: "showIndicators",
        showControls: "showControls",
        loop: "loop"
      },
      outputs: {
        itemChange: "itemChange"
      },
      standalone: true,
      features: [ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
      decls: 7,
      vars: 7,
      consts: [[1, "carousel-container"], [1, "carousel-wrapper"], [1, "carousel-content"], [1, "carousel-indicators"], ["appearance", "icon", "type", "button", 3, "btnClick", "fontIcon"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "carousel-item-default"], [1, "carousel-image", 3, "src", "alt"], [1, "carousel-title"], [1, "carousel-description"], ["appearance", "icon", "type", "button", 3, "class"], ["appearance", "icon", "type", "button", 3, "btnClick"]],
      template: function CarouselComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "div", 0)(1, "div", 1);
          ɵɵtemplate(2, CarouselComponent_Conditional_2_Template, 2, 6);
          ɵɵelementStart(3, "div", 2);
          ɵɵtemplate(4, CarouselComponent_Conditional_4_Template, 1, 5, "ng-container")(5, CarouselComponent_Conditional_5_Template, 4, 3);
          ɵɵelementEnd()();
          ɵɵtemplate(6, CarouselComponent_Conditional_6_Template, 3, 0, "div", 3);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵstyleProp("width", ctx.width)("height", ctx.height);
          ɵɵadvance(2);
          ɵɵconditional(2, ctx.showControls && ctx.items.length > 1 ? 2 : -1);
          ɵɵadvance(2);
          ɵɵconditional(4, ctx.itemTemplate && ctx.currentItem ? 4 : ctx.currentItem ? 5 : -1);
          ɵɵadvance(2);
          ɵɵconditional(6, ctx.showIndicators && ctx.items.length > 1 ? 6 : -1);
        }
      },
      dependencies: [CommonModule, NgTemplateOutlet, AppButtonComponent],
      styles: [".carousel-container[_ngcontent-%COMP%]{position:relative;overflow:hidden;border-radius:4px}.carousel-wrapper[_ngcontent-%COMP%]{position:relative;width:100%;height:100%}.carousel-control[_ngcontent-%COMP%]{position:absolute;top:50%;transform:translateY(-50%);background-color:#00000080;color:#fff;border:none;border-radius:50%;width:40px;height:40px;display:flex;align-items:center;justify-content:center;cursor:pointer;z-index:10;transition:background-color .2s}.carousel-control[_ngcontent-%COMP%]:hover{background-color:#000000b3}.carousel-control[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{font-size:24px;width:24px;height:24px}.carousel-control.prev[_ngcontent-%COMP%]{left:16px}.carousel-control.next[_ngcontent-%COMP%]{right:16px}.carousel-content[_ngcontent-%COMP%]{width:100%;height:100%;display:flex;align-items:center;justify-content:center}.carousel-item-default[_ngcontent-%COMP%]{width:100%;height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;padding:32px}.carousel-image[_ngcontent-%COMP%]{max-width:100%;max-height:100%;object-fit:contain;margin-bottom:16px}.carousel-title[_ngcontent-%COMP%]{font-size:24px;font-weight:500;margin-bottom:8px;color:#424242}.carousel-description[_ngcontent-%COMP%]{font-size:16px;color:#757575}.carousel-indicators[_ngcontent-%COMP%]{position:absolute;bottom:16px;left:50%;transform:translate(-50%);display:flex;gap:8px;z-index:10}.indicator[_ngcontent-%COMP%]{width:12px;height:12px;border-radius:50%;border:2px solid white;background-color:#ffffff80;cursor:pointer;transition:background-color .2s}.indicator[_ngcontent-%COMP%]:hover{background-color:#fffc}.indicator.active[_ngcontent-%COMP%]{background-color:#fff}"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CarouselComponent, [{
    type: Component,
    args: [{
      selector: "app-carousel",
      standalone: true,
      imports: [CommonModule, AppButtonComponent],
      template: `<div class="carousel-container" [style.width]="width" [style.height]="height">
  <div class="carousel-wrapper">
    @if (showControls && items.length > 1) {
      <app-button
        appearance="icon"
        type="button"
        [class]="'carousel-control prev'"
        [fontIcon]="'chevron_left'"
        (btnClick)="previous()"
      ></app-button>
      <app-button
        appearance="icon"
        type="button"
        [class]="'carousel-control next'"
        [fontIcon]="'chevron_right'"
        (btnClick)="next()"
      ></app-button>
    }

    <div class="carousel-content">
      @if (itemTemplate && currentItem) {
        <ng-container *ngTemplateOutlet="itemTemplate; context: { $implicit: currentItem, index: currentIndex }"></ng-container>
      } @else if (currentItem) {
        <div class="carousel-item-default">
          @if (currentItem.image) {
            <img [src]="currentItem.image" [alt]="currentItem.title || 'Carousel item'" class="carousel-image" />
          }
          @if (currentItem.title) {
            <div class="carousel-title">{{ currentItem.title }}</div>
          }
          @if (currentItem.description) {
            <div class="carousel-description">{{ currentItem.description }}</div>
          }
        </div>
      }
    </div>
  </div>

  @if (showIndicators && items.length > 1) {
    <div class="carousel-indicators">
      @for (item of items; track $index) {
        <app-button
          appearance="icon"
          type="button"
          [class]="'indicator' + (currentIndex === $index ? ' active' : '')"
          (btnClick)="goTo($index)"
          [attr.aria-label]="'Go to slide ' + ($index + 1)"
        ></app-button>
      }
    </div>
  }
</div>

`,
      styles: [".carousel-container{position:relative;overflow:hidden;border-radius:4px}.carousel-wrapper{position:relative;width:100%;height:100%}.carousel-control{position:absolute;top:50%;transform:translateY(-50%);background-color:#00000080;color:#fff;border:none;border-radius:50%;width:40px;height:40px;display:flex;align-items:center;justify-content:center;cursor:pointer;z-index:10;transition:background-color .2s}.carousel-control:hover{background-color:#000000b3}.carousel-control mat-icon{font-size:24px;width:24px;height:24px}.carousel-control.prev{left:16px}.carousel-control.next{right:16px}.carousel-content{width:100%;height:100%;display:flex;align-items:center;justify-content:center}.carousel-item-default{width:100%;height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;padding:32px}.carousel-image{max-width:100%;max-height:100%;object-fit:contain;margin-bottom:16px}.carousel-title{font-size:24px;font-weight:500;margin-bottom:8px;color:#424242}.carousel-description{font-size:16px;color:#757575}.carousel-indicators{position:absolute;bottom:16px;left:50%;transform:translate(-50%);display:flex;gap:8px;z-index:10}.indicator{width:12px;height:12px;border-radius:50%;border:2px solid white;background-color:#ffffff80;cursor:pointer;transition:background-color .2s}.indicator:hover{background-color:#fffc}.indicator.active{background-color:#fff}\n"]
    }]
  }], null, {
    items: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    autoPlay: [{
      type: Input
    }],
    autoPlayInterval: [{
      type: Input
    }],
    showIndicators: [{
      type: Input
    }],
    showControls: [{
      type: Input
    }],
    loop: [{
      type: Input
    }],
    itemTemplate: [{
      type: ContentChild,
      args: ["carouselItemTemplate"]
    }],
    itemChange: [{
      type: Output
    }]
  });
})();
var ChartComponent = class _ChartComponent {
  constructor(chartService) {
    this.chartService = chartService;
    this.height = "100%";
    this.width = "100%";
    this.chartInstance = null;
  }
  ngOnInit() {
    if (this.chartOptions$) {
      this.subscription = this.chartOptions$.subscribe((options) => {
        this.renderChart(options);
      });
    } else if (this.chartOptions) {
      this.renderChart(this.chartOptions);
    }
  }
  ngOnChanges(changes) {
    if (changes["chartOptions"] && this.chartOptions && !this.chartOptions$) {
      this.renderChart(this.chartOptions);
    }
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
    if (this.chartInstance) {
      this.chartInstance.destroy();
    }
  }
  renderChart(options) {
    if (this.chartContainer) {
      if (this.chartInstance) {
        this.chartInstance.destroy();
      }
      this.chartInstance = this.chartService.createChart(this.chartContainer.nativeElement, options);
    }
  }
  static {
    this.ɵfac = function ChartComponent_Factory(t) {
      return new (t || _ChartComponent)(ɵɵdirectiveInject(ChartService));
    };
  }
  static {
    this.ɵcmp = ɵɵdefineComponent({
      type: _ChartComponent,
      selectors: [["app-chart"]],
      viewQuery: function ChartComponent_Query(rf, ctx) {
        if (rf & 1) {
          ɵɵviewQuery(_c123, 7);
        }
        if (rf & 2) {
          let _t;
          ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.chartContainer = _t.first);
        }
      },
      inputs: {
        chartOptions$: "chartOptions$",
        chartOptions: "chartOptions",
        height: "height",
        width: "width"
      },
      standalone: true,
      features: [ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
      decls: 3,
      vars: 4,
      consts: [["chartContainer", ""], [1, "chart-container"], [1, "chart-content"]],
      template: function ChartComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "div", 1);
          ɵɵelement(1, "div", 2, 0);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵstyleProp("width", ctx.width)("height", ctx.height);
        }
      },
      dependencies: [CommonModule],
      styles: [".chart-container[_ngcontent-%COMP%]{width:100%;border:1px solid #e0e0e0;border-radius:4px;padding:16px;background-color:#fff}.chart-content[_ngcontent-%COMP%]{width:100%;height:100%}"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChartComponent, [{
    type: Component,
    args: [{
      selector: "app-chart",
      standalone: true,
      imports: [CommonModule],
      template: '<div class="chart-container" [style.width]="width" [style.height]="height">\n  <div #chartContainer class="chart-content"></div>\n</div>\n\n',
      styles: [".chart-container{width:100%;border:1px solid #e0e0e0;border-radius:4px;padding:16px;background-color:#fff}.chart-content{width:100%;height:100%}\n"]
    }]
  }], () => [{
    type: ChartService
  }], {
    chartOptions$: [{
      type: Input
    }],
    chartOptions: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    chartContainer: [{
      type: ViewChild,
      args: ["chartContainer", {
        static: true
      }]
    }]
  });
})();
var TranslatePipe = class _TranslatePipe {
  constructor() {
    this.translations = {
      "en": {
        "exercise": "Exercise",
        "exercise_set": "Exercise Set",
        "exercises": "Exercises",
        "exercise_sets": "Exercise Sets",
        "set_id": "Set ID",
        "exercise_id": "Exercise ID",
        "set_number": "Set Number",
        "reps": "Reps",
        "hold_time": "Hold Time",
        "rest_time": "Rest Time",
        "name": "Name",
        "description": "Description",
        "created_by": "Created By",
        "exercise_type": "Exercise Type",
        "strength": "Strength",
        "core": "Core",
        "flexibility": "Flexibility",
        "cardio": "Cardio",
        "add": "Add",
        "edit": "Edit",
        "delete": "Delete",
        "save": "Save",
        "cancel": "Cancel",
        "search": "Search",
        "filter": "Filter",
        "clear": "Clear",
        "loading": "Loading...",
        "no_data": "No data available",
        "error": "Error",
        "success": "Success",
        "warning": "Warning",
        "info": "Information"
      },
      "es": {
        "exercise": "Ejercicio",
        "exercise_set": "Conjunto de Ejercicios",
        "exercises": "Ejercicios",
        "exercise_sets": "Conjuntos de Ejercicios",
        "set_id": "ID del Conjunto",
        "exercise_id": "ID del Ejercicio",
        "set_number": "Número de Conjunto",
        "reps": "Repeticiones",
        "hold_time": "Tiempo de Mantenimiento",
        "rest_time": "Tiempo de Descanso",
        "name": "Nombre",
        "description": "Descripción",
        "created_by": "Creado Por",
        "exercise_type": "Tipo de Ejercicio",
        "strength": "Fuerza",
        "core": "Núcleo",
        "flexibility": "Flexibilidad",
        "cardio": "Cardio",
        "add": "Agregar",
        "edit": "Editar",
        "delete": "Eliminar",
        "save": "Guardar",
        "cancel": "Cancelar",
        "search": "Buscar",
        "filter": "Filtrar",
        "clear": "Limpiar",
        "loading": "Cargando...",
        "no_data": "No hay datos disponibles",
        "error": "Error",
        "success": "Éxito",
        "warning": "Advertencia",
        "info": "Información"
      },
      "fr": {
        "exercise": "Exercice",
        "exercise_set": "Série d'Exercices",
        "exercises": "Exercices",
        "exercise_sets": "Séries d'Exercices",
        "set_id": "ID de Série",
        "exercise_id": "ID d'Exercice",
        "set_number": "Numéro de Série",
        "reps": "Répétitions",
        "hold_time": "Temps de Maintien",
        "rest_time": "Temps de Repos",
        "name": "Nom",
        "description": "Description",
        "created_by": "Créé Par",
        "exercise_type": "Type d'Exercice",
        "strength": "Force",
        "core": "Noyau",
        "flexibility": "Flexibilité",
        "cardio": "Cardio",
        "add": "Ajouter",
        "edit": "Modifier",
        "delete": "Supprimer",
        "save": "Enregistrer",
        "cancel": "Annuler",
        "search": "Rechercher",
        "filter": "Filtrer",
        "clear": "Effacer",
        "loading": "Chargement...",
        "no_data": "Aucune donnée disponible",
        "error": "Erreur",
        "success": "Succès",
        "warning": "Avertissement",
        "info": "Information"
      }
    };
  }
  transform(value, language = "en", params) {
    if (!value) {
      return "";
    }
    const langTranslations = this.translations[language] || this.translations["en"];
    let translation = langTranslations[value] || value;
    if (params) {
      Object.keys(params).forEach((key) => {
        const regex = new RegExp(`{{${key}}}`, "g");
        translation = translation.replace(regex, params[key]);
      });
    }
    return translation;
  }
  // Method to get available languages
  getAvailableLanguages() {
    return Object.keys(this.translations);
  }
  // Method to check if a translation exists
  hasTranslation(key, language = "en") {
    const langTranslations = this.translations[language] || this.translations["en"];
    return !!langTranslations[key];
  }
  static {
    this.ɵfac = function TranslatePipe_Factory(t) {
      return new (t || _TranslatePipe)();
    };
  }
  static {
    this.ɵpipe = ɵɵdefinePipe({
      name: "translate",
      type: _TranslatePipe,
      pure: true,
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TranslatePipe, [{
    type: Pipe,
    args: [{
      name: "translate",
      standalone: true
    }]
  }], null, null);
})();
var TooltipPipe = class _TooltipPipe {
  transform(value, config) {
    if (!value) {
      return "";
    }
    if (typeof config === "string") {
      return this.formatTooltip(value, {
        text: config
      });
    }
    if (config && typeof config === "object") {
      return this.formatTooltip(value, config);
    }
    return this.formatTooltip(value, {});
  }
  formatTooltip(value, config) {
    let tooltipText = config.text || this.generateDefaultTooltip(value);
    if (typeof value === "object") {
      tooltipText = this.formatObjectTooltip(value, tooltipText);
    } else if (typeof value === "string") {
      tooltipText = this.formatStringTooltip(value, tooltipText);
    } else if (typeof value === "number") {
      tooltipText = this.formatNumberTooltip(value, tooltipText);
    } else if (typeof value === "boolean") {
      tooltipText = this.formatBooleanTooltip(value, tooltipText);
    }
    const attributes = this.generateTooltipAttributes(config);
    return `${tooltipText}${attributes}`;
  }
  generateDefaultTooltip(value) {
    if (typeof value === "string") {
      return value.length > 50 ? `${value.substring(0, 50)}...` : value;
    }
    if (typeof value === "object") {
      return JSON.stringify(value);
    }
    return String(value);
  }
  formatObjectTooltip(obj, baseText) {
    if (obj.name) {
      return `${obj.name}${obj.description ? ` - ${obj.description}` : ""}`;
    }
    if (obj.title) {
      return `${obj.title}${obj.subtitle ? ` - ${obj.subtitle}` : ""}`;
    }
    if (obj.label) {
      return `${obj.label}${obj.value ? `: ${obj.value}` : ""}`;
    }
    return baseText;
  }
  formatStringTooltip(str, baseText) {
    if (str.length > 100) {
      return `${str.substring(0, 100)}...`;
    }
    return str;
  }
  formatNumberTooltip(num, baseText) {
    if (num >= 1e6) {
      return `${(num / 1e6).toFixed(1)}M`;
    }
    if (num >= 1e3) {
      return `${(num / 1e3).toFixed(1)}K`;
    }
    return num.toString();
  }
  formatBooleanTooltip(bool, baseText) {
    return bool ? "Yes" : "No";
  }
  generateTooltipAttributes(config) {
    const attributes = [];
    if (config.position) {
      attributes.push(`data-position="${config.position}"`);
    }
    if (config.delay) {
      attributes.push(`data-delay="${config.delay}"`);
    }
    if (config.showArrow !== void 0) {
      attributes.push(`data-arrow="${config.showArrow}"`);
    }
    if (config.customClass) {
      attributes.push(`data-class="${config.customClass}"`);
    }
    if (config.maxWidth) {
      attributes.push(`data-max-width="${config.maxWidth}"`);
    }
    if (config.html) {
      attributes.push('data-html="true"');
    }
    return attributes.length > 0 ? ` ${attributes.join(" ")}` : "";
  }
  // Utility methods for common tooltip patterns
  static createStatusTooltip(status, additionalInfo) {
    const statusMap = {
      "active": "Active - Currently in use",
      "inactive": "Inactive - Not currently in use",
      "pending": "Pending - Awaiting approval",
      "completed": "Completed - Finished successfully",
      "cancelled": "Cancelled - No longer active",
      "draft": "Draft - Not yet finalized"
    };
    const baseText = statusMap[status.toLowerCase()] || `Status: ${status}`;
    return additionalInfo ? `${baseText}
${additionalInfo}` : baseText;
  }
  static createDateTooltip(date, format2) {
    const dateObj = typeof date === "string" ? new Date(date) : date;
    const now = /* @__PURE__ */ new Date();
    const diffTime = Math.abs(now.getTime() - dateObj.getTime());
    const diffDays = Math.ceil(diffTime / (1e3 * 60 * 60 * 24));
    let relativeText = "";
    if (diffDays === 0) {
      relativeText = "Today";
    } else if (diffDays === 1) {
      relativeText = "Yesterday";
    } else if (diffDays < 7) {
      relativeText = `${diffDays} days ago`;
    } else if (diffDays < 30) {
      const weeks = Math.floor(diffDays / 7);
      relativeText = `${weeks} week${weeks > 1 ? "s" : ""} ago`;
    } else {
      const months = Math.floor(diffDays / 30);
      relativeText = `${months} month${months > 1 ? "s" : ""} ago`;
    }
    const formattedDate = dateObj.toLocaleDateString("en-US", {
      year: "numeric",
      month: "long",
      day: "numeric",
      hour: "2-digit",
      minute: "2-digit"
    });
    return `${formattedDate}
(${relativeText})`;
  }
  static createProgressTooltip(current, total, unit) {
    const percentage = Math.round(current / total * 100);
    const unitText = unit || "";
    return `${current}${unitText} of ${total}${unitText}
${percentage}% complete`;
  }
  static createUserTooltip(user) {
    if (!user) return "Unknown user";
    const parts = [];
    if (user.name) {
      parts.push(user.name);
    }
    if (user.email) {
      parts.push(user.email);
    }
    if (user.role) {
      parts.push(`Role: ${user.role}`);
    }
    if (user.department) {
      parts.push(`Dept: ${user.department}`);
    }
    return parts.join("\n");
  }
  static {
    this.ɵfac = function TooltipPipe_Factory(t) {
      return new (t || _TooltipPipe)();
    };
  }
  static {
    this.ɵpipe = ɵɵdefinePipe({
      name: "tooltip",
      type: _TooltipPipe,
      pure: true,
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TooltipPipe, [{
    type: Pipe,
    args: [{
      name: "tooltip",
      standalone: true
    }]
  }], null, null);
})();
var SafePipe = class _SafePipe {
  constructor(sanitizer) {
    this.sanitizer = sanitizer;
  }
  transform(value, type) {
    switch (type) {
      case "resourceUrl":
        return this.sanitizer.bypassSecurityTrustResourceUrl(value);
      case "script":
        return this.sanitizer.bypassSecurityTrustScript(value);
      case "url":
        return this.sanitizer.bypassSecurityTrustUrl(value);
      case "style":
        return this.sanitizer.bypassSecurityTrustStyle(value);
      case "html":
        return this.sanitizer.bypassSecurityTrustHtml(value);
      default:
        throw new Error(`Invalid safe type specified: ${type}`);
    }
  }
  static {
    this.ɵfac = function SafePipe_Factory(t) {
      return new (t || _SafePipe)(ɵɵdirectiveInject(DomSanitizer, 16));
    };
  }
  static {
    this.ɵpipe = ɵɵdefinePipe({
      name: "safe",
      type: _SafePipe,
      pure: true,
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SafePipe, [{
    type: Pipe,
    args: [{
      name: "safe",
      standalone: true
    }]
  }], () => [{
    type: DomSanitizer
  }], null);
})();

export {
  CoreEventService,
  API_BASE_URL,
  ApiConfigService,
  UserType,
  AccountStatus,
  AuthService,
  Observe,
  ResponseType,
  HttpUtilService,
  HttpService,
  DataService,
  MenuService,
  HttpCallsService,
  ChartService,
  SnackbarService,
  AuthGuard,
  LoginGuard,
  HttpInterceptorService,
  CommonUtils,
  CHIP_COLORS,
  AppInputComponent,
  AppSelectboxComponent,
  IconComponent,
  AppButtonComponent,
  DatePickerComponent,
  DIALOG_DATA_TOKEN,
  FilterComponent,
  GridMenuRendererComponent,
  ConfirmationDialogWrapperComponent,
  DialogboxService,
  DialogboxComponent,
  GridComponent,
  NotesDialogComponent,
  ConfirmationDialogComponent,
  StatusCellRendererComponent,
  ChipCellRendererComponent,
  CheckboxComponent,
  CalendarComponent,
  ImageComponent,
  UploadboxComponent,
  PageBodyDirective,
  FooterDirective,
  PageComponent,
  GridListFiltersComponent,
  DividerComponent,
  LoaderComponent,
  JsonReflectComponent,
  PdfViewerComponent,
  QrCodeGeneratorComponent,
  RichTextEditorComponent,
  SliderComponent,
  TooltipDirective,
  ButtonCheckboxComponent,
  StepperComponent,
  StepComponent,
  TabComponent,
  TabsComponent,
  ToggleButtonComponent,
  TreeStructureComponent,
  RadioButtonComponent,
  CarouselComponent,
  ChartComponent,
  TranslatePipe,
  TooltipPipe,
  SafePipe
};
//# sourceMappingURL=chunk-QLFOHGLH.js.map
